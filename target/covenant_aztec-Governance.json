{
  "transpiled": true,
  "noir_version": "1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec",
  "name": "Governance",
  "functions": [
    {
      "name": "cast_vote",
      "is_unconstrained": false,
      "custom_attributes": [
        "external",
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "proposal_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "choice",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 32
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "285656119219400463": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 32 limbs"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3085686765229567191": {
            "error_kind": "string",
            "string": "Invalid choice"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5641381842727637878": {
            "error_kind": "string",
            "string": "Got more notes than limit."
          },
          "5672954975036048158": {
            "error_kind": "string",
            "string": "Collapse hint vec length mismatch"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7506220854563469239": {
            "error_kind": "string",
            "string": "Dirty collapsed vec storage"
          },
          "7542496824365424242": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10583567252049806039": {
            "error_kind": "string",
            "string": "Wrong collapsed vec order"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11499495063250795588": {
            "error_kind": "string",
            "string": "Wrong collapsed vec content"
          },
          "11553125913047385813": {
            "error_kind": "string",
            "string": "Wrong collapsed vec length"
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "11751673056818044221": {
            "error_kind": "string",
            "string": "Proposal not found"
          },
          "11873158822563704285": {
            "error_kind": "string",
            "string": "Mismatch return note field."
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "14748239111032984011": {
            "error_kind": "fmtstring",
            "length": 17,
            "item_types": []
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15431201120282223247": {
            "error_kind": "string",
            "string": "Out of bounds index hint"
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16953505913640931790": {
            "error_kind": "string",
            "string": "Not a member"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "TJ3LrizLbl3/5bbdqGAEH6FfccPwGwIECfCjJfjfvZIMcs6O9phXZ8eIykyyqnJx5f73f/y3//5f/u///E///K//49/+9z/+6T/++z/+y//653/5l3/+n//pX/7tv/7n//PP//avf//rv//j9/2fdf7xT2Lr/L//8I/15SP/+Kf1H/5xdv1x6g+tP6z+8Poj6o+bf+iv/lj1R62itYrWKlqraK2itYrWKlqrWK1itYrVKlarWK1itYrVKlarWK1itYrXKl6reK3itYrXKl6reK3itYrXKl6rRK0StUrUKlGrRK0StUrUKlGrRK0StcqtVW6tcmuVW6vcWuXWKrdWubXKrVVurbJ+v/fnen/K+3O/P8/7U9+f9v7092e8P99666233nrrrbfeeuutt95666233nrrrbf+1tt/f8rv/bnen/L+/FvPvj/P+1Pfn/b+/Fvvfn9+6+VfuA/2r2E1SMNu+HbpH2iDNXjDt3J8cB+cX8O38vcq8qJP2A1fWZwPtMEavCEa7oOvCApWgzTshl5Ze2XtlbVX/opCvsPzlUXCVxgFq0EadsNp0AZr8IZe2Xpl75W9V/Ze2Xtl75W9V/Ze2Xtl75W9V45eOXrl6JWjV45eOXrlr5jkOztfORVEw33wFVXBapCG3XAatKFXvr3y7ZXvW1l+v4bVIA274TRogzV4QzT0yqtXXr3y6pVXr7x65dUrr1559cqrV169svTK0itLryy9svTK0itLryy9svTK0ivvXnn3yrtX3r3y7pV3r7x75d0r715598qnVz698umVT698euXTK59e+fTKp1c+vbL2ytorfzW41we74TRogzV4QzTcB18NFqyGXtl6ZeuVrVf+anCfD7whGr6V/7qffDVYsBqkYTecBm2wBm+Ihl45euXolaNXjteRJE6DNliDN0TD63Vyfw2rQRp65dsr31759spfDR75IBpuwf5qsGA1SMNuOA3aYA3eEA298uqVV6/81eDZH+yG06AN1uAN0XAffDVYsBp6ZemVpVeWXvmrQf194A3RcB98NViwGqRhN5wGbeiVd6+8e+XdK59e+fTKp1c+vfLplU+vfHrl0yufXvn0ytora6+svbL2ytora6+svbL2ytora69svbL1ytYrW69svbL1ytYrW69svbL1yt4re6/svbL3yt4re6/svbL3yt4re68cvXL0ytErR68cvXL0ytErR68cvXL0yrdXvr3y7ZVvr3x75dsr31759sq3V75v5fP7NawGadgNp0EbrMEboqFXXr3y6pVXr7x65dUrr1559cqrV1698uqVpVeWXll6ZemVpVeWXrlr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNnq7B0zV4ugZP1+DpGjxdg6dr8HQNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DWrXoHYNategdg1q16B2DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1a16B1DVrXoHUNWtegdQ1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrXoHcNetegdw1616B3DXrX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",
      "verification_key": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJpAAAAAAAAAAAAAAAAAAAA3tIm\nIW+DcYdpznhNa2mxBf8AAAAAAAAAAAAAAAAAAAAAAAwbKD49U9s78mnOUDC6YgAAAAAAAAAAAAAA\nAAAAAC2oGh1FQ0r52IWeOK0aBATsAAAAAAAAAAAAAAAAAAAAAAAEr2QmzpEzHzatA+Uo2YEAAAAA\nAAAAAAAAAAAAAABchoR7du/RBG/r32l3q6EQAAAAAAAAAAAAAAAAAAAAAAAAEnZOPzSdCPxZjCEj\nJoOxAAAAAAAAAAAAAAAAAAAA46wpvFeCRZPKqR3s7DU9NwEAAAAAAAAAAAAAAAAAAAAAAAQKI69d\n6Iz0dPgyIbXkaAAAAAAAAAAAAAAAAAAAACGpOfjrOOA/glxPnyEGfRPSAAAAAAAAAAAAAAAAAAAA\nAAAWhptB9pHpJ1dLMUj4Q2AAAAAAAAAAAAAAAAAAAAAXjI2YyKScUmpPfxd5mNW3dQAAAAAAAAAA\nAAAAAAAAAAAAIPbI9dk57aieUI1wzKeUAAAAAAAAAAAAAAAAAAAAphOg9AKvoc+HwGcrGXbHR90A\nAAAAAAAAAAAAAAAAAAAAAB9THA6rDNJlio3teK6JXQAAAAAAAAAAAAAAAAAAAG5FLqUmO7PY6VuE\n0QnGu42CAAAAAAAAAAAAAAAAAAAAAAAezmnsQCt4jsgmzllgC0cAAAAAAAAAAAAAAAAAAADYb1Dj\n9Xa02pN5tjQYvZpHpQAAAAAAAAAAAAAAAAAAAAAAF6iebRE4RqnBmNAbp3EVAAAAAAAAAAAAAAAA\nAAAA6C9L87MQHDYRqkjWW8WAk/4AAAAAAAAAAAAAAAAAAAAAABrJquI/SQPlcKgv3Opw3AAAAAAA\nAAAAAAAAAAAAAH+VNdhIK6uD+sHIhpTjC5iuAAAAAAAAAAAAAAAAAAAAAAAXalBBzklSR/sJV3JL\nxygAAAAAAAAAAAAAAAAAAABIP6JXVdluiJionmAvLzQruAAAAAAAAAAAAAAAAAAAAAAAHLvGOpjB\nTXadmwFT0T9DAAAAAAAAAAAAAAAAAAAAIjx7zf4ErK3TUbUjPHWvo0EAAAAAAAAAAAAAAAAAAAAA\nABJB8o1i6Ip9b013Xwim2AAAAAAAAAAAAAAAAAAAANbtA9MMEnI01SmAvBq147tMAAAAAAAAAAAA\nAAAAAAAAAAAB4gue2VkVG3TYKDAdd9gAAAAAAAAAAAAAAAAAAACpYO0E7RgiavfiNMUPto6zLAAA\nAAAAAAAAAAAAAAAAAAAAH5TAAP1cwiS/0+cpUCw4AAAAAAAAAAAAAAAAAAAAf2bfOy4Wx90Wkg6C\np3acxZEAAAAAAAAAAAAAAAAAAAAAAAhRWG4qQOBJrmhi9vWEmgAAAAAAAAAAAAAAAAAAAN4XgO6I\nTKYe12AIliQDufDuAAAAAAAAAAAAAAAAAAAAAAAfOePN3Fh7bAmdwt81Oz4AAAAAAAAAAAAAAAAA\nAAApvXaEMHCinW8yjcol4JnGNAAAAAAAAAAAAAAAAAAAAAAAIQmGBEXVrFsDjZ4kAs6SAAAAAAAA\nAAAAAAAAAAAAvtYiIzMJKhCBwEwsqs8ZguAAAAAAAAAAAAAAAAAAAAAAACs8qAUEX9TNu4GImOJ5\n6QAAAAAAAAAAAAAAAAAAAG04Dp5UQQqWwnlbViE6VDhTAAAAAAAAAAAAAAAAAAAAAAAmHM9nTnrj\nEljDc0b3SjAAAAAAAAAAAAAAAAAAAAAKtVZMD3qtsRdC6lcawkW6eQAAAAAAAAAAAAAAAAAAAAAA\nBuELO/3IDDq3zn++UAckAAAAAAAAAAAAAAAAAAAAzWNw5F8oy5V21yemDaDmnLQAAAAAAAAAAAAA\nAAAAAAAAACDCR7+Ydrmpg8m4ijeHOgAAAAAAAAAAAAAAAAAAAIzbmc0DjBM0KnWzcsP9XAgDAAAA\nAAAAAAAAAAAAAAAAAAAZHZ5IYk4KQn1/RC8c+4AAAAAAAAAAAAAAAAAAAABCqEjY+Mx1NY/qlktO\nQA9DVQAAAAAAAAAAAAAAAAAAAAAAIkWczLbFJYpLaEsjhAAeAAAAAAAAAAAAAAAAAAAAu40KrxWt\nUHMUKc6dUA+L7eAAAAAAAAAAAAAAAAAAAAAAAAPZA6T2tVbVMvVGftb3XQAAAAAAAAAAAAAAAAAA\nAPxWP3hhvjWZAnc1CUBivFIAAAAAAAAAAAAAAAAAAAAAAAAfgzJHCuZ1H66fvaGxUxUAAAAAAAAA\nAAAAAAAAAACPFLiDB2Xw8gbsyOuduhZTLwAAAAAAAAAAAAAAAAAAAAAAFbujnRI2YmBxGiOmtU+w\nAAAAAAAAAAAAAAAAAAAAOqB/Y9U9ZBoj497JeiCLB08AAAAAAAAAAAAAAAAAAAAAAAUVUm2dY5xL\neHvhzFMOKwAAAAAAAAAAAAAAAAAAAP6ZQSIcNCmLg36OQGIjbQUlAAAAAAAAAAAAAAAAAAAAAAAJ\nF/nxl5ofOtLIdHyXld8AAAAAAAAAAAAAAAAAAADQaJnTBE8Err4FcFeCqxMrngAAAAAAAAAAAAAA\nAAAAAAAAAleikDRcLcoCmBohUMK9AAAAAAAAAAAAAAAAAAAA1+doO6m0E4r5OOU1g+YY5jsAAAAA\nAAAAAAAAAAAAAAAAAA1gn1v2j1wAHsYkD2Nm8gAAAAAAAAAAAAAAAAAAAOCKIeuBG8nHDFGxCVZb\ntkvvAAAAAAAAAAAAAAAAAAAAAAAmh6WoMVCDOyqDRYnZZWsAAAAAAAAAAAAAAAAAAABMqfGgAT0G\nimM3l7KKT7UCAwAAAAAAAAAAAAAAAAAAAAAABzgkBPnVHHM3MSvI2R9IAAAAAAAAAAAAAAAAAAAA\nhPTqSB68hMipA/YcPgXGo4IAAAAAAAAAAAAAAAAAAAAAAC5dcnOv+eTbRV0VMSsl8AAAAAAAAAAA\nAAAAAAAAAPgE53M9SsoeCzQ8Cq5pyagBAAAAAAAAAAAAAAAAAAAAAAAcC1aY4nwZhVPt9izleg4A\nAAAAAAAAAAAAAAAAAACl8MX5mi2ipEAEuXg94RBEEQAAAAAAAAAAAAAAAAAAAAAAED8+b2FP+GtT\nCZbPWlzSAAAAAAAAAAAAAAAAAAAAiyIEEuHmRqh2xdJi0xNXiccAAAAAAAAAAAAAAAAAAAAAACPV\nb1xWHz6ZLs3mtVz/nAAAAAAAAAAAAAAAAAAAABIDdZ7ZHZtwOHw63rDwIFldAAAAAAAAAAAAAAAA\nAAAAAAAr6OUFehBYvfjEpZ6vozYAAAAAAAAAAAAAAAAAAAC/17KlkMXfBBsxiPJaFtTuIgAAAAAA\nAAAAAAAAAAAAAAAAJcG2Lp0Vpf1XAafA1yI5AAAAAAAAAAAAAAAAAAAARbttkq4Ks9ARYRoZCVje\n1XUAAAAAAAAAAAAAAAAAAAAAAAzF/pM+AyI8wVW2XKTNnwAAAAAAAAAAAAAAAAAAAIgS8eJrn+MP\nWHhqrK1ZgL3GAAAAAAAAAAAAAAAAAAAAAAAe8tHOvq8RIIW23JcmoMgAAAAAAAAAAAAAAAAAAACG\nlMKGkqMiSf4kgIT8uWjIcQAAAAAAAAAAAAAAAAAAAAAAL7NvWZH68FsGNFJlMNmlAAAAAAAAAAAA\nAAAAAAAAJGN5P3yaRTKpVTLGvg3Bxa0AAAAAAAAAAAAAAAAAAAAAAABa/a0GyfykA3OcdSVM4AAA\nAAAAAAAAAAAAAAAAABsyJdqTtaLAwNt9rjP6QWIHAAAAAAAAAAAAAAAAAAAAAAAvE+4gEOBetc74\nhnSYXCYAAAAAAAAAAAAAAAAAAABxr3g0+2pxJ+/P8zIJCElD3AAAAAAAAAAAAAAAAAAAAAAAHaRN\nk/VZ5FWtS/SjIiSOAAAAAAAAAAAAAAAAAAAAixAep8zZ8wzyQfpEtCVRKUcAAAAAAAAAAAAAAAAA\nAAAAACDQ/Q/WYTq3ZLXo5FCe1wAAAAAAAAAAAAAAAAAAAFizPZI63otdBEhBnUg0Xl+BAAAAAAAA\nAAAAAAAAAAAAAAAorT+MiWPqoo2xOyPO9TIAAAAAAAAAAAAAAAAAAACe1XxR9U4oXDTtSWep/t/5\nwAAAAAAAAAAAAAAAAAAAAAAAHhXa0jS1bGGnpVJQqKzmAAAAAAAAAAAAAAAAAAAAYx8/ayUS6OK6\nwi4J3r8TDiwAAAAAAAAAAAAAAAAAAAAAACGqgNoJupA1TkV9PQbJGAAAAAAAAAAAAAAAAAAAAHTR\n02JqV4LjEinXD7AjqxONAAAAAAAAAAAAAAAAAAAAAAAgveQqOWlou79Of2EQxiYAAAAAAAAAAAAA\nAAAAAAC/cOMgV5JmbRB4Lfgky4mDBQAAAAAAAAAAAAAAAAAAAAAALT7USRibmwMGX6XBt0h+AAAA\nAAAAAAAAAAAAAAAA70JLLYunou4TQHZUN+vS/1cAAAAAAAAAAAAAAAAAAAAAACKwd3QIwJ0gm8XB\nZkrCzQAAAAAAAAAAAAAAAAAAAGBSsDFWpMNlG2T75KQkCAAIAAAAAAAAAAAAAAAAAAAAAAAXpSn4\nAHnnpj3rkDGPgS8AAAAAAAAAAAAAAAAAAAAUkC2e5eP8MdkMvIKIdhOBegAAAAAAAAAAAAAAAAAA\nAAAAAZxwvhZxJTvWaKHUbFbrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABLf4lvOoYcCv4U\nTp2HP/5oKgAAAAAAAAAAAAAAAAAAAAAAH1MeFr9lYRVJ+rn2Apn2AAAAAAAAAAAAAAAAAAAAv6fC\nLfPWIfmOjexOS88w22UAAAAAAAAAAAAAAAAAAAAAABB+bGzlkklgisoHg4eaQgAAAAAAAAAAAAAA\nAAAAAGvMegX/lalrKJQkxfczZw2WAAAAAAAAAAAAAAAAAAAAAAAAxDcm91tv2g3iLODg36sAAAAA\nAAAAAAAAAAAAAAAdCgnXF47JO614WPluZPC0jQAAAAAAAAAAAAAAAAAAAAAAL5tuC04sAZaN5cMk\ngqp9AAAAAAAAAAAAAAAAAAAAs8PPbbWlw3xztOqrx8K9tdUAAAAAAAAAAAAAAAAAAAAAAAGaqh23\nOphDKX3dUwWgOQAAAAAAAAAAAAAAAAAAAPMofO4kQhdTybsV1xRQMcptAAAAAAAAAAAAAAAAAAAA\nAAAFiSRi70jt/BTMpcaOrm4="
    },
    {
      "name": "constructor",
      "is_unconstrained": false,
      "custom_attributes": [
        "external",
        "initializer",
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "name",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          },
          {
            "name": "symbol",
            "type": {
              "kind": "string",
              "length": 31
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "364657447181031001": {
            "error_kind": "string",
            "string": "invalid admin"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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ugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Bq1r0LoGrWvQugata9C6Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LsGvWvQuwa9a9C7Br1r0LMGzwe3QRq+ke0Da/CGeJA1mLAadsNpuA3S0CNLjyw9svTI2iNrj6w9svbI2iNrj6w9svbI2iNrj2w9svXI1iNbj2w9svXI1iNbj2w9svXI3iN7j+w9svfI3iN7j+w9svfI3iN7jxw9cvTI0SNHjxw9cvTI0SNHjxw9cryR4/drWA274TTcBmnQBmvwhh559cirR1498uqRV4+8euTVI68eefXIq0fePfLukXePvHvk3SPvHnn3yLtH3j3y7pFPj3x65NMjnx759MinRz498umRT498euTbI98e+fbIt0e+PfLtkbsGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNrMLoGo2swugajazC6BqNr8O9j+N/QGtpDZ+gOyZAO2ZAPjccajzUeazzWeKzxWOOxxmONxxqPNR57PPZ47PHY47HHY4/HHo89Hns89nic8TjjccbjjMcZjzMeZzzOeJzxOONxx+OOxx2POx53PO543PG443HH446HjIeMh4yHjIeMh4yHjIeMh4yHjIeOh46HjoeOh46HjoeOh46HjoeOh42HjYeNh42HjYeNh42HjYeNh42Hj4ePh4+Hj4ePh4+Hj4ePh4+Hj0eMR4xHjEeMR4xHjEeMR4xHjMfU+Zo6X1Pna+p8TZ2vqfM1db6mztfU+Zo6X1Pna+p8TZ2vqfM1db6mztfU+Zo6X1Pna+p8TZ2v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",
      "verification_key": "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\nAAAFiSRi70jt/BTMpcaOrm4="
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "external",
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+y9CZwdR3Uu3lezWCON5mrfbV9blrVYlrxb3i3LCwav2JbBDhjZlg3GxmDLmJ2BsK/e2Mwm2WCWEAhZyPoSCOQRAoRHwgsPEh4kJGwJBBLI45H8X/5pqc/cb775um519+nRldT9+9lz1VX1napT55w6dWrpVrL3aWd/n33XnTftuPvuG+74r/9tv3XHNf/1qpUlDWZ/D8n+pu/nJZMfy9tJop5WgbyTCxWg0UrqpzEjqZ/GQFI/jcGkfhpDSf00hpP6aRyS1E9jZlI/jZGkfhqzkvppzE7qpzGa1E9jTlI/jbGkfhrtpH4ac5PiNMrQmZdMD5358Xn3YJ8r3hWhtyCpv48WJvXTWJTUT2NxUj+NJUn9NJYm9dNYltRPY3lSP40VSf00Vib10zg0qZ/GYUn9NA5P6qfRSeqncURSP40jk/pprErqp3FUUj+N1Un9NI5O6qexJqmfxtqkfhrrkvpprE/qp3FMUj+NDUn9NI5N6qexMamfxqakfhrHJfXTOD6pn8YJSf00Tkzqp3FSUj+Nk5P6aZyS1E/j1KR+GpuT+mmcltRP4/SkfhpnJPXTODOpn8ZZSf00zk7qp3FOUj+Nc5P6aWxJ6qdxXlI/ja1J/TTOT+qncUFSP40Lk/ppXJTUT+NxSf00Lk7qp/H4pH4aT0jqp3FJUj+NS5P6aVyW1E/j8qR+Glck9dO4MqmfxhOT4jTK0LkqmR46VyfTQ+eapASdbUQw3dCQbjhINwSkC/bpgnq64J0uSKcLxumCbrrgmi6IpguW6YJiuuCXLsili2XpQla6uJQu/qSLM+niSbq4kS4+pIsDafA+Da6nwe80OJ0Gjy24e8R//ZcGL9PgYhr8S4NzafAsDW6lwac0OJQGb9LgShr8SIMTafAgndynk+90cpxOXtPJZTr5Sydn6eQpndykk490cpA676lznTq/qXOaOo+pc3fuf/2XOkep85I6F+ngnw7O6eCZDm7p4JMODqnxTo1ravxS45Qaj1S5U+VLlSMV3lSw0k6/Jsl/rHNz9t/88/a9r2dmyTOgWIH9IK2ZRK5Y+fGPz2TAQuWTgZlZmZnlym+z8iPlyu8R3/S5frxbHutiuAPZ39vHu2VvH59M0/J8FPJ8lPJYfUvy+/qK7Z03mkxuo2EkULdZ5bDnY5vsGaB3iD+SVOr7VovwjB63z3Rj1PKMd+m1KG1wfGo9LW0I0oz/qelbD/m4b2dSmtUlfUx+LG0A0u7I0qxPBgGzgLw8q6K8nFujvGzZH+VlkNIGx6fWs6i8YN+yvAwl3cdsiaUNQ9rHKO0QSPu18S7tk6Eel2W/K9qkj1v5kmPQHpeA6SPWnvqOd/ObjAzAO+O18X4m5qe0EUgbHJ9MZ1b270Ggg1iHQDrmPyn791j2dxjKWPm2oD9M9CfVW7xjvoyI/CMifypHx1qdk66cbYW8nSTqGbCy54+Lsj+9+6uPff6Nv/GZD+78wPvfOu/rc94xe8Osl77ylf+84kcrH/7xKx+1sheMd9vRSqJpD1v5C8cF7bN/e+C6p3/8F3fOvuiXP3bv17922T1zVm7/48Nf8/7r/uT+w79/w6us7EWq7Pfe8M6Xtj/2wK7OMV/82fBFb/6nG/714qHNX//ii5Z9+uX/8f0fP2hlH6fK/sV1//GN32w/+ILnvfF3X7h57YLtH3nwqz/5wWc//9H2v/7trz7nqydb2YvHu20u46M9frxbvsh+XCv/hPFS5SfoXzJeqvwMK3/peLd8gfbPtfKXjXdfduzHy973wW9seeMXj/v2f8x63aXbX/G8E1//l9f+8AVLP7D6H2771ZUfmWdlL1dl/27n1vt3LrnjlB/O/NIbj9+94tBv/vQDv/ndf3v+js3/9N3vfeKIf7WyV4iyS09Yc9qz3/4/Fv7N2iP/+txPfmTjQ8t+etSZf/M7j9v941987udJl+dXjpdq8wTPnjheqvyglb9qvFT5CR2/erxbvoCeTsjMNeOlyk/Q3zZeqvwE/64d777shMtMuCFW9knj0WXtGbKyTx6fWnb9mSM/fv/rXvLK5Fsf+Mc3/dv6Pzj32HmHbZm38Svv/KsVz7rr+mU/trLXjXcrVKDPVqZ2PR3XP7J974t0Gn5UlnjPzmfc/oydz99y99077tq59c47nr195zNuvH3H5Xdtv+n2Hdt23HX3M+58FgO26N9bx/X7lM7SyXQu2rHzmr2/tt75rJ07nrdziHDZnxyhf8+if8+mf0/4WPQe/cfBJP4xv2kO4am/STLVT00fG2vbhIXtMV9pDNIKyPUVVr5drvwOKz+3XPm7rPy8cuVvsfLzy5W/08ovKFf+Diu/sFz5Z1j5ReXKT8zHFpcrf6uVX1KufMfKLy1X/m4rv6xc+e1Wfnm58jdb+RXlyt9k5VeWK/9cK39oufLPNztzGLw0G2LYh8P7Avb/0Bg7hfgjVJeifmmL8Iwetw/n08grLNsWaSEbOSDezQhgtR2x5jpizXPEmu+I5dnGBY5YCx2xFjliLXbEWuKI5cl7Tx1a2qdYyxyxPGXCk/ee8rXcEctTtz1lYoUjlqeNXumI1a/jo/lZ5jugr9HK+Wt0+J3RGSGsVlLO7+kQPa6f0ZuZTG1Xkfi40TtC0FN+luU/MrJ+6dza+j+bv5+/48Z7br3kzlsTenhKfcG4ruLKZHL1O4GqMW6L/uP3jD0g8uKTNs9Mcda8C3fsvOnpV2+/9dYdN/9XI+/mEox0/rh+b0J5hChrnX4k1bSTRD0zYoQa8UeoLmWFWgkNtg+FxoxZxtVL7tx+89btz777ntt34DIniilTaREqvlN92oKa4btZlO/88cn/ttD7QJL/sCytgjTFCcMcS6a2aVVOOVZZfjdD5D+SsI4U5azuA4HyiIHlWGJCUh0jldaO9Gkn+e2fmUzlRyeJe6yOR4o6Gu4qeF9AExbGap7hjySVNL0VkjdsHw8nR5Wjt6BF5ZEeYlp9jNerRZphHZ39ewiwMP9R0AbMj7/TZ5DefS772xaYbFNWJ1Pbg+9wKfTT1DbkPctRFT4jntUL3yH+SFJJbluhfsX2sRytLkdvfgzfsT7G66NFmmGtyf6NcoT5V0MbMD/+Tp9BevfV7G9bYLIcHS3ag+9Qjr5MbUPesxyV5HP0NhnDH0kqyW0r1K/YPpajo8vROzeG71gf4/UakWZYa7N/oxxh/qOhDZgff6fPIL37h+xvW2CyHK0R7cF3KEffzH7PzGlPJ4l6bld9UaD8vTOTqe0qUH6nlV9brvzTrfy6cuVfaOXXlyt/nJU/plz5F5tsboCXbAeOhfdFlndj7YDhj1BdytqBY4ket4/D+xtFXdoijcP7GwWdjYKOwprriDXfEWuFI1bbEWtpn2ItdMRa5Ii12BFriSPWakcsT7nvV34d7YjlKatrHLHWOmJ58t6zjcscsfpVVtc5Yq13xDLfyMZ79A9a2d+ZolzRuSXiWT3xHeKPUF0K0muF+ILt4znPpnL05rWoPNJDTKuP8fo4kWZYx2f/xjkP5t8EbcD8+Dt9BundyRnD2wKT5zzHifbgO5zzbMpwx0R7VhFuUXnF8sxDLMfyWqU/Ec/qie8QfySppB+tkPwovlj7jitHb25M/2J9jNfHizTDOiH7N8or5j8O2oD58Xf6DNK7C0leEZPl9XjRHnyH8npua3LbkPcsRyX5fEGsHBn+SFJJbluhfsX2sRwdX47e+TF8x/oYr08QaYZ1YvZvlCPMfzy0AfPj7/QZpHdXkxwhJsvRCaI9+A7l6LIMd2ZOezpJ3MM6ZhiIjXWO76fWT2Ll0PBHkkpy0QrxUemjte/EUvRaP2bZQXqIafUxXp8k0gzLjtahHGL+E6ENmB9/p88gvbuJ5BAxWXZOEu3BdyiHTyF7hrxnOSrH5+S8WDky/JGkitx25Uj1q9JHa99J5ehtieE71sd4fbJIM6xTsn+jHGH+k6ANmB9/p88gvXsOyRFisj07WbQH36EcPZPsGbYnfTpJ1NNSfVGg/BTeIoZhI68K9PN/xsqx4Y8kU3lcRo5PIXp5/WBtP1XUpS3SkMeYhnROFXQarAarwWqwGqwGq8Hav7FObLAOCKyDQb4aHWr6sbETjT7ur1iNfDWyejDKauNPNPxq2tjwfn/FamS1kYmDkV+NfDX9eDBiNTrUyMTByPvGrjY61PCrweqF1cytmjY2NrqR1f0Vq5Gvpl4NVqOP09nGBquxOc041LSxaWNjcxp+Nf3YyNf+i9XEOpo2NjansRMNViP3jQ41vG90qMHqZ1lt/IlGJhreN7yfTqxmHGr41ehQg9ULq99lwu6lxTvD+Hs16n6uUwJ0sLzlGxXlWtnfmaJ+KZ1OEvVE31tm+CPJ1DYXoNcK8V/xxdq+WdSlLdK4nzcLOpsFnQarOtZJfYrVtPHA4NfBUK8G68DQx8ZONFiNrDb2fjrr1fRj08ZGvpqxY3+tVyMTDb8a+Wr6scFqdKiRiYOT941dbXSo4VeD1QurmVs1bWxsdCOr+ytWI19NvRqsRh+ns40NVmNzmnGoaWPTxsbmNPxq+rGRr/0Xq4l1NG1sbE5jJxqsRu4bHWp43+hQg9XPstr4E41MNLxveD+dWM041PCr0aEGqxdWIxMNVoPVYDVYDVaD1WAd6FjqzrD0v04S9Vw9U2AXKH+DlT+tXPnnWPnTy5V/nt0pdga8bGV/DftMeD8Qj318i/CSrDy+Q/wRqktBehP3qZ1J9Lh9JhfW9rNEXdoijWXkLEHnLEFHYa11xGo7Yi1xxFrhiLXaEWuZI9ZCR6wFjlieMrHcEWuzI9ZSR6zTHLHmOmKtccTy1O11jliettBTHxc5Ynn24zGOWJ4y4cl7T932bKOnTMx3xOpXO+FZr4PBZ2rGtH3He099nOeI5dnG0/u0Xp7+hGcbbaxVc+H0v04S9dzDc03DQOyz4X2Bee/ZLcJLsvL4DvFHkqntLDPPPpvo5fHV2n6OqEtbpPE8+xxB5xxBR2GtdcRqO2It6dM2LnTEWuSItcYRy5P36xyxmn4shnWMI5anTCx3xJrviOVpv5Y6Ynny3lNWPXnfr/bLU1Y95WuBI5ZnP3rKl6cOecrXXEesZX3axn715Tzb6OlP9Gs/9qsvd7ojVr/6OZ4+ZuNPHBg65GknPOvlKV+nOWKd6YjlyXtPH8DGWosDnQblWtnfijGwI1qEZ/XEd4g/kkztS68YGLbP+GLtO6ccvU5MP2B9jNfnijTD2pL9ewiwMP850AbMj7/TZ5De3Tm8929bYB5HdTg3mdoefDcD6viMDHdMtId1UvXL2QK3LcozD7Ecy2vJ/hyIlVfDH0kq6UcrJD+KL0p+rKzqV+b/uYLOuYJOCIvjxpaePjNFuQL8GIzl/7nZ75GkUn+3QnxRdtTavkXUpS3SDoPfrJ8D4t2Macbi/kqfThJ8rDum8MKwEfc8eF+gX4Zi5cDwR5KpbSwjB+cRvTyeWtu3irq0RRr33VZBZ6ugsz9hnZv9Nt4gL1kusFyBfpoXKxeGP5JUksNWiC/YPvYnzi9Hb26LyiM9xLT6GK8vEGmGdWH2b/QnMP/50AbMj7/TZ5DePUL+BGKyP3GBaA++Q3/iXeRPKB0rK69YnnmI5VheS/ZntB0z/JGkkn60QvKj+KLkx8qqfmX+x/br/ohl8nd+gE5ITxUdLH9+gM45FemcE0lnS0U6WwSdUVGO9Qn5HS/frW/F6pPhjySV9LcVkifFF2vfhaXotb7JNhvpIabVx3h9kUgzrMdl/0b7j/kvhDZgfvydPoP07nNk/xGT7f9Foj34Du3/p8n+Y3t4PlNUz7E88xDLsbyW68+kHSuvhj+SVNGPrrwq+VF8sfZdVI7eWEz/Yn2M148TaYZ1cfZvlFfMfxG0AfPj7/QZpHdfJ3lFTPaDHyfag+9QXr+S4c7MaU8niXouU31RoPzfzkymtqtA+eOt/MXlyu+y8o8vV36dlX9CufK/Y+UvKVf+Ait/abnyn7Dyl5Ur/zIrf3m58k+y8leUK/8UK39lufJrrfwTy5U/0cpfVa7896z81eXKP87KX1Ou/O9a+W3lyj/byl9brvz9Vv5J5cpvtfJPLlf+Z1b+unLlH7Ty15cr/2Mr/xQoXySWb+VvKFd+wOr7VHwp6mT4Nhb+EuRv5fw1LE4zWiOEVbDurVDdsX7sTz0V6GEb87CeWhBrpkgr0ydPSfLbhfijgbqoeq6H31XbvNwR60JHrLmOWBc5Yj3OEetiR6zHO2I9wRFrzBHrEkesSx2xLutTrMsdsa5wxLrSEeuJjlhXOWJd7Yh1qCPWNY5Y2xyxrnXEepIjlufY8WRHrOscsa53xDquD7HS5+rxvX8rxjsurhivOL1ivOLSivGKqyrGG7ZUjDdcVDFecH7FeMEl5ms/EV62sr8qFlDA77+sRXhJoudPhj9CdSlIb2L+dBXR4/bxutvVoi5tkcY6crWgc7Wgo7AWOWKtdMRa5oi12hFroSPWckesJY5YCxyx2o5YS/sUy1NWFztiefL+YkcsT1n11Mc1fdpGT3080xHLU4f6lfdrHbE87YTnWOtpJzx578mvfpUvT9/Esx89eX8w2Il1jliPd8S6xBHrCX2Kdakj1mWOWJ6839yn9brcEWvMEctTJi50xLrCEcuzHz3r5Smr/WoLT3XE8pRVz370rFe/8stTVq90xPKUVU/7dYwjlqf/Nc8Ra6EjlqdP7jlX8Iw9mn9vcezLoVwr+1sxhj/WIjyrJ75D/BGqS0F6wRg+to/3Tl9djt6cmH7A+hivrxFphmVrt7h3GvNfDW3A/Pg7fQbp3U8O2fu3LTAPozpcI9qD73Dv9D8eMrltyHuWo5J8XhkrR4Y/klSS21aoX7F9vBak+knxm33mWH4rrLmOWPMdsVY4YrUdsZb2KdZCR6xFjliLHbGWOGJtc8Ty1CHPflzpiLXMEWuNI5anbnvKl6cOedrVg4H3CxyxPG202UI714j+zOFEp6hvjuUtX8XzME+seB5mW8XzLJdXPI9yoflV18HLVvZXnTUp4OO9rEV4SaJ9SsMfoboUpDfhU15P9Lh97FM+RdSlLdJ4f5E6L/EUQUdhLXLEWumItcwRa7Uj1kJHrOWOWEscsbY5Ys11xPLkfb/K6hpHrLYjlqd8edqc+Y5YBwPvF/RpG5f2KZanbi92xPLk/cWOWJ6y2q8+gCdWM24Xw2rG7X0nX824ve9434zb+063+3Xc9uRXv8rqmY5YnvzytDmevF/riOWpQ57jdr/a6H71Jzzb6On7evajJ+8PBjuxzhFrzBHrakcszzj5NY5YlzpineqIdYkj1mZHrAsdsa51xDoYeP94R6wnOGJd5ojlya8nOWJ5yqqnDvWr3PdrGw8GW+hZr2bsODDGjic7Ynn6cp78utIR6wpHLM+x1lMmPPnVr2PHMY5YnnO+eY5Ynms6nnEAz/iE5/4cPoODe8Na2d+KdyLPaRGe1RPfIf4I1aUgvVaIL9g+40vF+4FHW1Qe6ak7gI3XN4g0w3pa9m88g4P5nwptwPz4O30G6d2FI3v/tgUmn8G5IZnaHnw3A+p47sjktiHvWY5K8vmoWDni+6xLym3wPmulX6pfraziN8enYvmtsOY6Ys13xFrhiNV2xFrap1gLHbEWOWItdsRa4oi1zRFrmSOWpz6uccTylC9Pfq12xPKUL08d8rSrnjLhaVf7Vbc99dFTh1Y6Ynnq48EgXwscsTx9AD7jhf7y4USn6B3aWD7veyWWnj4Vv2dzf4vwrJ74DvFHkqltLuOzK/4rvljbnybq0hZpHO97mqDzNEFHYS1yxFrpiLXMEWu1I9ZCR6zljlhLHLG2OWLNdcTy5H2/yuoaR6y2I5anfHnanPmOWAcD7xc4Ynm2cWmfYnnq9mJHLE/eX+yI5Smr/eoDeGL167jtyXtPH8DTRnv6E/0qq824ve/sauOTF8NqfPJ9J1+NX7jv5Ktf/UJPfvWrrJ7piOXJL0+b48n7tY5YnjrkOXb0q43u1zHNs42evq9nP3ry/mCwE+scscYcsS51xLraEetURyzP9SFPfl3piLXZEetCR6xrHbE8ZeISRyxP3nvqtqc+eurQNY5Ynvp4MMjX4x2xnuCIdZkjlie/nuSI5WkLPW10v8p9v7bxYBhrPevV+CYHxtjxZEcsT3/Ck1+ePvkVjlieY62nTHjyq1/HjmMcsTxjCvMcsTzXrTzjTJ7xL8/9hXxGE/e2trK/M0W5lE4niXpGW4Rn9cR3iD9CdSlIrxXii9onbe3bXo7e7BaVR3qI+bTst/H6RpFmWDdl/8Yzmph/O7QB8+Pv9Bmkd5+dtfdvW2DyGc0bRXvw3Qyo46dmTW7b0yAfy1FJPn8qVo4MfySpJLetUL8+Dd6xHN1Yjt4nY/iO9TF6N5WjN2B9tUNgW11uyf6Ncoj5rV4zKD/+Tp9BevfXJC83QznDb4s0ltGbgcaAeDdjH2HtEFjIN9Tv/5HxQulH+l8niXpOYLtiGIhdUlaujdU9wx9JKulCi+2g0cuzQUqOrKzqL463Ven7NX2K1XbEWuCItc0Ry5NfCx2xFjliLXbEWtKnbZzfp/Va4YjlqY+e/bjcEctTh5Y6Ynn2o6esrnTE8pSvuY5Yhzpiecp9v9oczzauc8Ra74h1jCOWJ788fRNP+epXv9BT7vvVl1vmiLXaEetg8OX6Ve49fZNmTCuG1a++XL/aQk9fztMWevajJ7/61f96nCNWv/pf8xyxPHXbU4c8+eU5DnnqUL/y3tN+ecbl+jU25Clfnr5vv/qY/Tp2bHfEsrFjlLAtPX0qrjcd2iI8qye+Q/yRZGo7vdabsH1l15t4P3y/2ENPPerXWLmnDfPEatabimF5xuY8dcizHz3XAzx9nX6Nw3jKl2e9+nVdp19jFJ796LlXwdPe892r6Bvx3avKD7kpQAfLW75RUa6V/Z0p6lfAX3pli/CsnvgO8UeSqW0u458p/iu+qL1tVrYt0ngff2j/FtJRWIscsVY6Yi1zxFrtiLXQEWu5I9YSR6xtjlhzHbE8ed+vsrrGEavtiOUpX5718uxHz3p52lVPmfDsxwWOWJ68X9qnWJ52YrEjlifv+R7XfpHVfvUnPLEaH2DfjR2ND7Dv6tX4APuuHxsfYN/ZiX71ATz51a+yeqYjlie/+tVOrHXE8tShfh07+tX37Vf5Wu2I5dmPnrw/GOzEOkesMUesqx2xPOP31zhiXeqIdaoj1iWOWJv7tF6e/ehZrwsdsTxlwrMfH++I9QRHrMscsTz59SRHrGsdsfpVVht93Hdt7Ff5asahRu4Z68mOWJ4+pmc/XumIdYUjlue47SkTnvzqV308xhHLcy46zxHLc93KMz6x2hHLcz+TxTps/yHO5c8hOmOCzliADpa3fDNFuU4S9Zxh+/dOhZctwkV7PBCPPdgivCQrj+8Qf4TqUpDexN7Fi4get894am2/WNSlLdI4JnOxoHOxoKOwDqsBS/VX+l8niXqumSmwC5R/pvHz8fCSZQnHqgJ9uzRWlgx/hOpSVpaeQPS4fSxLl4m6tEUa99Flgs5lgo7CWuSIdXGf1mu+I9bRjliebVziiLXAEWupI9ZiRyxPfq1xxDrUEWubI1bbEcuT9wsdsZb3aRvXOWKtd8Sy+ctYMnVcYl9V+VUXBehg+YsCdLZUpLNF0BkV5VrZ34q+yIYW4Vk98R3ijyRT2+zliyi+FPVFOHbTL+P0mY5YnuN0v9qYlY5YyxyxVjtiHQxjRb/6zZ71WuGI5enXePq6njIxzxHLUybmOmJ58svTfvXrPMOzHz3r1a9jh2c/evLeU7cPpjlLv/GrX8dtT92uY6y1+QrOb1rZ35miXB1zNcMfoboUpNcK8QXbx3O1K0Vd2iKN142vFHSuFHQU1kJHrKWOWCscseY7Yq10xGo7Ys3t03otd8Ra4oi1zhFrvSPWMY5Ynvxa5IjlqY9rHLE85d7TFnr24zxHLE+b4ykTCxyxPHm/rE/rtc0Ry1MmPH0Tz3Hbsx/71X55ypenPvarjfbE8pSvxY5Yxvux7N84H7ue6BSdE2J5y6fmfel/nSTquZHnVYaB2HgursAc76YW4SWJnlMa/kgylZ9l5pRXE728/rO2XyPq0hZpvLf2GkHnGkFHYZ3uiLXNEavtiLXCEWtNn7ZxuSPWEkcsT5lY5ojlKRMXO2IdDDKxyBFrviNWv+q2J+89+TXPEcuzjasdsTz70VPuFztiecr9WkcsT5lY54jlKRON/3Vg2GjPsXazI9bBYAuPccTytDmXOWKd6YjlqUOe/PIc0/rVL+zXMa1f51aevPfUIU9+edroZuw4MMYOz7mVpy2c64jVxBT2nQ558t6zjYc6YvXrfMiT9wsdsfo1Xujp5zR2ohiWpz/R2Il9x/t+tRP8zVy8Q6OV/bX1X1z3LLAeO9wiPKsnvkP8EapLQXoT67+XED1uH6//Xi3q0hZpfBeJWme+WtA52LFsLwTK0eVER/XZJQE6WP6SAJ3rK9K5XtAZFeVYZ0rumTgkVmd4z0RJHQ3umVB8KbpnguWpis1qsMphsZ2z9PSZKcoVkJ/ZsfJq+CNJJf1ohfii7JK1/VpRl7ZIY/5fK+hcK+g0WA3WvsJim2zp6TNTlCugb2fE6rfhjySV7EkrxBdl96ztN4u6tEUa3+HRL98z9/xm+2pHrLYj1nJHrCWOWJ7fDZ/fp21c0adt9Pw2+jZHrDMdsTzly1MfPeXL0xZ61muRI5an3B8MMrHWEctTvpb2aRs9eT/PEctT7uc6YjV24sCwE55tPNQRy9Of6Ffer3PEanSoGNbmPm3jwaBDnrz3nLt7zpH5zlpsM99Zu1nQ2Rygg+U3B+hsqUhnSySdyyvSuVzQmSnKdZKop8VxZ8NGXOyrAjGymS3CSxIdkzP8EapLQXqtkCyqWKW1fYeoS1ukeX5L57AGa59jmX6ifPO3VYvaNSx/c4DOORXpnCPozBTlOknwOcR+sC4YNuLeAu8L6OVQrB0w/JFkap+VsQO3EL08GbG23yrq0hZpLIu3Cjq3Cjr7ExbLLvY964ji8y0BOlj+lgCdcyrSOSeSzpaKdLZE0rm8Ip3LBR2lm+l/nSTqeYGVv7Vc+WNNd54OL9luPAPeF9DjS2LthuGPUF3K2o1nED1uH9uN20Rd2iKNv1N3m6Bzm6CjsOY7Yq1xxGo7Yi1xxFrriLXMEWupI5Ynvzzb6FmvWxyxPGV1riOWp2578n5Rn7axsV8Hhv3ybKMn71c4YnnK/ZmOWJ663a/66Gmj+3Ws9ezH5Y5YB8M4dDC00bNenna1X8ftW/u0Xp78Ot0Ra6Ejlqdv0q9jWqOP+66N/TpuHwzzNE+ZuMwRq1/lfpsjVr/GOlY6YtVhoy1efDqUa2V/LVaOMeICset2i/CsnvgO8UeoLgXpTcTKLyR63D6Old8i6tIWabzWXnStBLEOa7AarAar77BsjRRtHt9dr+zLhQE6WP7CAJ1zKtI5R9CZKcp1kuAzZj/YPho24pZcR43ef8HrqCX3ewTXUZWMFF1HZVmsMjb3K1ZIdq8lOkVl99pIOnXoiKKzoyKdHZF0rq5I5+pIOtPFty0V6Wxp2nNAtOfyinQuj6RzoPHt9Ip0To+k0+hPufbcUpHOLX3WngOtf5r2NO3Z39sTnLP99O6vPvb5N/7GZz648wPvf+u8r895x+wNs176ylf+84ofrXz4x698X8V52bVW/rZy5RdY+WeWKz/fyt9ervw8K39HufLnW/lnlSu/xcrfWap8a6Lvnw1vO1Flu21/zgRaobqfa+XvKlf+cCt/d7ny/8/K7yxVvvVjK39PqfLJ/2flnwsvO/bj7N8euO7pH//FnbMv+uWP3fv1r112z5yV2//48Ne8/7o/uf/w79/wait7bznao1b+eeXKz7byzy9XfoWVfwG87EQVTWZY2RcC7Rnx5Wda+ReVK3+KlX9xufKnWvmXQPkCvOtY+ZeWKz/R/vFS5VvftPIvw0plf4/6q9875P98+M2Dv/6/fnznvT9b/+CfXfTGP/yVMx/44rFnj1/17bf+6FIr+/JStJM5Vv6XBe0e9Z6wda+YeFOI9piVf2W58kNW/lXwsmM/vveGd760/bEHdnWO+eLPhi968z/d8K8XD23++hdftOzTL/+P7//4ISv7alU2/Axa2deosn9x3X984zfbD77geW/83RduXrtg+0ce/OpPfvDZz3+0/a9/+6vP+eqErL82y16wzbOs/OvKlR+28q8vV36hlX9DufKHWPk3wstOVNHk5KH/+t/3s4Vi8+VmQj2OgN/pfyPZv4eSri/XgTxWdpDyf/aCbrkfZvRGqYxhJEnX3xuB9wV4sqxFeEmiY+mGP5JMbXuZWPoI0eP2cSx9tqhLW6TxvRqzBZ3Zgo7COsYRa4kj1jZHrLYj1iJHrOWOWAv7tI2LHbH6Vb6WOWLNdcRa44jlKV+e/FrtiOUpX546NN8Ry1MmPO2q7fsdFeVa2V/zA0bhfYFxeUaL8Kye+A7xR0Q9y/gBo0Qvjy/pO+vre3Y+4/Zn7Hz+JXduv3nr9mfffc/tO2YgdDLZG2KuICq+ayWTW49pA/RuFuW7cHzyvy8en1ouEdgDQPcISFOcMEzzPrFNR+SUQ14k4t0MkX+UsEZFOav7QKB8knQldoTop8++ktiSnnJQYrF97LkeIerSFmnIwzyLoTzkovWanXStU6ZJ5++48Z5bL7kT79LY8wzSvy8Y11VcSvkuHtdVawncFv3H75fSu4EkrKqhyVKMyKQPG2Oc7HSITmOMG2O8fxjjAVGOJWZMvOdP+RR1Za4X9BSdGyrSuUHQmSnKdezHy973wW9seeMXj/v2f8x63aXbX/G8E1//l9f+8AVLP7D6H2771ZUfmZ+GYK6YN7m+yP+ZVF/rdwz5qP4apPwLIORzdUYvra+53JmGnXfP7c984o6ddz1jx3N3/Jetvjuhp5daXDY++d+Xj08tp56YMbyk4Yk2dIbvNYYr0cobK+MNHQsEcgVR8V0rKW/orAftKWPoenkNbOhCxgl7Zaaga+9mJPmGSBkxjjWGDFmSNENzeYk9mIfmGImNHZrzJDZvaOZyQ0m+hA9S3udkQ0ZFyZ50cz3XsRkD9j7NGLC/jAEDohxLTEiqY6TS2pE+7SS//TOTqfzo2I+/27n1/p1L7jjlhzO/9Mbjd6849Js//cBvfvffnr9j8z9993ufOOKnFbVrW0WrcE1qiV5JTvARgMWTuyOzf+ete1rZQcr/mWO75V4LTrDFsDPN27b99mfcvH3njgue9Zx7dtyz4+bL7ty54+4tz7r5gufueNbOwi7xReOT//248anl1GOMwMbPobRZkMaKPovqyO9YqFqiDYyVx3DDGqT892dMTm/M/fXtkzGVIqHQs0HAOoVmeMyHojM8NRzU6OzNizECiD/dzp61b045enNbVB7pISa7AW2RZli2SIfyiPnnQBswP/5On0F6975MXtsCkw+qtUV78N0MqON75k1uG/K+6mCAvGF5VTHFtD4fmje5LbMhjQe19Ll0fO/fQcr/62BQP0IGHGlz/7Hsog1Jn7zY7nDS5QnmYftj+T8O9ue3tk/GnEFtxnYqmzIKNJhu+vuknDp8glznknokXWfDGk2m8tDHPrV+UtY+zShFL2yfsH0+9qn14/3JPn0mYJ+OozoUsU9/OE32iZetZjjSQXnrZL/NFmE/8uQp1O+KDpZn/WuJOqT8/dI8TRPlA8vyNNzyvwDs7V9E2FvlH82gNOQb8wb7J6SDijczcrDyfEhus+X/ekEfEsct9iFnCHqtHPqc/zhocx5WIt5ZfvRfZ1HeUco7O5A3b1xKf9uhjLr1eDPRyZP77xSUe5tcsdzvALn/Psm9ssOJqDPn3Ux550K7Y3GHqGz6+zDK2yZclJUnjSeT2mu4V87v4v+YbPNcwld/0yemT7He3KfIu07Src/PqE/nQZoKU3KfWv4zoY0/pz5FX2cu1cuj/fZ+PrxnuvMo7wLKi5vC2lTH+VRW/e1Vx7ags4BwFwbq3yacuaLcaKLbqv7G1neeqO9oouuv/sbSQawnj0+mkye7s+Z33yMf8mTXDisNUv55ILtzst9qKYBlF9t6EqUpXzPFv4vqjBsbjU/XjU8ta/kXU37ESB+ea9mKcN5cy8oOUv7FWT1xrmVtWyjopW1bmtM27A/c+LqYaFv+U6A/VlB/IL+sP8aSqbxhHVgCdeG8m3N4sArq0ZmfT4v1QrUxxVg9Pz/fZpGPMWYIHhiGsgtWbkzQY91dRDQWBmgsEOUUDbbHyLMlQN9kY2mP9CWibYl4N0PkX5TT3kTQXtwDd6HAUfZ9MaXNE2lsu7C96KeYnimbiHZvVkBf8nRCydWiQN15Y/ciUfeFgbor/qH9CPkN9u+Ysb4l/m31w0O7bGNNvocTPY5Y2UHKf56wmYyJthDrdXcO5gWA+TuEqWTmFHjHc7ZQP2F9xpJ8PVd1R1vC70K+TCLqgLZQyWyeH8f8UHWYL3CU3VxA9UGaRXUT/emf9Znvv22+bmdR3/8KmM89OUKH+9n355h7P/j+swmn8f2T5JlOvv9qkN1nlfT9T6S0Xr6/pRl/Z4hyc6i+Ru8h8EnvIbwW0EK5SX/zetd8wE9Em3j9w/I/H8aj398epq9sPrfn/gxvZjJVRwqsM2wJyaVhLyyJHSPXSheVvz0i0gYj6vLp33zSk+/56Tufw/JudeF3MWP/WSK/8YrnmZ0k6jlrYnPPeLc8Xv6dPoOQtpDShiDN6pDK2nqq36KS9YvhH+K3RdoL4HeRvlBYcxyxZpfEmpdMllHUQ2WHOdah4qWpDfhYD/ukxji2Dx8h+4Bx3AL9flJoPDfsBSWxY+1D3hiK9RoRaTH2Yc5Prlh10auefb7xDu3ggHjH9kHJyhkif0X9O07ZB7YBg5C2gNLQPlgdlH0oaeuPi+Ef4quYCNuH2L5QWHMcsWaXxDL7EIqRo31gf2iuaA/ahyl7LMDH+TjFzFCf2A4pf0f5ZJzWFpgp7T/J8deGs79XjHfTeL1JzTUTaIO9Q/8Ly/AeGMv/h8Cb36f6sU6jz8f+q1rHTzE/OT8/39xAPuwX7n+1/hnylWP7hceKP6WxAtdoC9gAuTfHsNK2mF+SbTC9aMfOq56+/a4dN1+146a7duzkHaQt+nfeajGW48cw+BTsIfRv3tE4h/7dFji9aHIvYlrFXVBHIIftUSOn4XvtllS7REK7JUt6HZ0WlUd6agdRyGKy5cCZLubnFeq8SAhblq9m2qOiDLwbaa5oD75Di/JlmlVje3hEKrp7B8szD1n206difw7EyqvhjySV9KMVkh/FFyU/oZVj5n9sv4awQvYihn+KzjT38+CB1s8c/anSz3Vg8Yhv6ekzU5QrwNvoT78Y/khSSXZaIb6oHZscucWyKhLL/FerE/MEnf0J69zst40ZofGwqPxh+bkBOu2KdNqCTmjlw+ScVys7SdQT7UsZ/khSSa9aoX5WfKkY4e20qDzSU7MtFWXhlWG1aqCiMqFdEenDqwrzMxA1C2dfKnYWntZxdMHktqld0mm+hQsm0xgV7cQVtCvHJ7fD8j/xmG65JRlmaPet1YvnOOlT8Vhi9MkqPvRbchYYPPSrTt5VPDk2l/sK6YVOBYX8abNB2O9qxq12yeJYNUjvjib5RkyW71iffs8uK5IxFTkI9UvoJKA6cRgzty3Zn9F+B5+0ma6TgKEIjOpX5n/Rudr+hBWyYzH9quhMs/w1J1GpPiqqyDu/6jrpdRHZS6+TXlvIXqpxImZcQVw152Yeovx0oD6XRPgdKI95fsdM8DsuD/gdMWOCOokaOoUe4pfymUJXXKh+mRVBJ9QvsyLp1NH/09WekG5jH1w1nl8vnie2e2A9kbCwvJVVMsh1LnrKTq3EKDpzKtKZE0lnutpTx+nEUVGOx9OScZ3o8ZRjgjPK0WvFyi2PpyXn83N5DER6Ki6i4lYcM7H5c96u59CqKc7zeRfaC2k8RUweT2PjUHt21NH8WsUjY+QAcdWYz/KaN56O03iKdVXjKd/sYPn/bX233C8HxlPu2xrisdF6tK/isRXjcHNj5A7rwzuTmLfpf+r0gIp5zaD8+Dt9+HTBA6RHiMl6FIq7GW2r4xtIj+ra6R4jrx762iE6efr6MOmrWqsN6avl/9+gr+8O6CuvEyBv8tqDdIuOMSFdmhPI3+sEBdvDGnbpRdsd3qlbMl49YXfUzjqlN7Mhb7azZMuOu48/YfP5O2666/nP3pm3Y491awHhssypPrS28W7wtqCRPiw/cykf97u9V7vNe9WpV95e6Upv+BMgRX1PtVOLsfJuxrD+4TH6Y1mCuhlDzalQhkI3Y4xSudGcug+INszKKffSRNfP2ox1Um2e2OkXaPOcHm3m+bea+4XiQdzmidhDMlUGECNmjlHy9qJvxdoo3g9VdY7Ra57tsx+q9U22K0iv3/ZD/Sn5Rl77of6YfCO1fyVGDhA3NMfv5bN8scAcI/07nv1m+/V58Fn+R8Bn4b6t66sbMXZ5HPLkxZ5ib4iz/F/L2l4x3iB3obK/2xL1T9v31059+t+gT/93oE85loN9GuNPxu7HDNkPtSZb336LeFvtvd9CzcOUrSnqTxruN6FBWP9e/iSXU/7kzBwaebrHPh77o738SVWnvLxV/EkuW9SfVPM2vgK6oLx0rC6zoB4qDpF3/fiMZKpuqfzKh1Qnu1gGBhPtZ3UgHfP/C/iKf7h97+8YX6wk/9qx+m34Xr5YrO2seMphjOUD6an+Vqc58j4GgeOM2sMxI5mq9zjH4XmCGTK1NsX7DmP3haR1/AX5YnX7IiF5LUtH6Y5a32QbVfRGcSyfd6N4no2xT9338kVHF07GVTcZt0Q9+CbjO8BvaWeYiifWR+rWzdDaFbe/qL2fJegwFtpHdfMz8yjWT7X8x2R8qbjP5Ioa9+FfEWuD8+LAWC+1jhBzsvaRvzzl0+fe+Uv3t6i81YXfxcRKnyjyV1x3uFSdrMU1hvQZhLQ2pQ1BmtVBnawt6b9eGsM/xFdxeLwZqEhfqBg435QXi2WnYVVMaV/ZirxYI/pamP/4TPdjb+HFcSHmFl419mMb2eYkSb4c/Sc9hmf8P0TQmpB3yrsZ2v2p7ZPrmhcXHcxpzyjVkzHyeMM0lC/0smRy3eZE1E3FPxEjb49HiqH2vFTdVzlL1KfGsWKs6Fgx3We2KtrPOaHxpN/2Z1xB/rrHOaG0jo9fOLltda33xt4Efw35q71uxH559pvt0vXgrz6J/FUlu/ae535o89OHxzijl3cb7Myc+j0F7CbfbDhTtPnlUK88O4L+Kvq3eXHVG8lfrSOuym0aTKaOnenz+PFEtilvHGYeKB1G2eQxVvlHjJW39sZ72tUNcRXPZs2Jtb18y01JXzcYC1W2o+LegdEWlUd6oVuT1G24htXrdmS+pVDdzpo+fHvyPWR7EZNtb+wNUWkd71w4mZ7pyH1LunnuJXs4CHVUevSE8cmYlv9Fi7uYLyiIeUkO5usXdjFfHLCxj08m02OZ5nc8jnD59BkV5Vj3SsYNoz+GafgjydQ2l9E9NY9RfBkFGlyXtkiL2X/8eEGnRVi96jU76drVbH3k/B033nPrJXfemtDD16VcMK6ruITy8fDL3cLXuSiRs38voXeqaYidivmly/b+NjHHIXc74WNdBsQ77jIsb/kUncMr0jlc0AlhbRdYln9I5D9c5HcUDUtfCXnS951A1Ri3l2gwdp5o2DNANNPffOqLu4brOCYwWoE2DYh33NUtQYtPUn2UvMAhqncniXpebVZpGF6yRS65cvRqbIc9oZWjUUHP6jUi0mKilv/cPvYvn7z6gi+0qLzVhd+xqqgo0E0if8Xo8StU1BJPR6bPIKTNpLQhSLN3KmpZ8lTjK2L4h/hq9YejlrF90RZpPKTEYlnUchjqYrozXbocwlIRxhbVeTjRK5RsKyz/b8Gs9TPbJ9NTfEjEuxnJVDtx7fjevzXakOjT47z6PFyOXnD1GdvHXp1aDfZcpd2fsExmRpOpctXK+Wt0+B3z2WNlmvvMA2vUEau5yWtyWbXyPga/MQ3p7MubvCwNbf4cSlN+DutT+tg4oE6WWpRwLJlq91r0e1i0azjQrpaoH+/cSH93st9pW7+1UNNUN+7g+MVj1iKIfHx7YX4bY3arYv68qOr3yJ9G+Sog9zKqali9ePeDArxLHzv1zbz7+aJuuR8GeMd+D+o67whBfvB36tWKQUj/QyvT6rR5jacw++pWvNBqWcmI9KDRUxFb1Q9zE81T9c0W0zFl69ieoa1ju46+wxiloX6fCL/z7Jna2TAWqN90203lI8fIoKKDdebb3vJszMii7nvslzz7fG/2m6Pd3wEbM5r9VjshmK/sl+MYkD5587q8lbpZOfWbl9UpdqXu3kCdkUaSTJVnHlMs/+KsDhXn3nJMmYab5qIj6vvqprk0n9mlLDx5yZ3bb966/dl333P7DhwpuceYK4iK71CbOW2A3o1QvseNT/63Se1Akv+gVqD1S5K4PUhqX46KFMwUdO3dDJE/tJ+JZ/YDgfKIgeVYYlS59N+vEWVCGhAjwemzr2ZzJb3MBbGaafhes7kxosft47a3RV3UPpMR+I1pSCdmP2P6e9AR67AGq8FqsBqsfYBlaWr/KM+O0ofvAcg7B4FpWL/Q4jPvtU2Sro3nFdr0qXinZfQeVj7TMFiOXvD8v+JLxfF7Tmg8RUzefxmKtPS6s3MM2oD58Xf68ErzzdksxlPu0zo+ddHkttV1/j+0KaNOvcC6d7LfabtvX6Rp5u2V5Rm45f8qzMDvXDS5zmoGnscDlLE9GONT2zSxDxTSiuhzOgv/7PYuHa7X0HgXN08vcFb+8ux3O5mqMyFZ4GhMXh+9gPpInS9pifrwPrxPQh+9mKIkWD5mr5eixzI0nJN/BtXP8r8coiS2MqzqNyuHXl7U6Jk59F4F9H4H5GFPO8cn00ifinK3QMkd6jPLnYr0Kf0PjRcopyFZ5N0ALYGFcsCRMSs/nOg+MLxByn+/6PNYOed+tfwPRfarkz2R/Yq84n5VOy3UWbOQHKhdISoSO0D5BgQW9jX3ay9dNjzWrfcG+tXKY79iPblfLf8jkf2KftEenPHJ9e0kUY/sV+QV96sarzF/zMZH9hnTR61oHEJpbBPxt7LfKAcxfY79k2e/Pyr6nOcGyi7E7llO42+22pNFWK/aeeddO7IQa0JPKCTaSqZegWFk5ovyCZVt0Ts+RqDMZ2jDmNEeTnRIks2n5f8twfKQ+U2fmG3v2N11BOntnde2915mjUOBITULueT7QFTTx6L3LVEtLp8QVku8Sx+1FR1x2QsMWTfFKj7VxvnxxAjm/5PAyBHycBJRh1CEGOuj2j9GaaFTuJYXRzQUIx7RLP8XIkc0o13HiIY84hFNzaAxP/M7dJsz8kTtVWLvFHnM+6t6qaGZVzWzQq+SZ1ZKXkKeWYg/Sr5QJtqUlhdp2YM93k2zfHXMgrE9LAuxN3Vb/tAX6JA3bcqv5ETtw4mxS+kTkgWcOd6esxcBcUMzIHUrDg7hPCu3/D8QNsAwR3u0LWYGiHac91GpL7iqm1sxUrEHe7ybhje07mkfpBWJQip5xPawPMau/sXqaigKzucIcIaVdwMt8hv3ukzX3jcev1VEVo13HHH9T4gazV88GVOd9A31gdr3pW5tVl/+XBCBFfIF1KnaBQHaWC8sy7S5nnjaeA+t8W6a0zg+pHQF7TPrSuztlCFeqX5qU37kTdF9eHzDUOw+PJN5JZ8qcqJsuNJd3O/6A9q3qnzIkA0O3ciC5XG/MNZhedYudTNQrz3NL8/BPBQwedxRbWiJNsTYYqVbaPtCfjbbRbR9bBeVvVZ2hO2iyTX6Zpif99NZ/rUZ/yreYiD307Gtw5tVle/Fe68t/9mwb/2YxRpzqCDmRiE3Ndq6wbptXa8xyXjSTqb2Td5+UsRSe4BZz4YTPV8yPJ4jnwZ9wJE2tLdsU9Hesk2dLegqe2v6kNL5pawe7K+lvzuQ71ySPTVfRpvDsmf5bwB53pr99rQbfGOc5xkfLM9fGQrdhF1yr330WQK+/aWOm7BVzKCi3Zw4S6B8FdUPeJZAnR9ALFw934M73s1Tp10LxWJ68ZXPZWEbWZ/RRrAdiPHJFL08n+yXavLJvkU+GeoX6z/qOOs/yjv7DchD9hvU17/QBuGYjflvARv2fOKNkuVQjGWRyI++OM/pUdYXRWCFYn2LRf5FAdpYLyzLtPN0Uumi8aaO+RT6BayLoblk+sTwSvVTm/Ijb4rqLs/DcHxnvUbZxtsHn58zbmM7cNxm3Z0j6or+gMkGjktPSSbTVEs7+I7HWSxv+RSdwyvSOVzQCWE9RWBZfhXDrPkKHKviKsiTvu8Eqsa4LfqP3zO2mkrio7qpleh6J0lcN7WIvsIagt+2cTVN5+Ncluc9NPUrudHzwdCVBIZd8uqIB7Hd9ij3L+9IINZLXWMRc93NX/zLy15z/U3/8LUWlbe68DtWCxWCf6rIX/G6m/vU0MJX2gxCGofDcXgIXXdT8tqR+2L4h/gqTM3X3RQ9RoppqCNFsOy6GxzCeENs3brPU+lHRWhtuutiw/EHA2G+XstcvOEe6x7adMztKrrpuCXoxGzGL3lF2CjSw3omVBe2XVU344c2a6UP26KSdnt2rK7ztTYzRZphTdipRC9NDkMbMD/+Tp9Bevf7mbwq95M348deiZXW8bcorORxZY9yn1lecfzpQH0+SW5wrw3Hz8t+8wa5F8OlrJ8mFxjLc/+x7KZ/8YAp22PejMt52K+x/H8K9oePqQ+JNj8P6sU2BUOXql0cVrf8XyTfquSYKcPqfLVfDVeERe+A21dXhBU7ps6SiFxBVHzXSia3HtMG6B1vdLtwfPK/yxxTV59QGhaY6vNCs3LKsRXidzNE/pmElWehB5KwN4cYajHVMFS59N/PFWU8LwCZriPvFY/xRX9qnI/xlZxVBI/xYfu47WojmFpEYO80dHwP6SistiPWbEeswxqsBqvB6jssFWEYpTQcD2xBV81OOepTdGaN5S3fqCjH40jJi4iiP6vBFxENlKMXvIhI8aViNGzisxpq8yli8qVPc0Qay1zeYtkotIFlDmWTNwQsyWZUaqMwy33sxqy0jvOWTG6bx+WsaiHG8k+3XmDdO9nvtN2HL9E0845g8kzX8j8LZrpHLplcZ6wXRlAUD/jScYzQWr46Nh6HjuUqvcBZrh2RDx19U7IQe2T/WOqjXsdk+ci+5b8W+ui47PeYKB/zqURFj2Uo9ji45T85q1Ov4+DDOfTyLiq9dFzTOw3oTcNx8HlK7lCfWe5UZFbpf2i8UGfblCzy8dLQkeKWoBM6KKGOl3Ldk2Rq9OwCIQ/sa7Bs5NVP8c35eOnMnGrMFeUTKtuid3NzsAwn/TeGJ2KOl6oT5GwiLhEsD3VZ+jTHS/e746UWdWuJanH5hLBa4l369DpeyhobYrFilVmr2IsJLP8vCZGOsZiJqIPyBNjzzWs/bzVV22+ZjrowIX14RLP8N0WOaEa7jhENecQjWmxkzPL3OmbAqhY63hW6tt3reCl7akpeQsdLex3nY/lCUxg6zhfyqg+U43zGG3Wcj+VEHYOMNf0hWUBPlGdWyptDWcjbY5F3xPzl2W9eT3uZsAGGObNH22LsHX8CK33UMR+2d2pdsMZLekaVPGL7WR5DbU2forrK9kddBKbWqNmN7CU3oe3TuG79SVp/RjpXEc2in8a6StRf0Tm8Ip3DBZ0Q1lUCK9TfNW/BtCqugDzp+06gaozbov/4PWMrNcdHdRMv7RftJiwfEodWRTotQYe3WP1mZg4rLvP/csxC5VhJbGyHPWqWY/hq4dDqNSLSYrZufv13z/jDBS/7yliLyltd+F3M7Q/XifwVTzmNqyEDvz6RPoOQNkZpaPatDmrrZslvYo/H8A/xlevKWzfLLuCkD0cGYrFs62boNonp0mUbOn8XXBveull3XZQLwfpfcgEmeoGJdbykLWuFhkDFl4obMSYWmEILMlifkH0zLHWaWW2kmEH58Xf68HjxZ7TA5LGwmtbxM7TApMaRGDlAXLXgwPKat8XxSzQ9wZtLVMQv70s8F6/vlvsLWlRQ4Q+m1wJ6oS/xWPnYL/FY/q+CzeAtjrNEm3Exg23KKNBguunvk3Lq8Dfkg5TUI7nFkaf9WB8eo9VGOfVlG7WgGPO9k4p28FNl7WDVL/4oO6j4UrH/PlnUDlb0Kwesr+YJbKsLnv4bEPnZjqLfhieU+baMfyV7h/aXfZ+6v4ZZB5byd5FvuAHie9Nk++v4JpFacOtkv83moOzeCL97ybqig+XnBOgMVqSj7qBXuoirbOyXWJ70MV0teZtC9Bdy+UuQJW1D8EuQyodRtoRPFSu7EaMvSEdhjThi8cZXJTc3Cqyi/HIMG1kVt1G+q8Z11QYEbov+4/fb6F1e2MiwlUrGREhDKonlp1v11YoFq3ZJVYtWbcPfV59LU5ff7I9DdI1muvQHe/vVTBdxa5DO/oR1bvab5dzS06di2G84Vi4M3+vypdClu+nDcjFf1EVdIMT8V5cRzRd0DnYs1j9LT5+Koe/oMCFf8FVSpoMXfCndq3jB10SYUF3Qh5h44Wr674UizbDsMh2c3qrLS2dQfvydPoP07uKle/+qC1FZrtTlQfgOw4Rbl05uG/Ke5agknw+JlSPDH0kqyW0r1K9Kv1S/8uVGHvxusPyw1CVaLK9YroD8zI6VV8MfSSrpRyvEF3Xpl7V9kahLW6Qx/9VFbIsEnQarwdpXWOpSPw7xFLUjWH5hgM5YRTpjgs6oKMf2CvlQwH7MjLVXhj+SVLKPrVA/K75Y20OXDmIab0dQlxsuFnQU1mEN1j7HMh1D+eYLyIvaDHXRqKIzpyKdOYLOqCjHuox8qCPeY/gjSSXb0Qr1s+KLtX2JqEtbpLE8LRF0lgg6+xPWzdlvkz/se5bzovqE5RcH6MypSGdOJJ2xinTGBJ1RUY71CfldQL6jP61u+CNJJf1theRJ8cXat7QcvYlPqy8V9BDT6mO8XibSDGt59m+MYWD+pdAGzI+/02eQ3n2CYhiIyfq4TLQH32EM49cy3DHRntMJt6ieY3nLp+jMr0hnfiSdORXpzImkc0tFOrdE0llYkc7CSDrTxbdFFeksiqSzoCKdBZF0potvYxXpjDXtOSDas7gincWRdA40vk3XONfoT7n2TNd42vRP056mPQdne3rd67R0maaZd6+TbUUdpPxnLO+WW0E3cOBet4uSyfSK3vyO5UM3zPPJbzzdPIvShgVmi9KwfqEvFmD54ZxyWJ8kiTvOUPLewOjLa/jewKrHGdStJuo4A29Hx7Jqe3nMxw8vEnSK1stx66xV8RjKx6eLsIsZt0X/8ftj6N2AyIvY0yX6is4TKtJ5QiSd6WrPrIp0Zgk6IawnCKxGvCdhq25iVhXtJizfD2K3uCKdxYKOGqnwMG4vb+Ji8ibUgU4sy96E5b9sWbfcJfDb7vZKRXq6DhsqOoMV6eQd3sR/5/HsOdnvQcp/bcYbdefOLKiH0p2rxifnD902ajiYv9c9NMzL0N1HvQ5CxlwmEKpraBc70lenPuYWrOuV01zXWaKuNZ5EiPYu99VJhGLfHck73t8iVHzHmoRpA/SOb0C8aHzyv8t8d0TtvVdXb5iEqCOwIclKxLsZIv9cwsr7+P1ADj3Vo1iOJUaVS//9KlEmpAExEpw+eWdbPLBq2F+9KFYz95f91Xz8ssp+4bYj1mxHrGbfd4PVYDVY+zuWikfPpzQcP232oWYHMQGO2YH6YXnLp+gsrkhnsaBT93c8eE8ejt3Mt6LnCrE8n3XDK4k62e90tvrryzTNvC+A3pv95mtbNsBawm8ty29j6EZhy1fxBtcxdYMr+jhD413cPP1BH+7l2W+lP3wjK/a1YfTqgz+iPpgNaaoPrD58Y/ki6IM/pj7A8niuM09vFD2WkeGc/LOpfpb/sxDt4O90YPmxHHrID+Tz63PofV5EV5TcGe2KcrdIyR3qK8tdrN8dK6e8BhM6c6OuNkQ54IiNlR9OdB/kXb34V6LPY+Wc+9Xyfy2yX53siexX5BX3q4qsqXEoJAfYX/y1duzzvEgkYmFfx/Sr+s4p9+vfB/pVRZCxntyvlv+7kf3q9BWCRUVv+lb9GrrpW43f2K/GE7V3eICwei0SxfQr9gHbaMv/L4F+VVHukB22/D/rAzuMvIrpV7USENuvbIexX/l7STjWsS5Pl41uZX6D+l7SPFE+VL+8hUvH7yXNzanGQlE+obItercwB8tw0ncYVmWWW3OHEx0CZZZb/pmC5UpN1UJe6Cbh6d5yUvUm4ZDruadi2d+iW06KDos1iGr62GpBS1SLyyeE1RLvME2JKpYJfW8ER+iLaaaAIsQzBWX5lOdv+U298rwLwxuk/MuFejAm1kHdrmD5Q6ebsT6q/XwiNXS6XN0Yg5afR0fLfwS0NTQ6Gu06RkfkEY+OakejOlFq+dUJNtwxyVElPN3GKo085hM5vUwHy7+SUzX7Vt74jEB7e83KWL5QJvj2AjWbU7Jg+eqIlGB7WBZibwqIkR3kjTqNy3KCesnDdsgupU9IFjC68OtkC1E2Y+Qc34Wic5ZP0RmsSGdQ0GGs2H0qlv98YaOsrDrhGdofsVzkX0Z50kfxxsqOCtqtnL9Gh98x37AO7HYsd6SDp2z50v0VjnRWQJ420VnpSGcl5OEo+qGOdA6FPCNE53BHOvitKP6wxBGOdI6APLOgXPrvIyENMaweq0Q9bApwFLwvMBZE3zZr+CNUl4L0JqYARxE9bh/r4mpRl7ZIewH8xjSks1rQUVjDjljWt2PJ1L7mKO2Rgs6RATpzIumMVaQzJuiMinJVdUTxxugc5UgHdYZ3IK12pINy0CE6RzvSORrynER0log6pP7Ai5Z336f/rYE09uPTx1aAByn/D9Z1y700wzQZRFuBdcTy6L+sEu1geq/IaJj9WwtlCtgj+ZEUw+rFu1cR71ZBWgzvLP8XgXevJd5hu1i310HaUZS2HtJWU9oxkIYYmJZAG/AdyxyWt3yjohyPVxvgfYH+ir5hyfBHkqltLjNebSB62Pb0Mb5Y+44tR2/Q6G0U9FQ/zE00T5G+YZmOKTu7ltLQNh5DaWjP1lMa6veJ8Bsx89rEO2CxfizfWL9llIY+/XJKQz98BaWh77yS0rDN7N9am4cEzmGUdy3lPVLkHSTc/++IbpnHlk/GOyZAezPhWd5fhR0DH8p+83ikxpB1oq6Wtl6kpfi/kTHL+Igyin2Yp2P4LjR+b8jBGkz0fJN3tFj+P6NxpaQe32p8QT1mG7ipJHasDTT8UUHP6jUi0mI+APrQ2h/N//BN//61FpW3uvA7jgccJ/JfKfIbr46H8gV4daOKoxntiQ+0QdomShuCNKuD+gDocSXrF8M/xG+L/FvHu/mK9EVb0Lk38cNa5oi1oiSWfZh0I5Q3nVbjBa99xN5kplZOLV/dcat5RAd9nU72e88HF8lfXQFpA6Is20jL/6MjuuX+J/mralz2bH9orED/gn0JbJeVZV6qcjiuLIioQ2i8WiDqMCrKVZUNVWeONbJsfJtk41hIGxBlX5v9HqT8XwXZ+A7JBo6l09X+Y4nOsY50sD2d7Le1Fe0Ny43y7TcG6GD5jdQe5V+UbY+qcy+5+RnJzSZIi5Eby//fQG5+TnKD/Wl1VDLF443i87GiLlz34Zz8G3Pq/v8C69ZKj5DPbGMn6K3oYvLaixr70PbF+FrKF1Q8PY6w1BwO+cxbZRRPsf1HUfst/0xoP+9OWibKq7Gc5wRFx3IsX8dY5hnTrHG+Ef0lIcMfSab2c5mYi5JzZSet7ceJurRFGvoCefpxnKCjsA5rsBqsgxhL2eSNlBbyy9FGsL0u6ieF/ISDxR87fUX3PdrBov7YR4/oljsrKzBGeVT78+p1LtVrY8F6Wf63Qb22Ur2UX8F8SBLth7AvaLKe57dsovpZ/scJv0XVb1kOPeSHisswvUuEn6hiXka74t6xOWrvGNqMofFkUruOh7SQjbH8J4j8GPvjcf0ESDuW0pDH7McqXxBlhP1Y499wovvH8FhenxTwY2PXMBZH1D3kxy4WdOqOSfHXIfLswnayC0dBmrILrAeW/zVHdMvdTHYhLya1p13j3TTLV8f+ShwXWEd62aaXZ79VXHQ5palx2LOvFU/59mo1R1Tz07Yof1SgPadTe/JkamdBmeKTtZb/uSBT90bIlNJd3ttTVHfnRNK5pSKdWwSdum0E7+2py3e6hehscqSDutghOsc50sHxi9dl8/TgDaQHx0Oa0oNXZL8HKf+SI7rl3hzQAx5jjwe8ROQ/KYfeQxkNi1vgGF/ADsu9PYbVi3dvLWBD0of39lj+X3S65d5BvEParNvIJ57LKH9oLJnKK/aBlW+F70Lr68w3LGf8tf46Gd7XsbfH8EeSSvIxEWc6mehh29OH16JPKUdvYm/PqYKe6oe5ieYp0jcs3tuDdnYFpaFtPIHS0J4dT2mo37y3Z0WPNvG8X9VP6cWGCDr4LhQTsHymo7YX5zudvX/3nAXJMo0K7GvGJ6ehfhyZdDF+KzAvrSPG4Tl+eo6RoXGw4r6O6Ji04Y8kU2W4jK2Inc+ynVT6hGkcky5qqxHrsAarwTqIsdQ4F9o/xWMT2gi210Vj5htEHRSdBRXpLBB06p6HcEwa96p3st979oFEzEOwLMd+Lf9XO91y36cxVvG5V73+iep1XMF6Wf5Pdrrl/jlQL/St8vp4g6DHfBvOyX8c1c/y/zQQk1b+RKifsP/vzaH388iYtNGuIyaN4/TQeDKpXaEYc/pwTFrND9DusG1BX51j0sjj44mO2k+GMsIxacMeTnT/4B5ozD+YbW5XMelNorySlcURdQ/thVss6NS9F4xj0nl2Yc7K7nvkW55dyNvD8/FOt9zcDLPXXrg97Rrvplm+/TkmHZqzeJyxVvLJMemi8onleb/ockGnl0x1Vur65MkUx6Qt/3s73XKrVua3P3TuhWPS6mw+vgvFpEN0bqlI5xZBx1NuVH9yTLqu/aIck64r9t0hOnXFvjkmnacHm0kPevlcHJO2/Od2uuXOCOhBns+FMekNoh1T6GU0KsYtZEzasHrx7rwCNiR9OCZt+Vd1uuUuKGBD0LfgMxTID45XK1+pRWlJEjffw/IHW0xazf/2p5g02lkeU9E2ckxa+czKBnFMekOPNvG8X9WPsQbhnYoNs649NdOvVNd+Kfut9Nxop/n+nvKpMcj6oOQe2+h7P/icYMnzkBNyHdqTnz55cWgsq/r+1fAb05DOJkFHYa12xOoHP2ysIp0xQWe6/bC6/KMxonOg7Q3YIOqQ2pgXky+hYj1oP9mXsPyfObxbbjwwx43ZG3CsaAfTeyX5YSXH2ai9AXm8e3VEfCDEO8v/AeDd6wK8Y92O9bV4bwCO1xx7Uv4GvmOZw/KWb1SU4/GqpJ8S7YcZ/kgytc1lxqtTiB62PX3YDzu1HL0JP+w0QU/1A/phyvdCrJAfFopPnkxpaM/YRwvtDTi2R5tCftixOVixfpjlf4TsRkm/SdoNjmk1/trksmrNzfPOgpi9/o2/NrVcK+ev0eF3jb/mQ6eMv/YpJ3/tceBzfGYa/LXP9YG/9nknf+0Y4N2fF4ibqTPkRfdy8jhYNG6m4isHS9xMjVcHStysjr2cHnGz2BgX08zz67aNT063/N+H+Np3KW6G9cJ71+48dHK+xl+bXHZ/iq9Zv44JbPbXVgs6oft754g6KzpjFemMCTqjolwr56/R4Xehe2jZX1vrSAd1nv21A22dM8/nmHlo9z3a21ifw/J/4bBuudl0lyLaiph1zpC/ZvnnZjSmY50zj3fziXdl/bWPAe8WBXjHuo1jI9uXZp1z79Osc+b7a2hnOb6GttFrnXNtjzaxv4b1W5uDFeuHWf5jyW6U9GOk3eA73NT3MireAx7trxn+CNWlrPyrvlPnmdhXxbI8x0sfjq+pGKzyC9V8keNrVbDY1iI2+2tFz5HPEXVWdMYq0hkTdEZFuVbOX6PD70LnL9lfq8svZH+tLr+wQ3Tq2mcX669dQj7HRkiL8Tks/xXgc1weuPua4zlWPnZfmuW/muwujhNV7a5hsd1l3m0j3ql9aaGz0pb/RODdk4l3SJt1G/nE9gXHVPbl1F73FqUlSdycVO05DM1FKt4bHe2vGb6657vMeBU6s5I+7K+VnD9M+GvKb1b9gP4a8hTpGxb7a2hn+aw02sZNlIb2jGMnqN8x30HANrG/pmRfxbjwPmeOcalxaaZoYx0+k+GPJFP5XUYGVXxFjdcqBmllVR++EX5jGtJZK+gorOWOWHY2uFmTnPquyJrkgeYzHeNIB8+fx94v8yancf8rh3bL3U/jvvoODdOLvV/G8r91H8xVmXdvJ96VvV/mt4F37wz4TKzbyCf2mdCXYZ/Jc16I5WPuaa+4JhPtM03HmkzofpmSPtqEz6R8NNUP6DMhT5E+x5GVnQ35TKH4F69lon7H3C+DbQqtSVpZky31jSpLw28c8T1o+I0jXMv8DfK18HtxRxPGKkhbR2lrIG094F981OS2HSXqETMXUrEjNU9iO7sJ6sK2CXH5Dtk/BNv05Zz1kCQJzyMsf+jeFayPmtsdH4F1VIB2rztJmbaK3XNdkiRf10aN1ng3zXgzM/s7CGlFbKA6B4xzj6HxLm5eP6n5V4hXqp/alB95o2wM3wsZOy9j+4OyjTGeL+eMx9gOtEFmb9Q4j2P523PWshA3JHuh9Xwle+qsdcyectR/thuh9fbQvfpqz5ja+8Z7xr5J/lkde8ZYvgcTLd9567I/A9v2dxFrvTGY/5Dh9Lo3w+lOgMF+vss57/wdYqmYCetZ3n3NvN/I8v8Y+oDvxkB7xHd+oD3iWFCsz2P6kMrNgiwWqtZ9OpDv/0TErdHm5MWtF0Ps9ReBtfKydoNjGGgHEINlKiRnat005u6jirHJ6HnEdNw9h+MDzyNK2s2JeUTs2jzOI1S8FbFsLJhuu4Z8irFrmN9sizr7xPqMNoLtANoIth9rA/TQRqAvbjYiZCNjfRaM3byJ9B/1i/Vf7esruo8m7+5DZcN4zMb8h4INO454o2Q55Meqc1/qXie19+eUCKyNAdpqj8opAdpYLyzLtPN0Uumi8aaO+Qb6BayLobu20ieGV6H7t/B83CmUFqu7vG8Hx3fWa5RtPLPB8tlr3y7rrjpTgP6Amg/wuqmHz8/r2L3uGDdc9vlPB929lHij/MiQ/vS6r43nTOosawgrFKfoZTeYtrIbXJckyR9ble4ab+rQXc979RSvVD+1k6k2kM+mYkyMx2TUXY4xoO7yfESNOUo+vcZd3kexqQcu8zMUq0FaSv/5blIsx3YD9Z/tBsoo243QeSb2Dzk/xwos//VZX1TcHypjBTyO4/4BJd88t7L8zwHb9tQc2zZUEHN7htMrVuA0jg/WPY73spust9g3PH9UYynylGMFxqPhRMcpcG8W5r8d+iD0bSf2F2LmAUg3tK9tzzc5KFaAutuBfHeT7JWNUz0A8vzc7Len3Qj51s2++uBzQO6rn267FoqB9uIrz92xjazP6ts5ReYbih7aCPTF3xwx39ggcNW+WZxvXELzDdQv1n/UcdZ/lHf2G9R8jscNZcN4zMb87wAb9hHijZLlkB+r7mzBeeYmag/K+mkRWKEY+xki/2kB2lgvLMu083RS6aLxpo75BvoFrIuhOEn6xPBK9VOb8iNviuouxxhC539Qtk3mlXz2WpNl3VVrzOgPTNeZOKwHt5FtEOKyz/8J0N3PEW+UHxnSn16xNp4zqVhbCOvYAO1edoNpK7vBdUmS/LFV6a7xpg7dxbGSdTfk76dPDK9UP7WTqTbwVEqL3Z/EMYbY83k4p2P5VOv/seMunoPlM7JqDSMke73WZln2lN/sOa6z3cC+ZbvB/iHn51iB5f8qxQpQRqrGCngcPwXqoOSb51aW/4dg276eY9uGCmJ+IzJW4DSOD9Y9jveym6y32Dc8f1RjqbqbjvVsONFxirxvsHwvECso6y+o+J2yRxgrmJ3dYcTx3PR3B/L9s1OcagzuTPoX8jc87EbIt+a9PmrMUXKm9qPgGMrlzA5UvAMyOlZg+CPJ1DaXiRXEzt0r2s2JWIHyw1U/YKxA3WuJWKFYQZ12LRQD7cVXnrtjG8vEA5T9CO1jQBuBvrjZiJCNjPVZcL4xk2IFqF+s/6jjrP8q9qvmt+w3nAZ1UT4PjtmYfxHYsLXEGyXLIT/2TJEf55nHU3tQ1s+MwArF2M8S+c8M0MZ6YVmmnaeTSheNN3XMN9AvYF0MxUnSJ4ZXqp/alB95U1R3OcaA4zvrNcq2ybySz15rsqy7ao0Z/YGYPYEe91Ozn6Z83w2iruz7ngC6ewHxxjvOFzNfD2GF5mu94nxMu4nzTc6v+ikmzhd7V3ZIP0N3ZeO4y/LpFSvg+0+VTQjJXq/9NCx7aj+N0n+2G0XjAUrW2W7wHeicn2MFlv+qrC/M/0QZqRorOIPqiPEMJd88t7L8zwDbti3Htg0VxHxyhtMrVmD9WIdPjfrOtiBkg9OnqN1kvVVjfIv+jVjIU44VGI+GEx2z5Pi25b8Z+iB0BoHjmmiPQnf3h+6CxVjBqylWgLrbgXzPJNlTcX20OSx7lv91IM/Pyn572g3e46RiRqExR8mZWufFMZTLmR2oOJeOjhUY/kgytc1lYgWx36eoaDcnYgVqjqP6AWMFai6CWKFYQZ12LbQe0ouvPHfHNobOTYbWMNh+bArQQxuBvvirSfeVjYz1WXC/wqfofnXUL9b/ovEANbdmv+EMqIvyeXDMxvz3gw17H/FGyXLIj+01X+d1GDVfD2GF4hRni/xnBWhjvbAs087TSaWLxps65hvoF7AuhmI06RPDK9VPbcqPvCmqu2dQmooHKN3FGNj7csZtbIeKVyp/AMf8Z9LYvb/ECj4KuvupJlYwhTbXs4kVTE6bzljBp2qKFby6iRUUjhV8aT+IFfwD2La/cIoV/M8mVjCRtq9iBd/qk1jBQGfv716xgu86xQqGO91yP2hiBaGniRUQvSZWsG9iBWYjQjayTKzgxftprGBOp1uu05mM2cQK8nWyiRUU012PWAHLp1es4Ls0dqOOs+6qewfqOIOAezLyziCs73TLndWZjOl9BiG0/zHmDELovoJecYrQ3qvmDILup5gzCKFvOqpzQFXOILB8qvsK1JnC0WSqPuB9BeflfJMWcUOy1+sMQujekdAZBLYb6t6BfXUG4QmdvX/7+QzC9s7ev2kfX9bRmEXPIFyZ4TRnEPbdGYRf6uz92ytWwHEOtEceZxBe2tn7u9cZhJs6k9td9gzCyzvdcrdkvz3tRnMGoTmDsAc8+3ugnkFAGxE6u+xxBsFsRMhGxvoseAZhM8UKYmOFrP/TfQbhtZ1uuXd1JmM2ZxDydbI5g1BMdz3OILB8ep1BYH8gdh7TovpifrRNRe9TC30bJXSf2vIcOnn7FV6R/eZ7mD7Q2ft3mu4Aa+/r+8J5nqz8MyXvfCd03ny2Q/PZjYH6qPqH5KuXvLAPieWsjjXe9Ti2r78LwbGTUN+ibvD4qvZBxPoJuA9iDvkJxwVoHh+gyWWxbcNJXMzR8v9JZ+9fnL+F+BuKvfTapxGKvYT2aWzMoZPn79xLbbX8X+h02zoNewvm1B077BXj5bE85IertfuQXpbxk/9pxWTcuuUrdh9Q6Bs5TrIwe1/LAttClIXQfgyWhZBdSp+QLOD66ndIFlpZGsY+T4LfJ0I65v9FZ+9fm08jXwr0z6WjUCYBDMQeLIndIrwk0fEPnOsreukzItIGI+qy4SX3Hnv484eOa1F5qwu/Y/kaEvmfLvIbr4ap7p0k6nmC0kGjbWmDkMbxEdQjq0Oqe+upfkMl6xfDP8Rvi7TD4HeRvpiXTJYFlHeza0dB2jJKm6590SsgT96+6NYR3XILj5iM6b0vmu9HL7ovOvQtrV77+5h2sy96cn7VTzH7opdBGn/HzXtfNMun13fc3hrhD4Vkz+ObBEr/2W70077oI7O+6Od90ZvBtq3OsW1F90WvzXCafdH7bl/0idAHvNaJ9qjufdHbsnr02hd9Osle2X3RTwZ5Piv77Wk3mn3Rzb7oPeDZ3wN1XzTaiLr3RW8j3Vc2MtZnwXn7G7IEpeOs//20L/ppYMPuJt40+6LzdbLZF11Mdz32Rd+dM25jO8rsi2Z/IHYe06L6Yv7QWmdorQ5pqfVMXrPHcsty6KBNwDgIr3Va/pdk/OjlUzvtJW7X/e2zXvNBnier/WZK3o1mr/nsTprPqrXO0Fptr7VOlpejRP3VWucyqP8e7PFu2r5a61S6UXStE+dBHDsJ9Tv2La87esU2tpOfsFHkC9kVxOX1P7VXFfPn7VV91xF7/6q1zrr6Q7U/tM98WQ4dtG1oC3mt0/I/GmnbnGKHc/b1t9x4PVP5nkr+eS+tslmx8m9l0746l2xhr/uOp2vstDrWOM7N3tfjHNvC0Dinzr6ExqNYWbCye/wusoXYV3x3RdHv4GL+12a/2e798RF7/6ItCPE+ZPd68Z5jOSrmHKKtvnvGtIcT3X5ea7L8n4P2c9xO7fsJnVFQfRjSKad9crOL7pPrxVtPneI4hzq/4a1TP8s246l9bzyGhmy60jOjk+dfGB5/u/NvhJy1iAbqLvKJx3HL/82A7ipehtaLeu095RhNaO/pNO8lnF33XsLY8badTLVrVfcSxso/ytC3l0/GVfuWQ7IQutsp/W3fmB8L1EOdrw7NtSxfHb4mtodlQel/6L6pXvNQ442K8bCcoC1iO7NC0DkG3rEsHCPo7Ll7iWzhOsjHc611gia+4/UTLL8uBwvXR7G9r4R0zL/8yL1/bV1gPZQpIAe3Ml8MA7E3lMRuEV6S6HUctH15OjQi0mL2bD209kfzP3zTv38tpOOhOYTS8StFfuMVyngBXt2odN1oqz1bPF6gvlod1J6tY0vWL4Z/ITuePlvHu/mK9IUaE16Z+GEtc8RaURLL9qWhfbK+GxP1nEt0lgk6ywJ1xvI43nC5Vs5fo8PvmI6qs9E5GtI62e/UFh95ZPc92+kBUZZtpOX/w3XdcqszzNAevxZhJ4n2A2xMUf1yNGGt64F1JWFheR4r1vfAuoqwsPx6wjqmB9YTCQvLH0NYIb8J+2dMlGfbj3VwGoeGi45DI6INZfYTxPqT7H9hWTWPZnlVY5TyzRTW0Y5Y6xyx1jtisR+ObZ5PdJTuHx2gg+Ut36goV9WOqjqr+U0n+53avIvIjq6DNDUnz/M1PwZ29PFkR7HPsf172jXeTbN8Fecth6h5C9rFofEubp6dQ9l6Xfa7nUy1TcspDfvAMDz7WvF0YTK5PUXnHlh+XaA9C6k9eTJ1XUGZMv6yTL0bZOopETKldHdOMrkuRXV3TiSdRRXpLBJ06rYRc4jOekc6qD+LiM4xjnRQFztEZ4MjHfQrTiI6eXpwF+mBik1i2Tdkvzk2eTbowT0BPcA6Ynnc+71OtIPpvYDiBiXnq3LvN8bwQ7x7UQEbkj68p9byHwG8eynxDmmzbiu/WMVr2W9AXrGvo+Jjal9PW5RnvmE546/1F8bJ6thTa/gjSSX5mPCBVRxQjVfWvuPK0ZvYU6ti0KofcE8t8hTp4x729FF2lmOVaBt5zRztWSjefSL8Rnp5beL5qJJ90x07SzoHdOctme6oMema8clpeBY1K7YH4+2kf8gHjp+qeSy+C8VPWV+RzvyKdOYLOnWPn+zLo13oZL9T/j5KNvMYSBsQZdmXt/z/b2233GOB8Qbbv6dd4920On159B+Gxru4qCN76pNM1Sn25VGn2JdX8YxRymvp6q/Vgd/tK19+uaDDMRWWqU9EjMNYNs+X/yeQqd8NyBTf44V1Zl8e+2BAvAv58iE6iyrSWSToeMqN6s/Gl4+nE/Ll8/TgzyN8eSyb58u/EfTgy9Pgy//VNPryebz7XwVsSPrk+fLPBt79dQEbomKGyl9nXx59vry9K0kS3vegYo2WT+2vMP5W9HWjfXnDH0mmtrmML6/2g6gYrLXv+HL0Jnz52H116Msr/x2x2JdHO8tjKtpG3teG9oz9/JAvv65Hm9iXV/VjLLzPRfnurGs/zfQr1bV/Id8f9dxop/lesGpyPjUGWR8gb4r2O+IliZZr3hNQcu/DhFyHYsTpw+s0an+C6vtXw29MQzqx68qrHbH6wQ8bq0hnTNCZbj+sLv9ojOjU5R91iM6xjnRwTGQ/LG+Ou2BV9z3aVTXHTR/2JSz/PPAlFmeYKl7A4z7uSU1EfvbDLP+KjEbFGJ30w9ifyOPdocS79ZAWwzvL/9M13XKdAO9Yt2N9rdBefT6jpPwNtf86tGda7fPm8aqknxLthxn+SDK1zWXGq9gYp7XvhHL0Jvwwta9d9QP6Ycr3QqyQH7ae0tA28hml2LMH7Iet79GmkB+2Pgcr1g+z/JvJbpT0m6Td4JhW469NLlv3/kSMk1fFavy1Lh1+1/hrPnTK+GvXOvlrbwGf47pp8Ndu6AN/bbuTv/Y84N3NxLtQ3Eytf4TOJSlfjsfBonEzFV85WOJmarw6UOJmaBvZJ0N7xnGzkL/mETeLjXExzTy/btv45HTL/9JVXcwXU9wM64V3PQwdNTlf469NLrs/xdesX9VZA/bX1F0hRwXozImkM1aRzpigMyrKtXL+Gh1+F9rbwf7aakc62L/srx1o65x5Psd7yL6pdc6Qz2H5l4HPsTvgr8Wsc4b8Ncv/GPlrda5z5vHug07+2n8c3S33KwHesW7j2Lia0pp1zr1Ps86Z76+pPXTKNnqtc67u0Sb217B+q3OwYv0wy/9pshsl/RhpN3h/oBqrZlJdy8gH4iWJln/DH0mm8q+M/Kv9ptg+9tfWi7rwHC99OL5WdH8m0uH4WhWsxl/r0uF3Rfy1us6ysL+21pEOylGH6NS1zy7WX/s78jlCe37Th30Oy/9u8Dn+IRAjyjsjHLsvzfL/gOwujhNV7S6fF0Zb18l+7/lOVs5cHnmHNi1vX9o48O6fiXdIm3U7dIYNx1T+3hbyivf7FJ2Tqj2HoblIxTsiov01w1d3epQZr9TZ4NAZk5Lzhwl/TfnNqh/QX0OeIn3DCvlrqykNbSOfE0d7xrET1O8Yfw3bFOOvFY1xHcw+01pRF9WHb4TfmIZ01go6Cmu5IxbfU493ErDPVPRukjmRdMYq0hkTdEZFuVbOX6PD70J3oLDPVNfaJ/tMdflmHaJTl28Wu5f/qKO673EcKLof/QgY99dkBdS4z/MQXDNIRH72mSz/hozGdMxV83i3kXi3GtJieDcxTwfeHU+8U/fuKL7yemXIn0Jeceyg6LwQy8ecAay4JhPtM03Hmowaryr68BM+k/LRVD+gz6TuCUIs9plC37ML7S9Tdy4pG8Q+0/IebQrdE8V7YJYIOpa2CtJWUNoaSDP8VO8uJr3D9mef0J7QW6N9A9kgPEdcoM/PGiU6hoHYJe9WOitWX/JiIFgvdc/TYERdTvy7Ty8auOXmD7WSqTYxFKthu4r5rxH5K/rCp48ajfFuefTV02cQ0o6itCFIszqoOwVL+s6nx/AP8dXcaDP8LtIXCmt5SSy7u28llOe75VG/D81+h3zAijoYPQ8y/BGqS9lxRd3HqvYFso3Asm2Rxmv9KwWdlYKOwlriiGW2WfUzz4OWCDpLAnTmiDorOmMV6YwJOqOiXCvnr9Hhd0xH8cborHCkgzrD86CVjnRQDjpE51BHOodCHp4HLRN12HMfDvnyGIdRc2P25S3/+1d3y7084FNgHbE8zoOWi3YwvVeTD1JybJHzII5T5fHutcQ73CMWwzvL/xrg3RsCvGPdxjGJxxHkx0pKQz8BMTAtgTaE7izD8jF3lll/ob9cxzzI8EeSqW0uM16pGJga461968rRm5gHqfmo6gecByFP1XoNz4PQzvK9J+puIGXP2OdC/Y6ZB2GbeB6k6tf4QnG+UPrwOnoV/+XIxA8r5KM0vtBkOo0vlJSiU8YX+iMnX2gdjOd/PA2+0Gf7wBf6nJMvNAq8+wLxDmmzbiOfQt+uZF9IxZJblJYk4dinih0y32pYw4z2haZjDVONVxV9vQlfSJ3pUP2AvhDyVPlFIV9oGaWhbWR/B+0Zx5JDvtCyHm0K+UK85ojxXM67FNqLeb99VLfMyOp8Wocnk9OWQtoRlBarn4iB/EVbgfmfQ22w/D/I2pDGGr+xXWPOSLSMmv1RsU9rR8V7Cz+l7i3EsXRofHKdcfwL+VSW/3CRH2WOfcPDIY39OSWPed/K2pNnvFve6lgHv7AOMfzC/EX5xXqP/FpFWMr/RR6G+GV1rINfWIcYfql9D7H8Mh4ofq0hrF5znIuproY9nGibYHiDnD+zZer7kyEbv1Rgo21sEQa2oyXaMUppWDbFXZpVYLriPOxrroW6sCwg7iDlXwD+2dHEm17fsGH5UjEOjFvwuj+O4+sjsJYHaPf63gPTxnrxOTBe71f+hrIDxpuKdmBI2QGMV7EdUP2k9nOFeKX6SZ0F4TX02JjTWkqLjTmZzCv5VPGnPJvN+oDzmc/l7H9B3JDshfYAKtlTMVal/2w31P3jSpfYbmDfst3gWCLn5zmq5T8pq2idd9iwfA8mWr7z9nI9HmzbqTm2bagg5ukwHoW+DW/9WNEWDCpbgPrOtiBkg9OnqN1kvcW+4bUGtW6OPGWfwHg0LPIjHu8zuyDSJ+A9PbEx8NC8z/QhlZunZ/XodSbhEpI9tGlqrsiyZ/mfCfJ8Oc3xPOzGoZSm9t6FxpzQHeZqr5WSZ7MDFfdDRsdSDH8kmdrmMrGU2HUejzsd0v82CHqqHzCWkvdNP8OysWC67RryKcauqbWm0Dk/ZSPYDqCNYPuxMkAPbQT64k8n3Vc2MtZnwfj1H1EsFfWL9R91nPUf5Z39BuQh+w3qTBraIL5DxfLfBTbslcQbJcshP7bXd7hXU3vUd1hCWEcHaG8U+UNn9dX9N1yXJMnXSaWLxps65htlv8eRPjG8Uv3UpvzIm6K6y2egcHxnvUbZxvsdXpkzbmM7VIxX+QM45l9CY/f+Eit4M+juI02sYAptrmcTK5icNp2xgkdqihW8tokVFI4V/Np+ECv472DbfsMpVvCJJlYwkbavYgWf6pNYwd9Hxgr+1ClW8F2Q5883sYLQ08QKiF4TK9g3sYK/rylW8NL9NFbwI7BhraMnYzaxgnydbGIFxXTXI1bA8ukVK/jTwNgdmqeG7v2OuZeI+w919yjBg0HKPxvuAjiMeBN7b0+s/hxF7VH6E8JaHaC9SeTfGKCt7srkuiSinlZO6a7xpg7dRf1k3Q3ZzPSJ4ZXqpzblR96oM/2s8xgv43uQcGzj+IO6I0nJp5rT41jMuqvOLKe4fK+G8ktCstdrvsWyp+JUSv/ZbqD+s91AGWW7gX3LdsP6E2MF6lsTg5R/Q0akzm80sHxjrADlO+8e5PPAtm3KsW1DBTFPyHB6xQrwDP4eHEir6lOjvrMtCNng9ClqN1lvsW/4/js1f1R3lLGeDSfah2B/0/KfBX3AsQK0R+xnoD1iXyL2jhGMFTwtK8T3z6S/O5DvfJI95Wejzcm7J/ImkOeLst+edoPvOkQ7wPE7NeYoOVMxJhxDuZzZgYp3AUbHCgx/JJna5jKxAqV/yo+uaDcnYgWxd2FjrEDdb4hYoVhBnXYtND/pxVeeu2MbWZ/RRrAdQBvB9iMUm0Abgb7400j3e62/hXwWjG8fRbEC1C/Wf9Tx0Pe52W9AHrLfsAnqonweHLMx/21gw15MvFGyHPJj1XcW8d51/t44yvrxEVih+a+6E/74AG2sF5Zl2nk6qXTReFPHfAP9AtZF1U+YP4ZXqp/alB95U1R3N1Eaju+s1yjbJvNKPnt9J4d1V8Vk0R9Q8wGeK6Bes37Gjt28Do9tVHE+jBlj/leD7j5MvFF+ZEh/QjKE9VG26LgIrFCcopfdYNrKbnBdkiR/bFW6a7ypQ3dxrGTdDfn76RPDK9VP7WSqDeRvwaqxTOknxxjU2KrWBHBO93DEuBsb58Nxl+8t39ADt2h822iF4ttK/0PxrZhxXck62w32Dzk/xwos/wcpVlDyeywyVsDj+Caog5JvnltZ/j/E7/7k2LahgpgfjYwVOI3jg3WP473sJust9g3PH9VYijzlWIHxaDjRcQr8FgLm/91ArADtUVl/IXSHO8YK/oZiBai7Hcj3Sac41TdBnj9N/oaH3Qj51s13rILPAfkdq+m2a6EYaC++8twd28j6jDYiLx6g7MfaAD20EeiL/03EfGOdwOU9N1g2xbXv1CgdZ/1HHWf9R3lnv0HN53jcUDaMx2zM/x2wYf+XeKNkOeTHnizy4zxzA7UHZf3kCKxQjP0Ukf/kAG2sF5Zl2nk6qXTReFPHfAP9AtbFUJwkfWJ4pfqpTfmRN0V1l2MMOL6zXqNsm8wr+ey1Jsu6q9aY0R9Qcf7Q2B2aP4e+QYn14DayDUJc9vkH4Buki9dMxlR+ZEh/esXaeM6kYm0hrPUB2r3sBtNWdoPrkiT5Y6vSXeNNHbqLYyXrbsjfT58YXql+aidTbeAJlKb2rlgazs05xhD7PUyc07F89tpvHRp3ca8Rf5NWrWGEZK/X2izLnvKblf6z3QjF3ZRvpGSd7Qb7h5yfYwWW/6isL8z/RBmpGivgcfx4qIOSb55bWf7TwbatybFtQwUx12c4vWIFTuP4YN3jeC+7yXqLfROzjxN5yrEC49FwouMUvDZl+U+GPgjFCthfQHvE/oKK3yl7hLGCJ2X14Hhu+rsD+c4k2Ssbp7oe5Pmc7Len3Qj51rzXR405Ss7UfhQcQ7mc2QGzKyiLdcQKDH8kmdrmMrGC2Ll7Rbs5EStQfrjqB4wVIE+RvmGFYgV12rVQDLQXX3nujm1kfQ7FE9FGsP0I7WNAG4G++JNI93vt1Q35LDjfeA/FClC/WP9Da2Yq9qvmt+w3nAx1UT4PjtmY/0awYfcQb5Qsh/zYU0V+nGdupPagrJ8agRWKsZ8m8p8aoI31wrJMO08nlS4ab+qYb6BfwLoYipOkTwyvVD+1KT/ypqjucowBx3fWa5Rtk3kln73WZFl31Roz+gMqVsD7forGA5TOs5+mfN91oq7s+74UdPcB4o13nC9mvh7CCs3XesX5mHYT55ucX/VTTJwv9O3AWP1knUfZxnH3gZpiBdspVqBsQkj2eu2nYdlT+2mU/rPdKBoPULLOdsP6E2MFmJ9jBZZ/F8UKUEaqxgpOoTpiPEPJN8+tLP8nwLY9mmPbhgpiPhYZK7B+rMOnRn1nWxCywelT1G6y3qoxvkX/RizkKccKjEfDiY5Zcnzb8n88ECtAe8RxTbRHHANR5+GUPcJYwVcoVoC624F8v0Oyp+L6aHNY9iz/V0Gef5/8DQ+7wXucVMwoNOYoOVPrvDiGcjmzAxXn0tGxAsMfSaa2uUysQOmfmu9UtJsTsQI1x1H9gLECNRdBrFCsoE67FloP6cVXnrtjG1mf0UaE1jDYfmwI0EMbgb74V0j3lY2M9Vlwv8K1FCtA/WL9LxoPUHNr9htOgboonwfHbMz/v8GG/YR4o2Q55Mf2mq/zOoyar4ewQnGKM0T+0wK0sV5Ylmnn6aTSReNNHfMN9AtYF0MxmvSJ4ZXqpzblR94U1d1TKE3FA5TuYgzsJznjNrZDxSuVP4Bj/u/sp7GCfwfdHVs7GbOJFUytZxMrmJw2nbEClk+vWMGhTaygcKxgZdYX/RwrOCGrY9rHh+fYtqKxgiMznCZWsO9iBcdCH+zLWMEVWT16xQpOItkrGyu4CuT51Ox3EyuQTxMrIHpNrGDfxAquIN33ihUs2E9jBdeBDbuDeNPECvJ1sokVFNNdj1jBHTnjNrajTKzgJBq7Q/cXqnsH6jiDgPs18s4g3Au6+zrijfcZhNDeqJgzCKH7CnrFKZh2cwZhcn7VT2rcZT1D3eUYgzoHpPQ69gwCy6fXPUH/68jJuL3G8zru1VT6z3YD9T90d850nEF4O8UKSvr0tZ5B+CjYtnfm2LaiZxDeExkraM4gTOWp1xmED0XGCjjOgfaI/ZMyZxC+QLGCvDMIv0ayhzZNxeDzziB8CeT5N8jf8LAbzRmE5gzCHvDs74F6BiF0BxraCI8zCF8g3Vc2MtZnwTMIf575LEVjhaz/030G4a/Ahn2feNOcQcjXyeYMQjHd9TiD8P2ccRvbUeYMwq+VnMe0qL6YP3SPYK/71Hh+ou6LGxPllufQyduv8IbsN9/D9NNIn9rprpyZ+/q+cJ4nK/9MyTvfCZ03n/0EzWeVvIS+Z1nX/Xvrof57sMe7aU59e0g/923oHjSeS3nda/QoyUIrS8P5/knw+0RIx/xHZATMh0S+FOifS0ehTAIYiD1YErtFeEmifX70bxW99BkRaYMRddnwknuPPfz5Q8e1qLzVhd+xfA2J/E8X+Y1Xw1T3ThL1PEHpoNG2tEFI4zkB6pHVIdW99VS/oZL1i+Ef4rdF2mHwu0hfzEsmywLKu4rvh74lUmd8H7/7lBffX7uuW+6MdZMxveP7/I216YzvM+0mvj85v+qnmPh+6Jsf3vF9lk/lF6+AdzwGqm8Yprgvqjm+z7IXG98P3R24r+P7F9N434/x/RvAtl2SY9uKxvcvz3Ca+P6+i+9fB33A8f3QnYTe8f0XZ/XoFd/fTrJXNr4/DvJ8c/bb02408f0mvr8HPPt7oMb3Q3cOe8f3X0y6r2xkrM+C8bO7AvF91v9+iu+/GmzYw8SbJr6fr5NNfL+Y7nrE9x/OGbexHWXi+9tLzmNaVF/MHzqr1Ctey/OT2Hjt0Tl0isb33x/pUx8M8f3QNzU5vp83n72O5rPqzFwovt/rW7wsL7Hf4j0a6r8He7yb5vRNxEPq/mZ7rC6pfcah7zXxt128YhsXHdkbNyQLofOW2IYxUQ/2NbCcfYNOyYLTN8CHlSxge1gWen2bjnkTkh3kjRpnWE7wm3z87YcVgo76juZoMlWurGwqC0eSz7gK8mVJE2lrII3Xf9dC2mpKU7LBsoTjwxLIY7j8reKvgM/4XRo7VZ+tgXdF+2wJtQf7YkME1qoA7V62g2mrcZjrkoh6WjmlW8abOnxGT91SvFL9pOzsBko7EtJWUVrsHflrKU3FvZV8rhLtWALvWHeXiLqmuK9aPhl3rcANyZ6y+6jHLHtrRPuU/rPdCH2HE2WU7Yaym6xnGKPG/Byjtvw/oxg1ykgBWZcx6rz1eIxRx3yPfHaWKe3jn+fYtqGCmP8e6U9bP073d6i9fS7WW+ybNYS1RmCp78+yng0n2hc2vEHOn2VSMWq0R6FvZbG/uFrQVfYIY9TrsnqMJlN1twP55qyf3G60aWwv0odlz/JvAHmem/32tBvsb6IdQAyWqZCctUV5HEO5nNkBsysoi3XEqA1/JJna5jIxaqV/an2zot2ciFGr+bPqB4xRI0+RPu5jSJ/ptmvIpxi7pvZkqfkA6zPaCLYDaCPYfqwO0EMbgb74OtJ9ZSNjfZY1gPuizGdROs76H/omF8o7+w1F41Hqu6McjzoRbNiFxBsly1W+PxT65vimCKzQvoRedxQxbawXlmXaeTpZY1xnqO6YneKV6qc25UfeFNVdXpfC8T0UBzSZV/IZ8vPTh3V3rair8gdmCtwZAtfyzwGsAcJIf788+z1I+S8Fv8l8V8McE3XAsZP7dK7IPwZ5rD5jVAcsOybKmZwrebd8FeV9jpJ3bA/L+zxIGxD5mTfzRX6c57BvNB/S5lDaKKQZzVHCQX6nMvGlJZPrM0fUB/uW5WsuYA0kU/vvFdnvQcp/Q0C+FA9nwbuiPLT6jFEdsOyYKNfOfiv5snwV5WtMyRe2h+VrAaQNiPzMm4Ui/wLKkz5tyo98srQ2pBnNUcJhm3PNwsn5RqE+rZy/Vld+x7qA8n4Y1WeOIx2U55OIzmxI62S/93wXhex2G9IGRNmXZL8HKf/94AM9j+ZxWH4Olbe0F4KefWt7fnnj5Vgylbch+8zyptoZsgeW/2VQz2+APqQP6p29q6h3baV3bcjAeqdsDOZnPoT0VNlu1MnZhDVbYKF8s002Hg0nug8Mb5DyvyEQK0GfoU11n1Gw7mo8UXbEyqayNJrZkbFkqi2aSzTbgqbqq7Yo387BmiHqj3rL/T4gaKv8JhMYr1T2eZDyvwP66tvbNWaSU4fZOXUezsk/n+pg+d8t5CVkB1D+5xGm5d8FmL9eEHM8B/PRgK+h9DTkr/UaT9mfQD4upDSsO4+LC4A+5/1loo9pKOdMNwnUV42pofryeGNpvwfj1Uez3zMJr6CtHgj11S+J+sb21exA+xjLyuF5uxgdQX781nqNOVQQ83fEmK58lRMB//dy/JEkmeqPpA/bZbQZqIf3kE+C9CfG6GTyOPFJoY9qrDesamN961tqrMc589B4FzePN5g/Zn7L40iS6PGG9/XjOMt0Zgg6LXgXGkutbNpnf70gHjf9ezvVQ9lhrOvO7Dfb4S8F7LDiIcY6mBeheTbWR9nheZSG2CZzSh4xHr+nfZBWVR6nM6bA8qjGD2VP2M/ykscvZvKo5uAc/1F1DY0P8ykP/jYbP5yTn22+5f/7gN+zSNQhZDsWi/yLKA+2H8elxYmmjXqJPLl0fHJ7LP8PIu2xU8xjnpJ/5BvLf4hH6cM8XSLyI6+MJ23Kj/xVtnoRpamxOqSzsbphZffsfS5gqxGX7Wqsrbb8vygYnwvZ6tgYZx/G5+YdiPE5tL3jJF91+T4xsf3QHLXonF75qyrO08r5a3T4HdNRdVZyzO1RfJsb2R6O7c91bI+qM8du09+d7HcqQ8uO6b5n+zVAZdOHxyHLf+Ix3XIrs98qHmk8LypTs5LJ9ZwLPFC29MrxZKL96YP2xXDrWE9F+8r2JWRLrS2Yv5dPxDYEbc8oYY0KLJQ9HNP25Bnvlneyx0NF47Yh+5Q+MWMV6oS1LWY9DuWNbaLiJcpeyD+YuNvlv/67ZEHv+s8JtLeXfPC6AI6/CyhN+eZKFixfHWMztodlITTWpg/zRvnyOP6yLKDfPo/SsP95fFf+lLKX3MdoX7FfeC3J8m/NbGpsHDQkN738Fp5jq9haaL433T5dv8gNx2PR9hSVG7YhaM9xjLbxW+n/DPqt5A3zDyTheL/hcBtmJTrW/UJqM/vSjP0iyo9rGzMCdecY63WgK58J6IrCfDHVYWGPOuTFGZ4q6hDif/qoOYqNHRXj8IM4BtnDPiXijyRaPjpJ1NMK6Z+aU3EsAcuGbHRIb1WcQWG1HLHMb1D2cQ7RUTZgXoAOlp8XoNOuSEfFW5V/28r5a3T4HdNRvDE6Cx3poM7wfHKRIx2Ugw7RWexIB+NhvKclb573EprnLYE0Nf7w2QTL/983dMu9jOZ5aCs4vmnl8fzRfNEOpveqjIbZv6VQpoA9kuePDKsX715DvFM+XIh3lv9DwLvXB3jHuq1inGPJVH4sojQ8D4sYmJZAG/AdyxyWx3PHXI7HK7xbt8hcMUY3EH8kmdrmMuPVcqKHbU8fPtexohy9iXMdKwU91Q94rgN5ivQNy3RM2Vn2UdE2LqM0tGdLKQ31+0T4jTTy2mS+7VigfqE1nfRRvj/L3nT7SgvK0Qv6SmquUtRX4vWNfvWVVDwmJFPzA3Sw/PwAnXZFOqG4vfLjY2RL0VG8aXyl3nTK+Ep/5OQrPR7G+z+m8R5tRYyvtEC0g+l9tg98pc8R73CfVAzvLP+xwLsvBHjHut34St164jvEb3ylfF9J+Rt1+koLerSJfSVVP+XvpE8niXtifClsX4G+OyJWNg3fy5dSfonypax9i8vR66SyNisrh3bzTviNvEM6C6kOVftPxWb2Vf/NK0cv2H8qZuXZf6hbRfpP6SbvtyvqV6p9NHX7lbw3IW+M/zmN8QshLWbPwITcwxj/74E9A6F9RLjPYU+bx7tpTmtOA/t6H1HIR+f1KNxrwvM+tW6tzh+rc6e4br1wga5/C3BfIsqybmP+haIelt90zvZ6ch4rO0j552Tylfbfb23XdUaZxXrxOqzlnwuYvA6r9jqG1hp77XVkHxX5zHdNYTm0F3uwx7tplq+iThyhdALbwzqxFNJCvqLlVz43+u8s9+jL9jpLkj64Ls/yqeo6r0JduR+xr5YRltoHjO1hubT8Rwq5VP1vPK+j/0P7gBVPQ/uAe/GU413Ix8WUhnaQY1nK9sauw6MN+fk0z1E5ZrAc6jIg6mq4g5T/JBiDL9owGVPdmRnSWTU/wzkX70fCudnKCKyQLT1U5F8ZoI31wrJMm+tp5WrULblPDufarFuqnzB/DK9UP7UpP/Km6Hx5OaXFzpdN5pV8Kj8rVncxLsUxK2WrQrIXO1Yp/V9GaViO7YYa45Qusd3AvmW7wXEQzs+xRst/TdYXNv9CGakaazyU6rgC6qDkm2OIlv+ZYNuelGPbhgpiXh85zlo/1nF/Guo724KQDU6fonaT9Rb7huOkyp9FnrJfbzwaFvkRb5Dy3wJ9wHcdoD3i+6Fj43d8L65aQ0jl5rVZPUaTqbrbgXx3kOyhTWN7kT4se5b/DSDPz85+e9qNxZSGdoD9VDXmKDlT/hmOoVzO7IDZFZTFOmLihj+STG1zmbhVbIy6ot2ciIkfIeipfsCYOPIU6RtW6F7IOu0a8inGrqk4eTuZ2kbWZ7QRbAfQRrD9WBSghzYCffHXku4rGxnrs+A65B/RfAP1i/UfdZz1H+Wd/QbkIfsNh0JdlM+DYzbmfxBs2GPEGyXLIT/2SJH/CMizlNqDsn5kBNayAO1VIv+RAdpYLyzLtPN0Uumi8aaO+Qb6BayLqp8wfwyvVD+1KT/ypqjuHkppOL6zXqNsm8wr+Qz5+enDurtU1BX9gena++cVK/g10N1P93msIBRvb2IFWX2S3jbWM1YQuw/RI1bA8qnW32LHXdzv+5qIWEFI9uqKFbDd6KdYwZf3g1jBd8G2fcUpVvDVJlYwkbavYgV/F4gVoDzVHSsYyi6q7hUr+L5TrGDmsd1y/xSIFZS1G02soIkV7AHP/h6osQK0EXXHCsxGhGxkmVjBSwKxAtb/fooVtMGGHUm8UbLcxAr2Pk2soJjuesQKWD69YgXsD/DeqfS5brz7jvey8L7IPNvENidvr5WV5bMH67P2414rdT7FsNK2bThWty1v78tiom35Hw92YlP2eyyZyi++Xwh5w3tn0X5y3s2J5sGpUI+Tjs2nZWvJo4E2phinHZufb7PIxxgzBA9Cd+SxT7dQ1DkhzBkiL9NYIMopGvMJE3mmxsKlPdKXiLYl4t0MkX9RTnsTQXtxD9yFAkfFM3nf0jyR1kqm6lSVfUvPzCqg9CVPJ5RcLQrUned+oTtWVN0V/9B+hO6isX+zbM0T7WyJf1v97oF3bGPVHeyYx8ryGadtwmYyZt49QXfnYD4ZMHl/qpKZU+Bd0btw2HdUeq7qjraE36n+mU15eX/nZlGnvH8vEDh5dVBx+em822cb6SaeaR2lurep7piXz9Liv5V8t+i3tRXlG/OwfFv+Zwbku9e3h+7OwXxWQL4V30+Gd0XvNo359pCqO9oefqf6h+Wb7dFmUae8f88VOHl1aAsck+/RHEymyfKQPqH77/D7Qt/JKqj4O5NoFr1zc6aoP38n7aUgS/y9CvXtNWwjn2mx/C8PyKf3PelWH2Uf5gXKYf/NFLQ69uM/w4/hmS4ckuTLIN+F8jrg06e267q0uD49ntFkKp9b1M6S91l1UIbtUTFCwx9JpvKiTIwwdKdl+nCMsOS5ycPxHBzK0Z3wW+31xf4y/qNd6WS/Uz16iOZ7Ssew7F3Zb9axh2Ge9bYczCSpZpu+NG8yrvc9/qF7cEPn3Xh9MO++P+yjvG/u7Mx+sw/5COhm6HtePufrWj/Z13c68lo0zmvyfCfEwr7meIrxKO87BfwtHsv/q9AHvG6l9rFb2oyCdW+Luis9Rt1gPVbfCZspcEN6j+cWb89+s95/IjC2tkUdUO+L3n3O94HH3lNtfaP0xene6Xn7+hskVv+Ye5SVHzlKOMjvVCY+RLb3VMjHMeH0Yfk6LXufF8O0soOU/0/FfMXaMQJ1OJXacRrUxWTOxuOzqe6dJOqZgeOSPcrfMPwRqktBehP+xtlEj9tnspL2l/X7PTufcfszdj7/kju337x1+7Pvvuf2HXiqGDnOVFqEiu9YgzFtgN7NonyXj0/+t/X+QJL/oHSl/50HaYoTfDMHtum8nHIsufxuhsh/NmGdLcpZ3QcC5REDy7HEsBahlT5V0GYt+hpo0Xe259M9NZnKB9akmYKead15lDdJulq3ldrUSaKea2O1zvBHqC5ltW4r0eP2ldM6lBSkso1QLQ/mxWcb1Azzz6J/c+/NFuX4MY6NJlM5wb16PpXpJFHP/NheNfyRpJIUTfTq+USP28dztwvK0ZvXovJIDzGtPsbrC0WaYV2f/Ru1H/NfAG3A/Pg7fQbp3T9n1qEtMA+jOlwo2oPvZkAdv09rAdieowhX9cv5Arctyls+RWdrRTpbI+nU0R7rpwl/YuPevylvf0G8PTvQZjXanB3Z5rOTfDpHVaRzlKBjenAkpPEdgasCaRsgbSulHQtpHUrbCGn87fNNos2WdnwA8wSBmfbdb2zsvk//uyPpPmqkYa/mNsDFsvjvIZGX18gt72KQq7GNk9uA/c28VnpmaWjjOpSm7Iuloc1iXt8QwHyGwEzb82FqD/MrfczWvwneF7D122LHMsMfobqUHcveRPS4fTyWvbkcvWtaVB7pIabVx3h9n0gzrPuzf+NYhvnfDG3A/Pg7fQbp3VFZf7cFJo9l94n24Dscyw4jOULet3L+Gi6/YzuIvLH+Mzqovx2oz7ocG4L8xLI252fdN0Xds3afYSo7w32r9Khs++8QbQzxuaI8L4jVV8MfSSrZh1ZIf7B9rK/3laM3P0a+sT7G6/tFmmE9kP0b5Qvz3wdtwPz4O30G6d3ZpK+Iyfp6v2gPvkN93Uz6iryvKq8hm4ezzg7UZyvp65sgbUCUfWb2e5Dyf//8brkLSV9RPrlv62o/j/tbHemgH9qB33mygO03/hlvUO7vp3Ioq6xzStYfELQVvmH0ko2rN+q25cmG0eKx789BNq6NkI2xJL8/x5KpfYB2Os++YP5nJrpdwzn589r11Kwt6ttRVj7Pj+Bxz/JvB0xet1CydRu849i8kgdlGxVPH0h600Y+c1zdyg8nYVlku/t0wVM1Hlv5UVEX092ZiZb7ThL1nBdjHxB/JKk0PrZiec3j8QPl6G0JyQliMq8fFGmG9VD2b5R7zP8AtAHz4+/0GaR399J4jJg8Hj8o2oPvcDx+Do3HyPtWzl/D5Xc8Tihd62VzX0Q29z5IUzb3WdnvQcr/22BzX0o2V+lh3e3nOfMDjnRQVjvwm2VK2SHjn/EG5eohKvcWSMN8OB6jPL9F0Fb4htFLNt64UbctTzaMFuvSu0A27iPZwPL3E2+Qbw9QGvY1j8e9xqFnUX6r93AS9nMGKf/bAuOx8l1Qbng8tvwPB8ZjZWdC47GSRWUbFU8fIqzbBBbymcdjxVNs/23Ufsu/O3I8tvIqPncipWF8jucpGJ/juQLG59i/x/jceZSG8Tm2wxifQxnh+NyRgfasgjSOF2+ANF5TwbjvBZSGcd8LKQ3jvtdTGsZ9b6A0jPs+A9pqcd9BausnsvcV9yfIuxjy4uqcD/8mSdx4gH01i+ic7UgHsS4cn0znPEc65wXac76gU3GNMHo/ieGPJFP1uozfq9Yk1dpUsZVtXnVCriAqvmslk1uPaQP0ro79JGo183yBaSMFtunCnHLIi0S8myHyX0BYF4hyVveBQHnEUCuX3H57n7efxDAGKf+XYLT6/vZu/jxayA8eMa3ueTvDuA6W/y+hDnyS5QIoo9p1fg7md2Al7K82asxEYKp2XUjt4jpcQHWw/F8XnkBotT/JeZf+G/fqYFn+t5KZUyn/9T3aw/1k+b8V6Ketog6ok8xTrgPnuTCnDn8v6iCs29Y7n/38zLol9AzCb7ZGivO872arwMl7jBt7zuNkNWe/ly2VescSYGXTltte66zl5++4fcfOHTltZ8s9K4fmjEQ/MWNoybXQ6DHU8L3GULVmr8ZQXsfCsmr9D/sX/92LTtqntu8869Ordt55V16Xxg6uLVEtLp8QVku8Sx9e0sS0fSUGt5WjFxQDNTUt5krxxi/kCqLiuxDne/W2OdX2lHGl1GaE2wSmuVLYpjfllOtl5GaI/HcQ1h2inNV9IFAeMbAcSwxrSJ4rxS6H5Z+RzTJxay6XsX8/F34fkf2ucWPLvFit2lcbW4ppFZtWozKXUC0P5sVnLtQM8+cNi/bY8dQYrYoZMkv26mjZXq06ZKpeVUNZxe0ds1tUHun123alJZn2e29XmrdpMj2T/aM2dfMsy36r7T48Aik3RI1z7STfYvLRnPQ3byncKtqvQpacFrulkEODZbYUPmvT5HweW8FCfYyWj0dRlOf7COv+HlhXElbeFob0vwd6YF1FWGoZgd1dLBdarjJ7wEtBnSTqmRNr7wx/hOpS1t6pZQtsH9u7h8rRG21ReaSHmFYf43XeMlv631uzf6O9w/wPQRswP/5On0F6dwbZO8Rke6eW9fAd2ruTSSeR92V1Ui2BW//12p557qbJbVHb57Dsvdlv3qbxSlhC3Er2GuWT+7au9rP9PN+RDo4ZHfidJwvYfuOf8UYtD1s5lFXWOSXrbxW0Fb5h9JKNKzfptuXJhtEapPy3gWxcHRjLHyTeIN9CR1rYB1L2DPPfS/mt3sM5+fOWza+HGREvL6uANdaLr4Cx/E8FTF5eVnZTzTZCsqjsrOLpWwhLzTaxPRwAVTxF/TQ85ukOwdOY7efoq/FyLPpqvISMvhovBaOvxtti0FdjvxF9NbbD6KuhjDyL/GBrz3Oy9xWPMcolV9Yp5CEuU2NaknT7Ux3tbovypwXobKpIZ5OgMyrKWbsr8jE6fsfHQaserVfH9BRflE23sm2Rxoshq7J//yvMv8bJZzkCK5j9Nb7iUnuBdp4Sy1fDH6G6lOXrkUSP28d8XSXqoq4TfjL8xjSks0rQUVjzHbHOdMRa5Ii13BFrSZ+20bMfPdu4ok/buMARa5sj1mpHrLYj1hpHrIWOWJ4y4amPnjrkKROe/FrsiLXUEcuT9/McsTx5P9cRy5NfnrZwmSOWJ7/61RZ68svT5hwMPpOnTHiO2568P9oRy1PuPXm/1hHLk/eebfS0E54+gCe/1jliHUNYRwqsIwRWiHbe1YWm+xNbEm+859ZL7rw1oYd3UF4wrqt4MuXjUCo2k3Fb9B+/P5neDYi8iJ2Ge16Z+VM1boM7oUV4SaLDPftqG1zR3ZBPgt+YhnTUDRoKa74j1gJHrG2OWKsdsdqOWGscsRY6YnnKxCJHrCWOWJ4y4cmvxY5Ynvya54jlya8zHbE8ZXW5I9bB0I9zHbE8+eU5Di1zxPLkV7+OQ5788rT3nvLlaXM89dFTJjx9Jk/eH+2I5Sn3nrxf64jlyXvPNnraiX71v9Y5Yln4Yiz7N86rTyM6ag57R4AOlr8jAit0Y4lqY81hEqvi8ZSPwyTITsZt0X/8/nh61ytMwrtlbjpu718Li5Tc7SN3afHuKQwH4S40TEuSuAgall8VoLOhIp0Ngs6oKGftrsjH6J30hj+STG1zmfCS2r2m+GLtKxnOmthJHzrtgvXhs3fKrJj+4I5VdaHPjGSqvqFZ4ItA7810oy0weSd9rGnbc1HbcZPbpnb7xcgB4iqTGSOvZemgvHWy36Z/2I+s50VPOandqoyF/Y47pG+g/LhzV2GeBOmY/xVZf6U7e/9p+97f6gKoDtTnVcf1ruv5oq58muwS2IH+2gxT8dn6XcnBbZS2StBVmGw7i/bdBlGHEBb217GU3/piOCc/X/pl+R+EvuOd7lY+T35uy6kDyg/WIU9+3lZCft5xXO+6Ytljibbl3wjy8y6SHywfkh/ehYvyYzxSY++mZHIbio69WD40xp9HaaruoXEutEtb8UjReVpFOk8TdOoeH55GdG5wpKNOfaopwo3wG9OMDr9jOlj+jgCdTRXpbBJ0lK+B/niNF+wPxvQL4k/3BfvqxLeVbYu0mIuv1UlshbXKEesCwlJyc6PAKsqvGqad2yjfVeO6agMCt0X/8ftt9C5v2mnYSiXzrmBJkjiVxPLTrfqKzjkV6ZwTSWdLRTpbIulcXJHOxYJOjVepRE+dDX8/+0bQaMikIKbVZ19euvG3NHX2unTjr8mFxfZcQrhFo5pY3vIpOldXpHN1JJ1zKtI5J5LOlop0tkTSubYinWsj6Rxo/bOjIp0dkXQauZ5MJ1auL69I5/JIOqdXpHN6JJ3psqPTJQe3VKRzSySd6bJvjd2ZTOdgtTtNe/q7PdM1LhxofJuuca7Rn3Ltma7xtOmfpj1New7O9oS+J5/GgW49XtPEOBaWtWUZ3uLROalb7rbjJ7dxFZS/KJlMr+hSJpYPLWXyEiO2gZfqjxeYLUrD+h0fqB+WPz6nHNYnffhbTJYnfSpug4q+rIq3QZ1Qjl5wGxS2j5e3LhR1aYs05GEenYsEnRZh9aqX4zKSVfEYypf3EZaWwG3Rf/z+GHqXt4xk/zbRx25m0Ue2hFilRP+EHCz8yI0ySYOU/7zsIr/UrPxy1vcxd7vxB2M6SdRzYqy6GL7X3W5KLEN3u90g6qJ2DFwBvzEN6dwg6CishY5YSx2xVjhizXfEWumI1XbEmtun9VruiLXEEWudI9Z6R6xjHLE8+bXIEctTH9c4YnnKvact9OzHeY5Ynv3oab88+bXNEWuZI5Ynvzx1yNOf8OTXakesxq7uO7vqyfujHbE85d6T92sdsTx579lGTzux2BGrX/3Vxzli8QFXnKOvIjpqPnxhgA6W50+jY7lW9nemqF+BeftAi/CsnvgO8UeSqW0uEydQ/Fd8Uaf9rGxbpHFYregWVcTaSlgqhKpiGy0q36uNjiE6q+IJlO/KcV21GQK3Rf/xe47u5oXoDFtFp8+jNAw78QHBogdnsHzogM50HQTanz8/oeisqkhnVSSdyyvSuVzQGRB08OAhr2CkvzvZ7z2f+Dthcp3Og7QBUZYP4Vn+S07ollt4wmQeIH+OTCanHQlpZ1OdcSWGh4eN8L6OVRfDH6G6lB0eNhI9bh+azviPkbImIlcQFd+1kqmWrQU1w3er6N9HUrkyn/jdBGmKE/xxQmzTppxyyItEvJsh8m8krI2inNV9IFAeMbAcS0yL3ud94tcwBin/0ZlWpUdsv7+9mz+PFvKDF7Ss7nbUmPNwHSz/eqjDb23XmIM57WJt3kT/RkuwOYf+OWBlNp6g6SeCPrcv/c9G7+Gc+m6kOkx4IsADO26t1pGxPuod8gDL5v0b8x6RTG4L/lvJ4qmU/4Qebef+t/ynBfp/g6iD1St9mP9cB85zRE4dzhJ1EFZz653Pfn7OZ+vZN2Qrx73EPbFB4OQ9xo1UYk16mTusHUzH/q0kIG25hS0mXO3bd+zckdN2HhFW5dCckehnNNF1S5+ZSaWxMnpsNvyRREteJ4l6Wmw9jR63j6duG0Vd2iItT0t70Un71O4Gzvr0qp133pXXpbGDtjIWXD6hsi3xLn3wKmobqLdCHp7yqJkjvgtNeSyfonN+RTrnR9LZUJHOhkg6myrS2RRJZ1VFOqsEHcbKm0I8J/s9SPmfCoadv66J03vGTB8++K2iMatEeyx/r7tamJcYLeI7VBRt5CUPhHcUrOubRH4VTRoT9XtTwbpeOc113SrqWuOB6ughx/Cn+0B1sekgSixzBVHxXSuZ3HpM45GFb/m7aHzyv8tMB98MaYoTPB3ENr05pxxLNr+bIfK/ibDeJMpZ3QcC5REDy7HEqHLpv18lyoQ0IEaC04edmDc7Yt0nsEwz8Th9AU1ZFKuZhj9CdSmrmfcTPW4ft/0BUZe2SOM4/gOCzgOCjsK6wBHrQkeswxqsBqvBarD2cyy1dnofpeH4abMPNTvgGWrR9XMsb/kUncsr0rlc0Amt0/Nfo8PvmI6qs7UHx27mW9EbzrD8fdSe8yCtk/1OZ6u/e4KmiTNZLGs3aQ5S/hPhbMQfnJDfRuTznnaNT63zTKMBaQX8mrF0Nv3Z7V06aXn0cYbGu7h5+oM+3Muz30p/QseDDKNXH/x36oMLIU31gdVnkPKvhD74HPUBln9zouklPeixjAzn5L+Q6mf5/1wsI6j65d0aiPxAPr8+h95fiOiKkjujXVHuFim5Q31luYv1u2PllM/eoJxyxOY8gYVywBEbKz+c6D4wPL7p+Buiz2PlnPvV8n8rsl+d7InsV+QV96uKrKlxKCQH2F/Gk3Yytc+3EpaKamJfx/TreQKf+/UfA/2qNlRgPblfLf+PIvvVeFlHvyKvYvoV83O/qvEb+9V40k6mjpMbCUvZ6FCEVfUr9gHbaMv/fwP9qqLcITts+f+jD+ww8iqmX9VKQGy/sh3Gfn0GpYX2Kk6XjZ6Z+Q3Y5+zzs13Iq5/iW8XFPV6LflNONRaK8gmVbdG7hTlYhpO+w7Aqs9yam3eBPbN8QuUFy5WaYn2UibL2VDxqHL0owEeNzytHL3jUWJnUokeNiw6LNYhq+thqQUtUi8snhNUS7zBNieoJ8M5EVW2HxBF6Hs0UUIR4pqAsn/L8Lb95oHneheENUv4jhHowJtYBPSi21g+K/OgZ8zZmbMODlIbl7sihk3fpLo+Oln8ttDU0OhrtOkZH5BGPjg9B2oDIz/x+i8j/EOThqNJbII1VGnn8INHpZTpY/pWcqtm38sbPT/Lb22tWxvKFMvEApanZnJIFy1dHpATbw7IQ0qX0Yd6EZAd50056ywnq5QNEJ2SX0ickCxhdsGjYTMBGOp0k6lljdNTqs2Hj8Fqgz27COtmjhmp7N0J1KTtUDxA9bh8P1YOiLm2Rdin8xjSkMyjoKKwljljbHLGWOWLNdcRa44i10BHLk1+rHbE85WuRI9Z8RyxPmWg7YrUcsZY6YnnKxApHLE+ZWOCI5WlXPXXbU1b71a56yoSn/fLUIU+Z8OTXYkcsT34td8TylFXPejXj9r7jl6e/6mmjPX2AMx2xPO1Xv8qEp53o13HIcw7j2cZDHbEau3pg2C/PfrzMEcuTX/1qc/rVL5zniOWpj55jrWc/9qu/emuf1svTrq51xPK0E/1qoz3r5cn7frUTnj75wTCv9Ry3V/ZpvTzntZ796KmPnnMYz7ivJ5anTLAOtbJ/Y56T4PeJkI757QM2FdeKb+a1WMNA7KGS2C3CS5LJ9UwIf1TQs3qN5KR1kvDz05s+OfbR1137kRaVt7rwO96fMCzyqzVt49UhUL4Ar25UeziMtqUNQtoQpQ1BmtUh/bue6jdcsn4x/EP8tkjjU2mxfTEvmapHJke2L+bNkHY+0XmzoPNmQactyr85QGdTRTqbBB3GyvuwFd8XYvnXZXZB3Rei9sBsEvWz/KHTJ1gfxRs+2aROw8fYB6xXW9ThfKJzvyMd3Gt1G9F5wJGOOsWu9t1VpYP7qvg040OOdHCP1iqi8xZHOrgv8DSi81ZHOm+FPDdAufTfb4M09ZG0t4t6mC1+B7wvYIsHY9qB+CNUl4L0JvZ3vYPocft4f9fDoi5tkfYC+I1pSOdhQUdhneCIZX07lkzt63OIztsEnbcF6JwTSWdLRTpbBJ1RUa6qjijeGJ13ONJBndlCdB52pINy0CE673Sk807IcxLReZOoQ+oPbD+p+z79712QNkBl08dO4g9S/i9t7Za7OcM0GURbgXXE8uiPvV20g+k9g+Ys74YyBezRpLhzQli9ePdM4t3bIS2Gd5b/14F3zyLeYbtYt98Dae+gtPdC2sOUtgvSEAPTEmgDvmOZw/KWb1SU4/FqN7wv0F9DMbqB+CPJ1DaXGa92Ez1se/rw3O2RcvQGjd6jgt4uQW9uonmK9A3LdEzZ2XdTGtrGXZSG9uy9lIb6fSL8Rsy8NvFNZFg/lm+s332Uhj79/ZSGfjifh0Dfmc/iYJvZv7U2Dwmcwyjvuynv20TeQcL9uzO6ZV5/0mS8XQHafMmz5X0APlj8puw3j0dqDHmPqKulvVekpfhvz249Nj7uhnzYh3k6hu9C4/fuHKzBRM83+WYRy/8xGldK6vGtxhfUY7aB7yuJHWsDDX9U0LN6jYi0mFjYQ2t/NP/DN/3711pU3urC7zge8H6R/0qR33j1GJSvGgsz2ioW9j5KG4I0q4OKhb2/ZP1i+If4bZF/63g3X5G+aAs69yZ+WPc5Yj1QEsvifY9CedNpNV7k3QaDdEK3IqkbreqOW/EtlrsgrZP9Tm3xb5O/+gCkDYiybCMt/1/CePR75K+qcdmz/aGxAv0L9iV2QXkry7xU5XBcuTqiDqHx6mpRh1FRrqpsqDqr2zQ72e+0H/+UZOMRSBsQZV+b/R6k/H8AsvF5kg0cS6er/Y8QnUcc6WB7OtlvayvaG5Yb5ds/GqCD5R+l9ij/omx7VJ17yc3XSW7eB2kxcmP5HwG5+QbJDfan1VHJFI83is+PiLpw3Ydz8j+aU/dvwzoJ3x+g9Aj5zDbW8n8nsPaixj60fTG+lvIFFU/fT1hqDod85itLFE+x/e+g9lv+HwqeqrGP54WYtpvqXnQsx/J1jGWeMc0a5xtzYuqC+CPJ1H4uE3NRcq7spLX9/aIubZG2C37n6cf7BR2FdViD1WAdxFjKJj9KaSG/HG3EbqpfUT9pt6jDweaPHX5y9z3awaL+2IPgjx2ZYY5RHtX+vHqtpno9WrBelv9FUK+1VC/lVzAfkkT7IewLmqzn+S3vo/pZ/mOzOqlbZ7H8fTn0kB8qLsP0jgd6ofucjHbFO3zmqDt80GYMjSeT2vUYpIVsjOX/gMiPsT8e1z8AaY9QGvKY/VjlC6KMsB9r/BtOdP/w3WKW/ywhDyp+HVrDuDyi7iE/9nJBp+6Y1OVEJ88uXEh24R2QpuwC64HlvwPswsVkF/JiUnvaNd5Ns3x13HOF4wLrSC/b9PLst4qL8hdR1Djs2deKp6cnk9uj5ohqftoW5d8RaM/p1J48mXpyQZky/rJMXQ8y9UsRMqV0l/f2FNXdcyLp3FKRzi2CTt02gvf21OU73UJ03udIB3WxQ3Te70gHxy9el83Tg+eQHjwGaUoPXpH9HqT8/3F6t9zOgB7wGPsY4CUi/0k59J6f0bC4BY7xBeyw3NtjWL1498ICNiR9eG+P5f8m8O4lxDukzbqNfOK5jPKHxpKpvGIfWPlW+C60vs58w3LGX+uvD8L7Av0VvbfH8EeSSvIxEWf6INHDtqcPr0V/qBy9ib09Hxb0VD/MTTRPkb5h8d4ede+nso0foDS0Z49RGuo37+15oEebeN4fupcU9WJ3BJ3Q14d2Czqmo7YX5/Ogo2/LdFTtzb9mfHIa6oft40kxHg7MS7k9HjEOz/HTc4wMjYMV93VEx6QNfySZKsNlbEXsfJbtpNInTNsFv1l3Ymw1Yh3WYDVYBzGWGudC+6d4bEIbsZvqVzRmvlvUQdG5uiKdqwWduuchHJPGveqd7PeefSAR8xAsy7Ffy/8HME7/OY2xis+96vVlqtf7C9bL8r8f6vWVQL3Qt8rr492CHvNtOCf/+6l+lv9rgZg0ln80hx7yA/v/3hx634iMSRvtOmLSOE4PjSeT2hWKMacPx6TV/ADtDtsW9NU5Jo08fozo7BZ0UEY4Jm3Yw4nuH8PjvSXfD8Sk3yfKK1m5PKLu+C4Uk7Z8de8F45h0nl34F7ILag8Pls3bw/NWsAs/I7uQtxduT7vGu2mWb3+OSSsb43nGWsknx6SLyieW301p9ws6vWRq6BRdnzyZ4pi05X8FyNTMU/LbHzr3wjFpdTZffeNGxaRDdG6pSOcWQafus/kck65rvyjHpOuKfXeITl2xb45J5+nBoaQHvXwujklb/tWgB52AHuT5XBiT3i3aMYVeRqNi3ELGpA2rF+/WFLAh6cMxacs/E3i3voANQd+Cz1AgPzherXylFqUlSdx8D8sfbDFpNf/bn2LSaGd3UxraRo5JK59Z2SCOSRuNvDbxvF/Vj7EG4Z2KDbOubc30K9W1LdlvpedGO833OcqnxiDrA+RN0X5HvCTRcm34I8nUfioj1yreje3Li0NjWdX3r4bfmIZ0Ys+aPeyI1Q9+2JaKdLYIOtPth9XlH20hOgfa3oDdog6pjbmRfAkV69kNNNmXsPwfOq1bbgf5EqFzJGpvAObP2xtwG/lhJcfZqL0Beby7nXin4gMh3ln+NwDv7gzwjnU71tfivQE4XnPsSfkb+I5lDstbvlFRjserkn5KtB9m+CPJ1DaXGa8+RPSw7enDftiHy9Gb8MN+RdBT/YB+mPK9ECvkh4Xikx+kNLRn7KOF9gY80qNNIT/skRysWD/M8r+a7EZJv0naDY5pNf7a5LJ131kQs9e/8demlmvl/DU6/K7x13zolPHXHnPy144Fn+ND0+CvfbQP/LVfc/LX5gLvfqNA3Az5xP5a7F5OHgeLxs1UfOVgiZup8epAiZuhbfTay7m7R5ti4maxMS6mmefXbRufnG75/xzia1+guBnWC+9du/rUyfkaf21y2f0pvmb9qu7pY3+t6P2954g6KzpbKtLZIujUfQ8t+2vvdqSDOr+F6Bxo65y7RR1SG/PDiHXO3UCTfQ7L//HN3XI/DvhrMeucIX/N8v9sGtc583j3f5z8tYeAd78I8I51G8dGti/NOufep1nnzPfX0M5yfA1to9c657t7tIn9Nazfu3OwYv0wyz8/86kq3psq7YZhqTM5LP8l7wGP9tcMf4TqUlb+Vd+p80zsq2JZnuOlD8fXVAxW+YVqvsjxtSpYbGsRm/21oufIzxF1VnS2VKSzRdDxvMtLnb9kf60uv3AL0anLL+wQnUcc6Sg/p5fPcfyp3fdoi2N9Dst/MvgcJwXuvuZ4jpWP3Zdm+U8ju4vjRFW7a1i9zkqfQbzbDWnKpuXtS1sKvDubeIe0WbeRT2xfcExlX07tdW9RWpLEzUmxPPNNzUUq3hsd7a8Zvrrnu8x4FTqzkj7sr5WcP0z4a8pvVv2A/hryFOkbFvtraGf5rDTaRr57CO0Zx05Qv2O+gxA6j6ZkX8W48D5njnGpcWmmaGMdPpPhjyRT+V1GBlV8RY3XKgZpZVUfvhF+YxrSebego7Dud8Talf1u1iSnviuyJnmg+Uy7HOnsgjyx98vc7TTu/+6p3XLPpXFffYeG6cXeL2P5X7gP5qrMuxcT78reL/Mu4N14wGdi3UY+sc+0G9LYZ/KcF2J55lsNazLRPtN0rMmE7pcp6aNN+EzKR1P9gD4T8hTpcxxZ2dmQzxSKf+2mtF2QFnO/DLYptCZpZdU3jk6kNPzGEd+Dht84wrXMt5Ov9SbI907CwG/bvYfS3gVp7wX8jWdPbts7RD1i5kIqdqTmSbvgN8qDsk2IO0j5HwXb9Amyd7HzCMsfuncF66Pmdo9FYIXuz+91JynTVrF7rkuS5OtajWflh9Q5YJx7DI13cfP6Sc2/QrxS/aTu7+CYN+pw6JuvoXkZ259dkIYxnk/kjMfYDrRBZm/UOI9jOY/zaowMyV5oPV/J3m7Rvpg95aj/bDdC6+3Yt7uo7mrPmNr7xnvGPkP+WR17xli+BxMt33nrsl8H2/bZHNs2VBDzzzKcXvdmWD9WtAWD/XyX827C2i2wVMyE9WxY5Ec8XjP+n9AHfDcG2iO+8wPtEceCYn0e04dUbn6es0cp/d2BfH8TEbdGm5MXt/53kOdv0jzCw27sojS0A4jBMhWSs9A9TzXePRc9j5iOu+dwfOB5REm7OTGPiF2bx3mEircilo0F023XkE8xdg3zm21RZ592J5PT0EawHUAbwfbj3QF6u6Ac+uI/z4m/YDtifZbdgHs36T/qF+u/2tdXdB/NrmRyOz4AdVE+D47ZmH8GrB8t2jwZU8lyyI9V577UvU5q78+HIrAeDdBWe1Q+FKCN9cKyTDtPJ5UuGm/qmG+gX8C6GLprK31ieBW6fwvPx32I0mJ1l/ft4PjOer0L0vDMBstnyM9PH9ZddaYA/YHQ95Y9fX5ex+51x7jhss9/OOjuCcQb5UeG9KfXfW08Z1JnWUNYuwO0e9kNpq3sBtclSfLH1hq/9TJU9716ileqn9rJVBvIZ1PVt8CV7nKMAXWX5yNqzFHyuVu0o8y4y/so3tcDl/kZitUgLaX/76c0db5S6T/bDZRRthuh80zsH3J+jhVY/nOzvqi4P1TGCngcx/0DSr55bmX5t4Ft25pj24YKYl6Y4fSKFTiN44N1j+O97CbrLfYNzx/VWIo8jflGqdrnzfHtK6EPQt92Yn8hZh6AdEP72lK52ZnVQ53p6UC+J5HslY1T3QvyfH3229NuhHxrxGCZCslZs69+/91XP912LRQD7cVXnrtjG1mf1bdzisw3FD20EeiL74yYb+wWuGrfLM43jqf5BuoX6z/qOOs/yjv7DWo+x+OGsmE8ZmP+l4ANu594o2Q55MeqO1twnsnnulHWfyUCKxRj/4jI/ysB2lgvLMu083RS6aLxpo75BvoFrIuhOEn6xPBK9VOb8iNviuouxxhC539Qtk3mlXz2WpNl3VVrzOgPTNeZOD6jiG1kG4S47PO/E3T3o8Qb5UeG9KdXrG03tUfF2kJYjwRo97IbTFvZDa5LkuSPrUp3jTd16C6Olay7IX8/fWJ4pfqpnUy1gR+mtNj9SRxjwHlG6HwezulYPtX6/254Fxp38Rzs/8m5DwZxQ7LXa22WZU/5zZ7jOtsN7Fu2G+wfcn6OFVj+P6BYAcpI1VgBj+Mfgjoo+ea5leX/C7Btf5Rj24YKYv5xZKzAaRwfrHsc72U3WW+xb3j+qMZSdTcd69lwouMUvDZl+b8YiBWU9RdU/C50Z0EqNz+mWAHqbgfyfcUpTvWvIM9fJX/Dw26EfGve66PGHCVnaj8KjqFczuxAxTsgo2MFhj+STG1zmVhB7Ny9ot2ciBUoP1z1A8YK1L2WiBWKFdRp10Ix0F585bk7trFMPEDZj9A+BrQR6Iv/OGK+sVvgKp8F5xs/pDs4UL9Y/1HHWf9V7FfNb9lv+BWoi/J5cMzG/L8AGzbntMmYSpZDfuyvivw4z3yM2oOy/qsRWKEY+0dF/l8N0MZ6YVmmnaeTSheNN3XMN9AvYF0MxUnSJ4ZXqp/alB95U1R3OcaA4zvrNcq2ybySz15rsqy7ao0Z/YHpup+a/TTl++4WdWXfdwnc2bieeOMd59tN7Ska5wvN13rF+Zh2E+ebnF/1U0ycL/au7JB+hu7KxnGX5dMrVsD3nyqbEJK9XvtpWPbUfhql/2w3isYDlKyz3eA70Dk/xwos/+asL8z/RBmpGiv4CNUR4xlKvnluZfkvA9t2Ro5tGyqIeXaG0ytWYP1Yh0+N+s62IGSD06eo3WS9VWN8i/6NWMhTjhUYj4YTHbPk+Lblvxj6IHQGgeOaaI9Cd/eH7oLFWMHtWT14rpP+7kC+K0j2VFwfbQ7LnuW/E+T5quy3p93gPU4qZhQac5ScqXVeHEO5nNmBinPp6FiB4Y8kU9tcJlYQ+32KinZzIlag5jiqHzBWoOYiiBWKFdRp10LrIb34ynN3bGPo3GRoDYPtx/sC9NBGoC9+O+m+spG7Ba7yWXC/wmMUK0D9Yv0vGg9Qc2v2Gz4CdVE+D47ZmP+5YMNeS7xRshzyY3vN13kdRs3XQ1ihOMXHRP6PBmhjvbAs087TSaWLxps65hvoF7AuhmI06RPDK9VPbcqPvCmqux+hNBUPULqLMbDX5ozb2A4Vr1T+AI75V9DYvb/ECh4E3X2siRVMoc31bGIFk9OmM1bwWE2xgtubWEHhWMFv7gexgj8D2/bbTrGC32tiBRNp+ypW8Cd9Eiv4XmSs4AtOsYJ/BHn+UhMrCD1NrIDoNbGCfRMr+F5NsYIb99NYwb+ADRs6fTJmEyvI18kmVlBMdz1iBSyfXrGCL9DYvRvyse6qewfqOIOAezLyziC0T++WO5J4430GIbT/MeYMwu4A7V5xitDeq+YMgu6nmDMIoW86qnNAVc4gsHzuFu1QZwrV/em7AXdNxBmEkOz1OoMQunckdAaB7Ya6d2BfnUE4LuuLij59rWcQLgTbdmKObSt6BuGUDKc5g7DvziBsgT4IxQo4zoH2yOMMws1ZPXqdQXgcyV7ZMwi3gjw/IfvtaTeaMwjNGYQ94NnfA/UMAtqI0NlljzMIN5PuKxsZ67PgGYRDA2cQQrFC1v/pPoPwLLBhLyPeNGcQ8nWyOYNQTHc9ziC8LGfcxnaUOYPwuJLzmBbVF/OjbSp6n1ro2yi8foDl7s+hk7df4RXZb76H6Q2RPrXTXTltJe+hu3K87ws3nijfiNfb1V3dveazQzSffTRQH1X/kHz1khf2IR8Vdazxrscx1bfYHu7bkG6kT9HvQnDsJNS3qBs8vqp9ELF+Au6D+JeT9/5WsQem+ViAJpfFtg0ncTFHy/9hMX8L8Xc3vCu6TyMUewnt03g0h06ev3MvtdXyfzzStjmtwc2pO3bYK8bLY3nID1dr9yG9LOMnf/nkybh1y1fsPiC05Xuwx7tpTrIwe1/LAttClIXQfgyWhZBdSp+QLOD66udJFlpZGsY+T4LfJ0I65v8mxT6RLwX659JRKJMABmIPlsRuEV6S6PgHzvUVvfQZEWmDEXXZ8JJ7jz38+UPHtai81YXfsXwNifxPF/mNV8NU904S9TxB6aDRtrRBSOP4COqR1SHVvfVUv6GS9YvhH+K3Rdph8LtIX8xLJssCyrvZNbxD7j5Km6590XgXdd6+6O9A7OH/0hzMe180349edF906Ftavfb3Me1mX/Tk/KqfYvZF3wdp/B232PhC7L5olk+v77i9MMIfCsleL38o5psESv/ZbvTTvuhDztj7t5/3RR+a1THt41lnaMyi+6LnZDjNvuh9ty96KfQBr3WiPap7X/QZWT167Ys+nGSv7L7os0Gej8x+e9qNZl90sy96D3j290DdF402ou590WeQ7isbGeuz4Lz9ORTDRP1i/e+nfdEXgA17EvGm2Redr5PNvuhiuuuxL/pJOeM2tqPMvmj2B2LnMS2qL+YPrXWG1uqQllrP5DV7LHdfDh20CRgHeUX2m/eu3RTpUzvtJZZrnZ7fPus1H+R5stpvpuTdaPaazz6Z5rNqrTO0VttrrZPl5R2i/mqt8z6o/x7s8W7avlrrVLpRdK0T50EcOwn1O/Ytrzt6xTYuJD/hUZEvZFcQl9f/1F5VzJ+3V/VlYv5Wd3+o9of2md+XQwdtG9pCXuu0/K+JtG1OscM5RfcQ9hrTin7Ljdczle+p5J/30iqbFSv/Vjbtq9VkC5WM707y21vX2Gl1rHGcm72vxzm2haFxDvWS40pqPIqVBSu7x+8iW4h9ZTIQOo/GMpFnC16b/Wa79wFhC0K8D9m9XrznWI6KOYdoo56w/2nlhxPdfl5rsvwfDcTtdkN5lg11RkH1YUinnPbJzS66T64Xbz11iuMcqFM8f/fSqa9nAVG1743H0JBNV3pmdPL8C8MbpPyfCvgXuA9M+bY8jlv+zwR0V/EytF7Ua+8px2hCe0+x7ruz3zX617Pr3ksYO962k6l2repewlj5Rxn605Mm4+4WuCFZCN3tlP7elf0eC9RDna8OzbUsXx2+JraHZUHpf+i+qV7z0F3ZbxXjYTlBW8R25gFBZxe8Y1nYJeiksvDbZAvfA/l4rvUeQRPf8foJln9PDhauj2J7XwnpmP8/aQ33vVCmgBzcynwxDMTeXRK7RXhJotdx0Pbl6dCISIvZs/XQ2h/N//BN//61kI7juxgdv1LkN16hjBfg1Y1K14222rO1m9JQX60Oas/WIyXrF8O/kB1Pn63j3XxF+kKNCa9M/LDuc8R6oCSW7UvbBeVNp8dEPS8mOvcJOvcF6ozlcbzhcq2cv0aH3zEdVWej805I62S/U1t8yJnd92ynB0RZtpGW/9Gt3XKzMszQHr8WYSeJ9gNsTFH98k7Cek8PrCsJC8vzWPHeHlhXERaWfy9h7eqB9UTCwvK7CGt3AAv7Z0yURzvGdTC5qjgODcfILuKPiDaU2U8Q4kv6mK6w/4Vl1Tya5VWNUco3U1jvdMR6jyPWex2xdmW/lY5dQnSU7r8zQAfLW75RUa6qHVV1VvObTvY7tXkbyI6+B9LUnDzP13wI7OgmsqPY59j+Pe0a76ZZvorzlkPUvAXt4tB4FzfPzqFsvS773U6m2qb7KQ37wDA8+1rx9NpkcnuKzj2w/HsC7bmW2pMnU+cUlCnjL8vUy0GmzouQKaW75yST61JUd8+JpLOjIp0dgk7dNuIcovNeRzqoPzuIzi5HOrsgT4fo7HaksxvynER08vTgWtIDFZvEsm/IfnNschXowXUBPcA6Ynnc+/0e0Q6md0NGo+J8Ve79xhh+iHfbC9iQ9OE9tZZ/GHh3M/EOabNuK79YxWt3URryin0dFR/DdyxzWJ75huWMv9ZfGCcr0F/Re2oNfySpJB8TPrCKA6rxytr3/nL0JvbUqhi06gfcU4s8Rfq4hz19lJ3lWCXaRl4z3wVpoXj3ifAb6eW1ieejSvZNd+ws6b+ct/dvqjsvyHRHjUnXjE9Ow7Oob0u6GC8m/UM+cPxUzWPxXSh+yvqKdC6pSOcSQafu8ZN9ebQLnex3yt/XkM3cBWkDoiz78pb/29Dvrw+MN9j+Pe0a76bV6cvvggxD411c1JE99Umm6hT78qhT7MureMYo5bV09dfqwO/2lS9/v6DDMRWWqXdGjMNYNs+X/zLI1HsCMsX3eGGd2ZfHPhgQ70K+fIjOjop0dgg6nnKj+rPx5ePpoM6zL5+nB78R4ctj2Txf/i7Qg09Mgy//+9Poy+fx7r8VsCHpk+fLXwO8+2QBG6Jihspf30Vp6PMhBqYlSXjfg4o1Wj61v8L4W9HXjfblDX8kmdrmMr78+4ketj192Jd/rBy9CV8+dl8d+vLKf0cs9uXRzvKYiraR97XtgjT283dDGvvy7+nRJvblVf0YaxDeKd+dde1rmX6luvZV8v1Rz412mu+GsybnU2OQ9cEueF+03xEvSbRc78p+jyRT+6mMXO8ietw+XqfZLeqi+v7V8BvTkM5uQUdhPeyI1Q9+2JaKdLYIOtPth+1ypLML8mwhOrsd6aAcdIjOI450cExkPyxvjvtz8iUehTQ1P2JfwvL/25ZuuX8PxCV43Lfy6Ie9V7SD6SWZbawYo5N+GPsTebybcdbktrwX0mJ4Z/m/BrwbyjAV71i3Y32t3ZSmzlW0KC1JwvuvQ3um1T5v429FPyXaDzP8kWRqm8uMV7ExTmvfB8rRm/DD1L521Q/ohynfC7FCfth7KW0XpPEZpd2QFjp7wH7Ye3u0KeSHvTcHK9YPs/yHkt3YBbhV7cau7Hfjr8X5a+njuT8R4+RVsRp/rUuH3zX+mg+dMv7ameRzlPXXXrClW+6cgM/h5a+d3wf+2oVO/tpTgHcXE+9CcTO1/hE6l6R8OR4Hi8bNVHzlYImbqfHqQImb7YI09sl2QxrHzUL+mkfcLDbGxTTz/Lpt45PTLf/NZ3Uxb6S4GdYL73r4QRNfO2Dia9av6qwB+2vqrpB3BOicE0lnS0U6WwSd0B79GNlSdBRvjM7DjnSwf7cQnV2OdHZBng7R2e1IB+Ut1l/7ZbJvap0z5HNY/v93brfcqwL+GtYRy8f6a5b/9eSv1bnOmce7Nzr5a397brfcfQHesW7j2PgwpTXrnHufZp0z319Te+iUbfRa53y4R5vYX8P6PZyDFeuHWf4Pkt0o6cdIu8H7A9VYNZPqWkY+EC9JtPwb/kgylX9l5F/tN8X2sb/2XlEXnuOlD8fXiu7PRDocX6uC1fhrXTr8roi/VtdZli1E592OdFCOOkSnrn12sf7aZ8nn2AVpMT6H5X/5ud1yfxaIEeWdEY7dl2b5v0R2dzeUqWp3DYvtLvPuyzlzeeQd2rS8fWk7zu2W+wrxDmmzbofOsO2CNP7eFvKK9/tYWpLEzUnVnsPQXKTiHRHR/prhqzs9yoxX6mxw6IxJyfnDhL+m/GbVD+ivIU+RvmGF/LWHKQ1t425KQ3u2i9JQv2P8NWxTjL9WNMZ1MPtM7xZ1UX34RviNaUjn3YKOwrrfEYvvqcc7CdhnKno3yTmRdLZUpLNF0Kn7DhT2mepa+9xCdOryzTpEpy7fLHYv/8jZ3fc4DhTdjz58brfcaIapxn2eh+CaQSLys89k+edlNKZjrprHuwXEu4chLYZ3lv/753TLLSbehb6th3zi9cqQP4W84thB0Xkhlo85A1hxTSbaZ9qV/a5zTUaNVxV9+AmfSfloqh/QZ9oFNJE+x5GVneX72kP7y9SdS8oGsc90f482he6J4j0wbxJ0LO3tkPYApb0L0gw/1buNpHfY/gez34NE+3yyQXiOuECfnzVKdAwDsUverXRWrL7kxUCwXuqep5g7BU/8u08vGrjl5g+1kqk2MRSrYbuK+a8R+Sv6wqers7voq6fPIKS9g9KGIM3qoO4ULOk7nx7DP8RXc6PN8LtIXyis+0ti2d19D0J5vlse9fuh7HfIB6yog9HzIMMfSabyoMy4ou5jVfsC2UZg2bZI47X+BwWdBwUdhfUmRyyzzaqfeR70JkHnTQE654g6KzpbKtLZIuiMinKtnL9Gh98xHcUbvivGgw7qzBai86AjHZSDDtF5yJHOQ5CH50H3iTrsuQ+HfHmMw6i5Mfvylv914MvfGvApsI5YHudB94t2ML3byQcpObbIeRDHqfJ49yziHe4Ri+Gd5b8DePecAO9Yt3FM4nEE+fEgpaGfwHeuFL2zDMvH3Flm/YX+ch3zIMMfSaa2ucx4pWJgaoy39r2nHL2JeZCaj6p+wHkQ8lSt1/A8CO0s33ui7gZS9ox9LtTvmHkQtonnQap+jS8U5wulD6+jV/Ff3pb4YYV8lMYXmkyn8YWSUnTK+ELvc/KFxmA8/8A0+EIf6QNf6KNOvtBPzu6W+zjxDmmzbiOfQt+uZF9IxZJblJYk4dinih0y32pYw4z2haZjDVONVxV9vQlfSJ3pUP2AvhDyVPlFIV/oPkpD28j+DtozjiWHfKH7erQp5AvxmiPGcznvm6G9mPdPQc9+dHY+rbckk9PeDGlvpbRY/UQM5C/aCsz/HGqD5f9SVu801viN7RpzRqJl1OyPin1aOyreW/gpdW8hjqVD45PrjONfyKey/G8R+VHm2Dd8C6SxP6fkMe9bWXvyjHfLWx3r4BfWIYZfmL8ov1jvkV9vJyzl/yIPQ/yyOtbBL6xDDL/UvodYfhkPFL/eRVi95jj8/UnDHk60TTC8Qcr/j2AT+PuTIRv/ZoGNtrFFGNiOY0U7RikNy+6JkR2/9/d0xXnY13w31IVlAXH5PuCfw7gx+5zJmL2+YcPypWIcGLfgdX8cx98bgXV/gPYukf+9AdpYLyzLtLmeeKZ0D63xbprxpqIdGFJ2AONVbAdUP6n9XCFeqX5SZ0F4DT025vRuSouNOZnMK/lU8ac8m836gPOZj+bsf0HckOyF9gAq2VMxVqX/bDfU/eNKl9huYN+y3eBYIufnOarlX5b1RZ132LB847cSUb7z9nJtgnn7yhzbNlQQ8/AMp9e34a0fK9qCQWULUN/ZFoRscPoUtZust7sgjdca1Lo58pR9AuPRsMiPeLzPbD30Qcgn4D09sTHw0LzP9CGVm0uzevQ6k3A8yR7aNDVXZNmz/FeAPJ+U/fa0Gw9Rmtp7FxpzQneYq71WSp7NDlTcDxkdSzH8kWRqm8vEUmLXeTzudEj/2y3oqX7AWIq6AwaxbCyYbruGfIqxa2qtKXTOT9kItgNoI9h+PBighzYCffFLSfeVjYz1WTB+/T6K8aB+sf6jjrP+o7yz34A8ZL9hF9RF+Tx8h4rlvxZs2G3EGyXLIT9W7S3dDXn4vPwuSHskAuudAdqPivyhs/pYLyzLtPN0Uumi8aaO+cYuzDDexc3rJ8wfwyvVT+o+z0coLVZ3///23gTOsqo6F9+3a7DLLrrAIcYJSjExGhAZEtFEu5tRBGxmRVC6ZRAFBBWCI5YjxkSaoRuaHm910zQ0TTOjKIl/Y54mMTGDyYsSfTEE40teJmNM4ks0/3e6zqr73e9+e519zj2nqsF7fr/+1em7115r7bXXWnvttYfTpjIc39muUbfxfoe3RcZtbIfK8ap4AMf8g2nsfrzkCi4H2716kCvooc18DnIF3WVzmSu4uqFcwdsHuYLSuYI1j4NcwR3g29bWlCtYP8gVzJbNV67g1j0kV/C7ibmCO2vKFfw+6PPdg1yB9wxyBURvkCuYn1zB7zaUKzjvcZor+Br4sL8Z5Ap6aMdscpArKGe7bSqrkiv4m4ZyBXc6Y7c3T/Xu/U65l4j7T90FgHiHCf6fwXaHlnbjTL23J9V++A4mZT8ernUO7VsE/FaHtrork3kJgk+r1+B3d6XtTiPAVAdvkc/MnhRZqX6aIHiUjTrTzzaP+bJpKsOxjfMP6o4kpZ9qTo9jMduuOrOs7tVQcYmne20B791fqPJUyv7Zb7ShjP0G6ij7Dexb9hvWn5grQPjYNxr2WTrzt8lvNLB+Y65gGnDE7kF+4dKZv1kfP22pxjlSEuczcjxFuQLrxyZiarR39gWeD86esn6T7Rb7hu+/U/NHlCnnCkxGo0HHEBxvGvzzl878VbkC9EccZ6A/alNZ6h0jmCs4eunMu7pndRLgXrS0u91tKGN/kT2xeyJfvbRT74D8vU6/wXcdoh9AHKxTnp6pHBOOoVzP/ECfdwEm5woM/1jobXOVXIGyvzb8xrmCin5zNlewTdBT/YC5ApQp0jdcXq6gSb/WBoAUv4bwPHfHNrI9o49oUxn6CPYfXm4CfcS0tSF0fITnI1NjFsxvj1GuoA1wbP9o4973uTluQBly3HAL8KJiHhyzEX750k69Ny/txql0eRp+47FLfWdxG8Bspvagrt+agKvt0FZ3wt/q0Ea+sC7TjtmkskWTTRPzDYwL2BZVP6n78D1ZqX6aIHiUTVnb5XvycXxnu0bdNp1X+tkOve1Q94mpeKANeC0eUPMBniu0oYztE+3aG7t5HR7bqPJ8hpdj/ouXdup9cGk3ThVHtuE31glPh5Af5Yu2JeDy8hRFfoNpK7/BvIQQH1uV7bbz35qwXRwr2Xa9eD97UmSl+mki9PrAbVSmxjJln5xjUGOrWhPAOR3rZ9FZVi/Ph+Mu31s+XYC3bH7baHn5bWX/Xn4rZVxXus5+g+NDhudcgcF/aunM3z6/xyJzBTyO433dSr95bmXwW5fO/M36+NqlGudISZw35HiKcgXWj03E1HWO40V+k+0W+6ZNuNoCF8qUcwUmo9Gg8xSGj/Pbm5bO/FW5AvRHVeOFNpWp70hkevOFpTPvnM/N3icBbtvS0NXuqnmq317aqXdb/l6n3/Bia16HG3zHqut5Qn7Haq79mpcDLZIrz92xje3QXYY+IpYPUP5jo0MPfQTG4uYjPB+5SeDlPTdYN8P7ZfouircmhzbO9o/6znGDms/xuKF8GOIdJvivLO3U+19Lu3EqXfbi2NsEPM4zp6k9qOu3JeDycuy3C/jbHNrIF9Zl2jGbVLZosmlivoFxAduilyfJnhRZqX6aIHiUTVnb5RwDju9s16jbpvNKP4vWZNl2pwWvGA+oPH8T36BEPriN7IMQL8f8/3tpp95/Lu3GqeJIz36Kcm08Z1K5Ng/XZod2kd9g2spvMC8hxMdWZbsmmyZsF8dKtl0v3s+eFFmpfpoIvT5wO5Wlfg+TcwxtKOP5yDSU4ZyO9bNov7U37uJeI/4mrVrD8HSvaG2WdU/Fzcr+2W94eTcVGyldnybeOT5keM4VGPzYspm/Fn+ijpTQdZkr4HH8VuBB6TfPrQx+v5zHrI/Hl2mcIyVxTuR4inIFNY3jw02P40V+k+0W+yZlHyfKlHMFJqPRoPMUvDZl8M+CPvByBRwvpH6fl2OQaSjDXMErcz44n5u9TwLc80j3quaploI+vyB/r9NvTFMZ+gHe66PGHKVnaj8KjqFcz/yA+RXUxSZyBbP+LPS2uUquIHXu3qffnM0VqDhc9QPmClCmSN9webmCJv2alwMtkivP3bGNbM9ePhF9BPuPtkNvGuphLP5Ksv2ivbpezILzjY9QrgDti+3fWzNTuV81v8X2od4oH4Z4hwn+WPBhbyDZKF324tgdAh7nmVupPajrOxJweTn2OwT8Doc28oV1mXbMJpUtmmyamG9gXMC26OVJsidFVqqfJggeZVPWdjnH0IYytutpKDOdV/pZtCbLtqvWmDEeULkC3vdTNh+gbJ7jNBX7bhK8cux7HtjulSSbuvN8KfN1D5c3XyvK8zHtQZ6vG171U0qez/t2YBvKPPtkm0fdxnGX9bOuXMExlCtQPsHTvaL9NKx7W0X7lP2z3yibD1C6zn7D+hNzBQjPuQKD/1jeFxZ/oo6U0HWZK7ideMR8htJvnlsZ/HrwbZ+I+LaRkjh/LcdTlCuwfmwipkZ7Z1/g+eDsKes32W7VGN+i/yMulCnnCkxGo0HnLDm/bfA3Qh9wrgD9Eec121DGOZBpQVf5I8wVPJTzwXOd7H0S4DaS7qm8Pvoc1j2Dfxj0uZ2/1+k3eI+Tyhmx/YTg65la58UxlOuZH+hzLp2cKzD8Y6G3zVVyBcr+1HynT785mytQcxzVD5grUHMRxOXlCpr0a956SJFcee6ObWR7Rh/hrWGw/5h26KGPwFj8IbJ95SNTYxbcr/DLlCtA+2L7L5sPUHNrjhtuB15UzINjNsJ/EXzY/yTZKF324tii+Tqvw6j5uofLy1PsFPB3OLSRL6zLtGM2qWzRZNPEfAPjArZFL0eTPSmyUv00QfAom7K2ezuVTUMZ2zXqNubAWD+9OD972HbVWRKMBx5vuYJvg+1+n2QzyBX08jnIFXSXzWWugPWzrlzBgkGuoHSuoHXEzN89OVfwjJzHrI+Hj9A4y+YKnpTjGeQK5i9X8BTog/nMFfxCzkdRruCZpHtVcwWHgz4/J38f5ArkM8gVEL1BrmB+cgW/QLZfV67gP3555v3xlitYAj7sFJLNIFcQt8lBrqCc7daRKzglMm5jO6rkCp5JY7d3f6G6d6CJMwi4X4PjLoM/G2z3UpJN3WcQvL1RKWcQvPsKivIUTHtwBqEbXvVTyhkEtF3OMahzQP2cQWD9rOueoN/45W68ReN52TMIKfdqKvtnv6HuHZivMwgfoFxBxZi+0TMIN4Bvm4r4tpGSOD+SmCuoKW84OIMQes8gXJOYK+A8B/qjOs4g3EO5ArTdSYBbQ7pX9QzC/aDPayneqMNvTFPZ4AxCMr3BGYTQv1+bqzMI3h1o6CPqOINwD9m+8pGpMQueQbiPcgWpuUK2/7k+g/A58GFfJdkMziDEbXJwBqGc7dZxBuGrkXEb24HjduoZhDUV5zEt4hfh2/Aby1/5HGwzz0/UfXHePalMJ7Zf4dfz92GC/0ZiTG20+9T3hUrfUUas72o+6OVBUs+kq9iI19vVXbtF89n1NJ9V+uJ9z7JIX6rev7cZ+N+Ne6pTVlPfPmlP7ts2lSk7a4Vee1Y5iNR7jT5ButDKy3C+fxi8HwrlCD965MxfiyFRLiX658RxqBMAB+Ieroi7RfhC0DE/xreKXvaMibLhBF4OuOrKA/d7z8hLW1TfeOHfWL9GBPyFAt5kNUq8T4ak53hlg0bbyoahjOcEaEfGQ2Z7Lyb+RirylyI/xD8hyvaF9zJ9sU/o1gXUd5Xf974l0mR+H7/7FMvv73Vkp97kkd04687v8zfW5jK/z7QH+f1ueNVPKfl975sfdef3WT9VXHw9/MZjoPqGYYZ3ZcP5fda91Py+d3fgfOf3X0Lj/Z6Y3z8KfNvBEd9WNr9/WI5nkN+fv/z+EugDzu97dxLWnd9/c85HUX7/GNK9qvn980Gfj8vf6/Qb01Q2yO8n0xvk90P/fm2u8vvencN15/ffTLavfGRqzIL5s9c5+X22/z0pv38x+LAPkmwG+f24TQ7y++Vst478/gcj4za2o0p+/5iK85gW8Yvw3lmlonwtz0/aUObla9dH6JTN738yMaY22k/k/H6bytQ3NIrms0toPqvOzHn5/baAR9tifUn9Fu964H837qlOWU3fRJT5/TYAcN9OQ1kda2WcO8E5kve9pjbRqSu3ccAvF+P1dME7b4ltWCz44FgD69k36Br8Bvio0gVsD+tCG8pS/KqnOygbNc6wnuA3+fjbD9cLOuo7muOhV6+sbqYLT6KYcS3A3RS6yzZAGa//4t3+fGel0g3WJRwfrgEYwztM8A9BzPj7NHa2Q+cZIt6zp2yfXUPtwb6YTsC11qFd5DuYdhvKsC7TZj6tnrItk00TMWOdtqVk1QYYk5Xys9NUdhOUraWy1DvyN1KZynsr/Vwr2nEN/Ma2e43gNcN70WHdeDcKvJ7uKb+Pdsy6t0G0T9k/+w3vO5yoo+w32lDGfsP6E3PUCM85aoN/hHLUqCMldF3mqGPr8ZijTvke+T+Db/tWxLeNlMT57cR42vqxiVxOGwDYF0xDWR0xF9st9s0GwrVB4FLfn2U7Gw06FjZ8wwT/f5wcNfqjNvHufd9znaCr/BHmqBcfNfM+HnptdxLg/iUyJ0XdQ5/Dumfw+xzVqfcDylHX4Tc43mxDGeJgnfL0bELUNzilz+YHzK+gLjaRozb8Y6G3zVVy1NNED9uePZyjrug3Z3PUWwW9tqCHOWqUKdI3XF6Oukm/hnJK8WtqT5aaD7A9o49gP4A+ok1l6xx66CMwFjcf4fnI1JhlA+BdmTsiZeNs/943udpQxnEDyjAlH6W+O8r5qJ8GH/bzJBuly/18f8j75vgtCbi8fQnbBPwtDm3kC+sy7ZhNNpjXGWk6Z6dkpfpJ3W3CeehU2+V1KRzf21SGuj2dvyv99OL87GHb3Sh4xXjAdOMcgHt56C67BMr2D938XCP4QfijCH5V/v/RCLzhGyb4w3JEGG8tJpjs/YAIPeQPf+MYAeuviuBCf4PtuzjC+yuAd4vXDee1gr8DBH8Gf52Ax9yS8aNkw/v1rxXtQV9/JbXH4JeK9ijfYDrVp2/YS/kGlBv7Bk9G2cMyVfk3lBXnIjAHuorKXg5l11IZ2s4lxMM5goej4De2a9Q7q5v1480vnXm3/n8bwO2Jdn1Kol2fFaGH/Hl2jfXL2vW7I7y/vqRdnyX425Ps+k2Jdm06NbDrYrt+m+Ah1a6tbtaPH39pN941UDYUem2d+9jgL3F09kbBK8qQ5XuTgL9R8L+YeMC6i0W9G6gM4y32O2uFHBCebdfgrwA5fMvRdeOrT10fV7qO+VzWdVyzS8n/rhPwGIuaTFQsuoZwrRG4sK85h2YyGg26DwzfMMFPCd9v/N0A9Tmnf1RJ3t8meB8PvTaDNnXyQTPvat3zGqK52qHJdZHOaATe8LHtflLIi30d2gHydeJUN06D/5TjD5QsL4HfWAeV/1gj2qVkeiOVrYYy0wVlnwbXxFiE7Wf79NqaPVV9pZpj8loy2gbrvxrzUvUfdWjpQd14V0OZ4T0C6r49fx8m+M0l9csbz4v0y/hROsT6hfX4vgTsF7bdm4QcEP4doVsOBr89cbwxvvrU52VKn1EHWZ/VOibCc1944xPKROVFVhMu5T+xr3m8Uf7zRoGf/ee9zniDcSGPldeX5P0Iwft46LUZtKlPvWTm3XQQY3+OKa93aHJd9BejEXjDN0zwDzvjjZpjoJzGCafBf97xB0YX24W+i3VQyf4G0S4lU28sMl1Q9mlwfdrnEco+sf1sn15bs4dlo3wr6q71/0To9Yc8v0HbuIHoqHluqv6jDr3/Jd14r4MypbMX5e/DBP/Hjn4pu8E8B8tQ6SPqCY83Sk5Kv1ZRGcr0SOJBjbsIzzlHg/9G4nhTkz4/Rekz6izrs6ef2VN27DeZTITe8YDzIyqPgH3N443JaDToPjB8HFs/5ow3mL9ZTbwfWZL3VHtDmzqNxhuc0/B449k410U6sfHG8LHt/qMz3lwDvKv8GI83Bv89xx8oWXrjTVE+yfhRMvXGItMFZZ8G16d9PlXZJ7af7dNra/ZU9ZVqDsN5OC+3qfLSqfqPOnQkjTeXEF7EhXrRIh5RH9FuFuXvnDMePnrmb2rOGNtWNmds/Hg5Y7UWYHJS+mhwferjGfOd++X5tpf7RTvm2PoSQSd1vm11Mx160Uu64XANsJX/tb0zB8LvJWS+oEX4jGf8DfGPES8l6c3uRzqQ6HH7rO8ym3lK/n7F5W+9+K2Xv+eES1eed+TKy951xcXnL0DUoXfFCqWCWPG3VuhuPZYN0W9PJrhjprr/bz07FOKPSczovgTKlCQMp1kltuklkXooiyB+WyDgDyRcB4p6xvuQUx9xYD3WmBb9jl5zXNAeJvj9wWv+zco43fHQK4dx+v+vCHoNWt0+PxlWtzdhNRiExWdv4Azhn0z/5x61PHaK1Q0Tzy/NtSjTvgPzd+v550Fd219rZc+HMrtTKsNxHuHYn3hQf5F3/I3Hrzo8Ba9PZs+pVO8lUO+sBB5eInhWa+wGNy7qVZXNhMOz0UFvMpm/Z331yqM7v2f/DoIy5Yl4/dTg7wYdWpq/myzRYo1HJWfca1VFzucIOk3L+Ryic1CNdA4CmEl4z/4dQrhYztZPJueDoewQqvcyKEM4HOUOgd9fJmgr/IajSAdPPlq3LaaDRmuY4NeADp5GOqhGUx59Q/B1nvVyNAJ/APFn8GfCaM3z+Nn7A4P2a7xOafBnO/OmcdEu5Su9dqFOcS7B4FeIdqk9IFZfjS2HUhmOLebDcWwZJhxvyX9fGHr7o0SUIM88xfhGOKO7fzW6yXMQwz8WemVYJRran+hx+6pFQyh9lgpixd9aobv1WFY0B3ntVPf/q8xBlBd4nsBpHkXF9VyPrZB/WyDg9ydcyoLYO6v6iAPrscaoetn/F4k6KRZQMT4fSrUAw1+XBRT1u+mqtf1AwcuEKHsyvGMZ0jlQ0FG4nk+4np/Ic9aHT83fc6s99fJL33l+braBnqJJx/4RNhaI+oHqsmlzYP880SQ0HR6sjHZsEDZ8wwT/UTFYefVDSFN77KImHL/hr0vtU1WIJ3FY1xvkW6G3D+dIVbPHRoSWYIvrB8LVEr9lj4olF1K9uVLjG5yYa6Gon8VOJ+3TTbsozua5nsGvdWJONTdQ2RWDf7mAx/mI8bOYeMC6i0U9nmfiPuWDiIdXhV45IDzvlTX4NsjBW0s2vprYK/sqABiZCl3twjWSIQHPfXGkgMd1IpOJWo89hHCp+Sn2NduByWg06D4wfMMEf4djBzhPfxXxflBJ3pUNq3kt2tTJNAdFmjyUHuzQVDprdGJ+IzZHfsCZg6rcD/LFc1CD/4zjD7w8RfawDir/cYhol5Lpy6gMcxKYD9qNe6oXZxN7ZbH9bJ9eW7Onqq9UZzMOojK0Ddb/gwSdVP1HHeLcIq5tG96FAq/B2/4P03GGme0vgv8K6OMD5BOeBzzg/mmsb+UhdMK7NcT7ZEh6ksM7wz9GvJSkNxvepe4jKjev52gHpYJY8bdW6G49lhVFcUdNdf+/yrxe7ZBaLXCqHdA3Ruqx5vJvCwT8GsK1RtQz3oec+ogD67HGsBXFdsrFrOibztoi0sUdLsyL/f8YQc+s7kaCDaFjdTdRmyZD0vP6VKsz/GPES1Wr804zZE81q+OzDEbldYTVYBAWn9cBZwjP03zuvbeKevyYxHhv+Q8gJ/83FA+hxnI8pPb1Kv+lpqC8hxnpvKBPOi8QdEyTx6CM10oXibZ66yJWdg2U7Utlq0S7eM+Qwnmdg/N6UZb13XuP6YZDb9SK/M2eIfEby3SN4FWdceQsmLK2mxw6WN/g1BmQftujeOYYA9uayddcpLVNnd/EurZfis9vrlkJ9XKciwkGeVRyZlssK+f9BZ2m5cw2dXONdPCMziS8Z//WEy6WM5/1xfOl66ke3tmGcBgR4H0o6r4ihd9wFOng047RbYvpoNEaJvj3ruzUe0ZFHeS7kLAPeDwsOuPLe1SNz9EIfKxd++ZtUbmGNaK+4p3n8Tc7vGePtyfA4JrW+YOITkx/Xkj6sw7KlP7YPs9hgj8X9OfFpD8YoTXRfs+u1dk7z65Zlqoe2ughCTysFzxPiPp45zjX61c3FM9FunE46Qbel6Z04+35+zDBnwC68UukG+g/+b5E5JljwLJyfoGg07ScOb7bWCMddTemyUbdg45ytn5Sd91tpnptKEM4HN/Ufc6IQ+FPHd9OOEa3LaaDRovv5T54ZafectJBrO/pIN9Bp+4db4Xevvb6oEV8j0bg+b5xgz9DjG+evaLesC83+DMBJ+eG1Z1tarbs6eIm0S4lU75bPvW+OKY9GnT7Y7qywpGp1R+JtIdlavDnOjJVMvJk2hbwm0W7Fos2twmXyrSpe0A9mWL7DR/L9G1OHHazqK9iB44hVRyG8Hz2T9mYik3Yxi5LjCE5tsHcAu+Vw9zCWirD3ALPxTC3sI7K1DlMlVvg8Q9zCxuoDHMLqPuWWximtn4g/73PHLzc07eGeBsD+Fbkbwhp4yn21ZOJTlN5E6ZzY410ENdRUzN/1ZztAHjHMqPDv3l3THpzw0V90lkk6DAu9MmTAMN7YA1+Fdj1vSu7cao7RBbBbzwnUN9tGBe4rM/MPtD3NbFGZfjHiJeS9Fqez1V3eVnb1wle1L1dsT5FOt4adCpfi3L62ZNn8Y86/81XvOWES98S6Bmm/x89pVl8NsHxkIldzHhb9I9/fzb9NiRgEfdcmZ6ic2CfdA4UdJpOQR5IdGLTkFtLpnovzt851bvfyk69251pSMwcUAe8LWpGL7YMPx7hbxe4xAfIJarjDhc7PK8FGkw3ez8swsN9FEJUdJEyhOAUJfIzRmUYEvBVSRh6DInfWOdWCzqMKzZ8mVw51PpsyeHLW0BHnqyuSv+yHBQd5XaVHDw6L+mTzksEHW84rupLFM8qxJ/M37M+/jL5kpuhTIUavIXL4Pda2an3e44vQR75/8ovx8avmC9h/TT4P3R8CYds2E7FM07NmK7yJQb/p+RLeIlmMqQ9ypfwkgHyczDxX3YsxPpzNRYeTHSaXo5TaXj2L2qZaJ1DRy11FdnjowlLIGq6zksgf7aiU+87CWN7yhJa076XcaWOQQb/DzWOQTcl8Dccem0qe38ptDmGK4jfDB7HP04r3Eywax3YmN/K3i/L35u2r8OJTkzvf1hS79+Vv7Pe/38rOvX+i/Qe0+fcXk6ZrxdtsP9vgHan4h2hutn7vgS7nvCirrx+KnS11/Ced2wH/1D+Pk60DL/6mz0pfYp8c58qf5rxs/DYzu/ZP5Wuxrrcpwa/HNq4KH9X6WROF9bRfvt9E/zOdHkpbTPBqk+7jlNZCP33kVrasv+3Q5x/Xm7eIOo1vWy4mehsrpEO4jpzqptOTHefS7rbhjKlu+/J3/mTki8A3Z0k3cX6rLvo63groEpjZfg/RjxPA5zJ6Q1TvXUNfgvBI47s4Vh8a/57LBa3usME/6KcT4zFrW1tQS9r289H2ob90Qb+txBtgz8O+uMl1B8oL+uPxaFXNmwDW4EXhj08IoNfBD4OPTZOi+2iLdq4e3vEsXG4wwUc41ggZGA4lF+weosFPbbdaaLRdmioz0YrGuyPUWZbgb7pxi0F5VtF24L4bYGAnw66vUHQ3lKAty3wKP++hco2ijL2XSH0+q7s4eM46jOJ6BOVvcRsQunVtMP7VuJ9WvDednhvCzroP7y4wf6fMta3xP+NvyvgN/axaskaYawuL1mfLnwm44xtrXhXBOfrASdvA2iHzmM4fxF+4yUPr5+Qn8UhbueKd/Ql/JsXywTBA/pCpbOxOI7loXhQ20iU3+RtJGprTqptYjy9cA+L/d9aU+x/x4pOvYsf57E/5373hNifPwE0iP1DuKqm2H9qRafehyrG/rxVpyj2tzKT7wJRj7enG73tEJN+gvAtAlqoN9n7vvCOujgs6mfvnB83+F+H8ehzK336yudze27J8S0MvTZSIt++zNNLw92uiDtFr5UtIj3jS33mfDiBly/e//ozr/jX9e9gfTde+LeUsf+VAr7Pz6K/Uh29N9qza8hQ1qayESgzHjJdezHxN12RvxT5If4JUfZeeC/TFwrXuhpxra2Ia5/QraNoh8oPc65D5UszH/BbBf5JjXHsHz5P/oGPO02GpOcwbzw33Jsr4k71D7ExFPkaE2Up/mGv7520/7Efv+yoVuj1g0Pit5Qtwr8k4Pu0v5cq/9DOf1P+YTOVoX8wHpR/aFfkL0V+iF/lRNg/pPaFwrWuRlxrK+Iy/+DlyNE/cDykjjyif+D1kt+FGOe3ac7k5VxVvKNiMi5bL3BmtL8eiddG878nTXXKeL1JzTXt//gbxl9Yh9dPDf6PQTZfJf54PxXGfBy/qs+jZji/dmwcboMD58XDav3Ti5VT+4XHir+gsaLixRJy74bhymj9VP6ebwc99vzLT71w5TvPP+/U88995/mXDwEm5I4x2f+t1ViPH+OEd4JeT//nnUrr6P/rBZ4immpnwcvhnemm7Cx4ueBZ0XlVn3ReJeg0vavrVUQHdwpM5u+ZFn+XZrBqVxfuFjh5auYve8s739Sp93c0g1W7UNTuiSNCNy9ldx9hfW+3ypF90jlS0Gl6l9OR1B7sa5ZbWf3E+qyfMb354bGaZqreGPy5oDf/5ehNbJcutrHsQQfW+RiukwkX1vcuD7gpgY53AD/1koKU9nh05rM9hkvtmMM+4I9mqEsUDNf6AlynEC51oF7pIPO8qICOt9tpkUNnXZ901iXSmav2rO6TzupEOkf0SecIQWdc1OvXryuei/zt81/d+R31NOZvefe1wZ8M/vZncpxq19sTXc5NrXpNEp1Yfx5M/alWvbz+NPiXQ38eltCfSjaxXV1I1+trdYFFS+DydkKzHBBejSkNZtKSPxfG2fSKqwazhxTbRI/bh4cBn5a/57O/Zee/6+BDDj/q/0393nPZ5bGs2t5INHSvQCJ8oP9zvYy3YYJZJGhkD+vPBoLjfrffGX8KT0WwReXK122KtDOENF+H9RdFcMV2r1v/cIbhmNzO1e51FZOpixG8eECtXCLckGjDkyP1Phg0f9Zm5Em12eBPdNq8rqDNHL+r2JF9E8MNiTYsDHrHOZ+wwbKjQjfvZfUJ68/V2HkU0YmNaWfSmKZ25mPdqfydd+b/LIxpZ9OYpmLBptvP8au65nYKYGJzm+EITl7lNvjz87b3ueokM4mcOR8T/Gftewv1qWq716cG/9PQp29L6FPPPryP1CtfsNaBV3NFlfvx4kbrH97hNxlSnta3U3QU8Y8RLyX1YTbeUBcTYfuqxhuG9y+hQch/UbzB9bx4g2FjtscxwHr6vSjeUDzFYPuJNzZE2hlC2viA9Q3O9LPiRe+TxstNwIfagRk76bcg9NqWglcxhlqdZ180HPQ4PAnlCH8VxBK/uXLmXfXF0RH+QkjrC6w/V2PV0URndY101C0TKr/KOlw2v471YzdKxHTwqvy9KFb5FI1rXv4a6XL++nfe2Kl3LY1r6jYTLz+WcqNG2UvEPXtLtR+WUWocY/A7KY6peDPGSbxaazgQd8UY6aQUm0D8anXY+BoTZSm7Z7Z87Re/uPTSs6/jMcp44d9Sci2nCPj+4pVwoto9gyv72TMMZeupbATKjAe1e6ZifHNiivwQv7oEFXf/l+mLCVHGp+FScdmOFzUnnS9fEctVmN/gsfZeZ96u1vDUjR7e7SAc43Mb2eeEENej/6bH8Jn8nyRo8eWLBvsQtPsLK7t5vVnwaj5iyKERxG+tEJcN01gg6n4odPO2LoE3lT9BHKsjfGY41Job623Z2zNuEvwoOsv7pLNc0PHGJP5rdPg3b/1uOdGJxTNfKbE+lL1/OH/n9aEHIZ75KsUzWJ/XKNVNX2o9nmUfOxHM/sTgvwZ2xafbVD71w8BXTM9STx8Y/NfnIC/DbRoOvb41e14zFWSbYn6aZaBiBlx38i6R3xDBFcvtcgxtbfuz4zv1/vLV5dp//JTG+eev6eB8tCTOEyI4v//qDs7vOLbxmtBNr+yta1ifdyqqy2MXhl7dLaGHyZdyGv6x0NvmKvknNZ9WclEXDPN6Jpal7Gt4jaDTIlxFfNV4Kaex+AyCY7eJzWS8LfrHvz+DflMpLMSdqfk7Tph5NzVfBTArCf8qwDEkfmM1x/oGp+js1yed/QQdD9dKgcvgrxXw+wn4GlXDWHwOwLBXZ9YYb5FqMO6YatgzRDSzd76fj7uGeVwscIw5bRoSv3FXjwla/JmAnzpu5u9CQX8odORa8FzN15AbDsRdMeN6dapH5uvSkZ7xpT7zmZKN+KeJA7925s8c/fstqm+88G9sKmp2d66A7zMr9FGVjcBdrNkzDGWrqWwEyowHlY2oeAX1R1Pkh/hVtpWzEWVn9ur+urK4LBuB1+6b7cyVLXu4vLtAjefRoFci2FcY/HNzX4GfUBgKcTkE8duC0OsnXjc183exwLUkaN4VbcOfPROivsE16KtGyvqqsdDb5qF0ei1Pb5Vc1Pkfq6t2QPMZ9bK76R8PuEw3+TMbVq7+Gh3+jeVcx4pTnadj6ry3UmWVXgbvWGa4+DfuF6y/jsquFXTU+HAdlaHczBeqXduHUbvQJtl/l/VDY4K/ors9jzxO08RshjoVwn77Mpj9H3NcvI0pO3UQPpYROp5iyiZ36sRkd2IJ2WWPnahg2Z0KsjvJkR2P/SpzrLJGfAIs9ilSLAvB36GiMqcp9/z0uRKWPPbVvXNH7ZJWPqbP+0yGjZ73aT6kt3fQMlV3DpmNKV/H/gx9Ha/a4bgW+xxm9n4ovMf8GbaJM5+Kv7nym4rOWX3SOUvQ8eLEFF1XdBTPRb7sUvJlavUR616Zv3M2dxn4sneSL8P6yCP/P2V+YfRSvzVg8FfC/IJXM1Sbr3R4Rhoh9NoNj10G/34auyrOc+XYxadJ1enYPukmZ68N/xjxUtUHF61eYyrwKfl7ngo84dKV5x258rJ3XXHx+XyDXGwPXYuw4m+t0N16LBui38YJ7tVT3f83rR0K8QetAr1sCGnr+Gpt29sfGMRvCwR8yp4A433IqY84YvsrhiL1sv9/QtSp83x4nTOaBvdUPTXVMg3/GPFS1TLV/hoVHambYbwbznHxBcuQjhedIq5VNeLad4BrgGuAa4BrHnB5e7B4FpY9fBYP/SCf/Sm70Iv1vQXl5X3SWS7ojIt6rchfo8O/MR3Fs8q2sNzKZiDV2cWi/WZfPk7TjO034xmawR8CM7TfO66bZzVDQxngDAj7YTeOqd66C40HKCsRXyzOZmlfXtmhw3Idmergzf55cUj2/uH8Xe0/5v0tqAupffRn1Edqf5y3J9Dgnw199HWaRatzg0wvFNBjOxyNwPOeQIP/llilU/zdFKEXyypcFKH3V0DvM6APu9s51alvtPvUu6cqvUM/w3qnMkHKn3n+Am2LdRF1mFdm1V43bx+o1R8Nug8M3zDB/73o81Q95341+H9K7FeTZRP9irLiflWr3ur8macHaoVeZequIVzXCFxqn2iqLRs+tq3/6/Sr+uIs8sn9avA/SuxXPC+5Gw+U9duvKCvuVxV/qP2Gnh7g+GAyUZn166kMfSJnrpX/Rj1I6XPsn5j/HsvHF+xzlcFPORse26f51Pw9z8Cdevml7zw/T8EFeryUWfb/tRE2niLqB6rbot+eQmXKfXqbd4z2aNApK3afs9e0CJF77jd7UrYgY3c3kcQ1/HVtQS5ya5wq8szMm8rMg6pmj2V3W4Itrh8IV0v8lj1qW7C6RSbFuylRqb1aCG/4eN16Uqg040QevFuoVOSu1vhU+/kGQax3U4QOjmioRjyiGfwLoa3eiFbTzEeOaCgjHtFUZsE7uarWs1W2dILgUfZqRIudpkE6KopRMyuMKnlmVXTjZMpJXeSV9Uvta1B7K7xZsME1MQvG9rAueH2bPbHbQxAe+5ujVtxbwJkntCU+raRmPam6gNmOL0fWqhGvNwNSNw/gEM6zcoM/WvgAw3lzQdtSZoDqlKpaweMTl1gP9xXsxj3VKcNbtHa3D8pK6ONedWZlsqesrbL/QT3jPd04Fnjfece1/0vneA8Wj9/qZko13vHNlG+ArNElr+nGqWzc6wO1/0jdrKe+97Y5Add1Du22gN/s0Ea+sC7TZj7xWze7aU11ykw2fdrKiLIV9M9sK54vzp4UWal+miB4lE3Z/WD8DcXU/WB4WpX1U8WLyocr28V9lyeS7aJ98my7bNZejUccE18BYwTfvlC0t/bDEZzvdsadojE1Jc72bq9G38dxtspKKt/HflH5a+VH2C+qb9chfOzbdR/J5dfnLbVyv1Xsm6F4ewOOZ7wH2OBvBt/98ddonCMlcf5q4pylJl833LSvKxqTeJ8q9k1svyHiUntR2c5Gg54vGT5ebVvtZNrQ37JPRX/LPnWtoOudNcj05tM5HxyvZe+TALeedE/Nl9HnsO4Z/GdBnzfl73X6Db6VR31zku0nBF/P1KqgwSl9Nj/Q557v5D3t/K24invo3dsoVc6gT785u6e9LeipfsA97WofO+KysWCu/ZqXiymSK58PwjayPaOPYD+QEpMperGY7NMNxWRHUkyG9sX2jzbO9q9uplRzgNh33ZUP4zEb4b8APuxPSTbt0HlScizTAr4NMDynV99g93B5ub4tAn7aod2GMqzLtGM26d1W18R8CuMCtsU2lA0J+BRZtQGG811boGyaylJtl+dhOL6zXaNum84r/SzKubDtqi/yYDxguoHLTW8M3TTV0g7+xuMs1jc4RWe/PunsJ+h4uN4ocBm8Wltp+DoSY3F/gMl+n3RYY7wt+se/M+4hAYuP6iaeXpftJrVZgXHhRVe2sTEr5+M+Bv9DmvqtojZOhqTnBu/YtuGueLz+hhbhC0GHf7EjY8iXOuqfcvXIn/zLhz5x1rnf+UaL6hsv/BubhUrBv0nA93n1yLVqaOHrRYahjNPhODx4V49UvJrh2hT5IX6VpuarR8oeM8QytJEyuPYJvUMYb/Bt2vZ5Kv1jkVqba14sjBk6vpcXb4hQH2ZUvHubqLldZTdRjyXSOadPOucIOk1v1j6H6MSOue59fOd31O9YSvbd+TtvhvwtuEDxqfm72pqAPKrxB8eu7GF75c2aDHNThL+fBv3kY66qze92eMbUVgi9foHTrrNX+eQ89OlTZdqVr+Fq4Jqd5B1S83XNTrljrrxtGKWCWPG3VuhuPZYVbYQ6Zqr7/1WOuarPGFwncHpXc6vRt8zlUYhXbRbgy+y80R5xqMU2w6HqZf//FVGnzgsE5urIrFlmxWOnyZ8L5M8DVIw6Zy3T27SRPd4xV04cYBnPdvo5Jra+Rlxra8Q1OO43wDXAteceJ1WXdPEGz+zhz4Kr4wYtKkP+vJkX1vcSgmf1SecsQWdc1Ks69k04PKsNfSy3shcNYn2+ACZ2VPG84zXN2BEungkZ/H0wE3rL8d08q5kQykDt7W/w+JfcuIhyHZnq4EU72M1P6O03O2LrHZ1RupDaR++kPio6ZsdHfg1+A/TRFTRb9Y5rFh0nvZLgrY2px0kN/r0wW/WOk14XoRe7cI8/4W3wVwG9OThOuo/SO/QzrHcq46L8mecv1NkYtcDEx9O8I4llj5qq42neUVOD/6TQBx6LWDdi/Cm51Xw8bXWEjb1F/UB1W/Tb3hFchif7DaevKcfT1AlUdhHXCZF7XZY9g+Npj7vjaZaVaQm2uH4gXC3xW/YUHU/jUcUTsRJV1YPN00KlPQ/rfbRYRQIqN+8dz1NRz3UROurAdfbwiGbwtyWOaDVFUnJEQxnxiJaaOTH4om3KbGre8RDv+uG6jqdxpKb0xTueVnQciPUr9TiQF1U/UY4D8fE07zgQDkd89bGKolJ1AWdP50XWmBAv6kJsjRZ9AA7hH87feb3lS8IHGM7VBW1L8Xcq662OCbC/U2vISh8Nrk99HFf6iO1nffTamj1lbdW7vIW3d+JYwGFkkd542y9xjW9vmvEhnVOJZtnPnJwq+Fd09uuTzn6CjofrVIHL6++Gt3AZi88GmOz3SYc1xtuif/w74x4SsPiobuKl37LdpNRZ0Rnrk86YoMNbNH5Yz/LzR1IWsiruxP9Ii/CFoGc5sVMIyJc6FZCy9euRh37pN5/6oT9d3KL6xgv/lnJ6/A0Cvs9TBFNqyOATnMNQtpHK0O0bD2rrV8VTHFMp8kP86mYF3vpV9uQKlnFmIBWXbf3yTqPPlS3Pbv0S263mihdF56w+6Zwl6NT5NZ8Jh+eiLVJjJ3R+Rz1I/RKAwd8C3zUed9IDseEcxzDvSwBGL/VLAAa/T86T2iJ1k2jzlQ7P+E1yppu9Hxbh4adyHvrcECG3SPG0EPnhFIvaaKNu1lcLTjc5dFb0SWeFoFPnJpUJh+c673xXC0ST+bs6FflmeMcyo8O/MR2s732ffVWfdFYJOipdg1OZBr8ONJzSL4i/ya8DqYV4a/smwYs6DcgpChVrbRJ0FK7xGnHxJiOlN28WuMrKq8YpmLF4BsGdOqVZGxJ4W/SPfz+DfotNwQy3Mkl2zXVcLT1Xpl+0nr3kBE0ztp7NHwk1+BtP7NQ7wvle9rGhm17ZnexY39sxz0MgZrw4G6au0G5RGfLnnfRQKwlDgo5yvz+JHwbiIR3rqiE65dKIYwWdsnzV6OaMxZ8P3U/sDjTrljJu7ufpt5ibs//PleorOsf3Sef4RDpz1Z6b+qRzk6Dj4Tpe4Bqodxdu1U2xK1ZDSOsmdZXCfI4gmJQoGuUvoVFefVbPG+UN/vYTOvUug3fea4C41oTuMpTjjcS/2unZ5znh5BHQ8I8RL1VHwNQdY+XODPGUAaWCWPE3z1J4dwpvHFpE9aqcGVKrZtcInCqOuzZSD2URxG8LBPwqwrVK1DPeh5z6iAPrsca06He0thsEbd4T+RFIh/3tyg58jBbKo2jfH8MwDwZ/tZOSWwV1VLvYmvmkPnqCwyP0N4CX+bUTNP0g6HP70HuORvhdRTwY/CqQAW/EU54/RH5DGWDd2P8RdmHobgv+X+niDQR/fUHbuf8N/kan/8cFD8ZX9rD8mQeGmd1lQPDrBA/Cax556WXviezB41iDvRz3EvfEuMATe0wamcaa9rJ02DqYjv1faUDW8qfl77Oh28XnXx7bf8gjwliE5oKgn/GgeQth/raUjlej524pxfZV3VIas9IiOn1uKY0N2spZcP1AdVvit+zJ1Plv863Q87l+sapPOipJxLhiYfE78nf+evS94KB4m9dNwAfjzB5OdnrbWg0PwhdtfWJZqm2KHm1vnW9DSV6LvnDAiTl1I1wqryfPMa83CV4bXFdJdp3zta5SbloTu2+9RVjxt1bobj2WsYfkqcKxU93/rzKtUas16r5a0xC148TTrCB+WyDgNxKu2H3NQxF6qkfVfZSGQ9XL/v9xUcezgBQNzp7YSl0duDYLXGaZbfi9hKU8PdUy2/n7GPFS1TLbRI/bx22fFrxMiDJOOUwLOtOCjsK1vkZca2vEte8A1wDXANcA1+Mclzpww3fZ4vjJV0c0fQWCorO8TzrLBR11lUAr8tfo8G9MR/Fs7VHfwmlRGbZns0MH62+m9uAux8n8PZut7nWiphn7nhbvEDX4q2Ebx94nxtuIct7drqlenpv4xlobAEamOnhj9tMGnj+cvyv74UNA2NeGo6gPnkV9UPWbZpdBHzyX+gDr4+6vmN0oeqwjsc+mriX+DP75OU/qagisvyFCD+WBcv61CL2fBXreQVqj3afePb3p+8ynBXwbYHj7C+opZ2zULnf1nYEW1R8Nug9iu/0PFn2equfcrwZ/WGK/1uRPnl72qhmVWfMOpLcFvPoW3UTo7fNYJhJxeZ9AVv2qrl7kfl3i9KvaJIB8cr8a/BGJ/WqybKJfvcOlql+9w6Vq/MZ+NZlMhN5xkq9rKdqfk9Kv2Afsow3+RKdfVZbb88MGf9Ie4IdRVin9qlYCUvuV/TD2K1/Rg2Md2/Jc+eizRZ9zzM9+IcZfbM9YjVf0bIyw8TRRP1DdFv32tAguw5P9hmlVFrk1dzToFCiL3ODPFSJXZqr2aqlDZfO127fiQVx3t69yqWV3+5YdFhtQ1eyx1YKWYIvrB8LVEr9hWdE1EN4VFzhCX0Jb8FCFeKagPJ+K/A1+Ov9/LLowfMMEf4UzCk0LHtrwG3vrLQJ+GmC8rzNvoTKstyFCB0dH9Pw8Ohr8+xNHR6PdxOiIMuLRcSuUDQl4lvctAn4rwHBW6RYoY5NGGW8hOkWug/Vf6amafbcFXu+6H08flX6pr4EtFvW8TInBNZEpwfawLni2lD0sG093UDYToVhP0C6niY7nl7LH0wXMLuxFWRPUP87Olb2wF+sbnKKzqk86qwQdxpW6T8XgNwsfZTjVKrC3P8L7Uizyo2SDd0Qw7Vbkr9Hh32L3LWBf1bly7EXU3qpyVTroZ9YTnXaNdNoAw1n06RrpoM2PE50tNdJB/8Tn1LfWSAd93c1Qj8dEdUvnNsGHTQFuhd9LjAXJ560N/xjxUpLe7BTgVqLH7eMpwHbBy4Qoey+8YxnS2S7oKFzX1YjL+nZx6O3rJURHxVK3OHSWJNJZ1iedZYLOuKjXr40o2RidW2ukgzazjOhsr5EO6sEk0bmtRjq3AcxhRCf2tfA/pzj4dijjLFf28NfCDf5ouCvmEYqn0Fcgj1gf713ZJtrB9P4yp2H+bwfUKeGP5L0rhqtIdn9FstsGZSmyM/ifA9k9RrLDdrFt3wFlt1LZTijbTmV3QhniwLIAbcDfWOewvsGNi3o8Xu2C30v0V/KX1g3/WOhtc5XxahfRw7ZnD9+Rdlc1erNfWr9b0FP9gF9aR5kifcNlNqb87A4qQ994J5WhP9tJZWjfh8I74oy1iXfAIn+s38jfRipTO2cX0/+z981Upr6EvVi0eTp0HmzziMCzL8HuINhbBOww4X396VDntd347nRoH074DHbhazt1hvN3Ho/UGHKH4NXKdoqyDP/ik2feTY6oo9iHMRvD37zxe1cEFx42RL3gHS0G/zO5PPq047eYXNCO2QfeUxF3qg80/OOCnvE1JspS7pxc/XP/+JQd5/7n7OeG7yFe+DfOB9wr4E8W8Car+6B+CVm9WeXRjLa6c/IeKhuBMuNB3Tl5b0X+UuSH+CcE/JFTHbgyfTEh6PAHYfrBtbFGXJsr4rK7MO+G+mbTarzgeyHL3t+J9WN3vlq5+mt0+Dcvb8X3QmKsM5m/Z774wNd2fkeZYryKdWO7/o6D8eilOU5vXK6z/d5YgfEFxxLYLqvLslT1cFw5LYEHb7w6TfAwLur1qxuKZ841sm68inTjLihT61q/mr8PE/whoBvLSDdwLJ2r9t9FdO6qkQ62ZzJ/t7aiv2G9UbH93Q4drH83tUfFF1Xbo3gu0puTSG/ugbIUvTH4nwa9OZX0BvvTeFQ6xeONkvNdghfmfTQCf3eE9zNzftW6tbIjlDP7WIM/G3Dy2osa+9D3pcRaKhZUMr2XcKk5HMqZt8oomWL7b6X2G/y5QqZq7ON5IZbxnKDsWI71mxjL6sxpNjjf2CuFF8Q/Fnr7uUrORem58pPW9nsFLxOiDGOBmH3cK+goXPsOcA1w/QTjUj75birz4nL0Eeyvy8ZJXpzwkxKPrakpHhuDeGwtxWMqdijiaz3xdXdJvgz+X07r1NtEfKm4guUQgo5DOBY0XY/FLfcQfwa/VcQtir+NEXooD5WXYXrbRZyocl5Gu4lPxaHPGJkKXe26D8o8H2Pw9wt4zP3xuH4/lN1FZShjjmNVLIg6wnGsyW806P4xfKyv9zlxbOoaxvIE3r04drmg03ROajnRifmFh8kv3Aplyi+wHRj8X4Nf+HxiTmp3u6Y6ZQbXxP5KHBfYRop804fzd5UX9b5FxL65jr5WMn1F6G6PmiOq+emEqH+r055XUHtiOvWHJXWKT9Ya/B+DTv1Jgk4p2+W9PWVtd0kinQv6pHOBoNO0j+C9PU3FThcQnXtqpIO2OEl07q2RDo5fvC4bs4Pvkh3cB2XKDj6avw8T/DvBDv7OsQMeY+8DfEHAHxah90+0BotjfAk/LPf2GK4i2X2vhA/JHt7bY/Cng+z+lWSHtNm2UU48l1Hx0OLQKyuOgVVshb956+ssN6xn8rX+egB+b2Jvj+EfC33px2ye6QGih23PHl6LfrAavdm9PZ8W9FQ/7B20TJG+4eK9Pehn+UwF+sb7qQz92X1UhvbNe3s2F7TJu93O24ezK4GOdzvKLkHHbNT24iwDG90rD1zV3vzTp7rL0D5sH8/um1CWd7en6RxHneNnnWOkNw72ua8jOSdt+MdCrw5X8RWp81n2k8qesIxz0mV9NeLad4BrgOsnGJca57z9Uzw2oY9gf102Z75L8KDonNYnndMEnabnIZyTxr3qk/n77n0gyzu/ox/EWBrrcu7X4A+BcfooGmOVnIv4Opb4urckXwb/bODrNQ5fGFvF+niXoMdyG43A30v8GfzynCeVk1bxhNdP2P9XRuidCvS8nLTRbiInjeP0yFToapeXY84ezkmr+QH6HfYtGKvfRWUo4/uIjtpPhjrCOWnDPRp0/+AeaIQ/R+iDiv+tvtKV5Qm8e3vhlgs6Te8F45x0zC9cSH5B7eHBurE9POPgFy4ivxDbC7e7XVOdMoN7POekvTlLHWeslX5yTrqsfmJ93i+6SdAp0qn3Ldf8xHSKc9IG/39P7dS7yhlrvHMvnJMu+x3hJYl0LuiTzgWCTtNn8zkn3dR+Uc5JN5X7niQ6TeW+DyM6MTu4oWTMxTlpg18PdnBjhZgLc9K7RDt66OU0+sxbyJy04SqS3cYSPiR7OCdt8FeB7NolfAjGFndRGcqD89UqVmpRWQhp8z2s/5OWk1bzv8dTThr9LI+p6Bs5J61iZuWDOCe9q6BNPO9X/DGuYfhN5YbZ1h7K7SuztU9Tbhnt3Gjv/sj6Sd1wagyyPqi4xzb53g8+J3hXNXqzeu3tyc+eWB4a66q+vxresQzppJ41214jrj0hDlvWJ51lgs5cx2FNxUfLiM4TbW/ALsFD5mO+npCTQ//JsYTB7wexxF84c9yUvQF3iXYwvW9THFZxnE3aGxCT3aMJ+QFPdga/AGT3HUd2bNupsRbvDcDxmnNPKt7A31jnsL7BjYt6PF5VjFOS4zDDPxZ621xlvHqQ6GHbs4fjsE9Xozcbh31G0FP9gHGYir0QlxeHefnJB6gM/RnHaN7egLsK2uTFYXdFcKXGYQb/I/IbFeMm6Tc4pzWI17rrqjW3Ou8sSNnrP4jXeuu1In+NDv82iNfqoVMlXnvOSZ3fcQwqG69tPaVTb78cZ5Px2gtyGvMZr/0sya5qvPZxkN2LSHZe3gzlVHUvJ4+DZfNmKr/yk5I3U+PVEyVv1sRezjryZqk5LqYZi+vOmOouN/ijTurgPILyZsgX3rv2e4P82hMmv2b9uljg5nit7P29SwTPis6yPuksE3SavoeW47UdNdJBm19GdJ5o65yxmONc8m9qndOLOQz+hRBzXODEaynrnF68ZvAXUbzW5DpnTHaX1BSvPRlkd5kjO7ZtHBvZvwzWOWeewTpnPF5DP8v5NfSNda1z7ihoE8dryN+OCK7UOMzgP0F+o2IcI/3G7H46wQ/rf8V7wJPjNcM/RrxU1X/Vd+o8E8eqWJfneNnD+TWVg1VxoZovcn6tH1zsaxE3x2tlz5EvETwrOsv6pLNM0KnzLq+JEJdN03HhMqLTVFw4SXTuqpGOinOKYo7tFHOo+2m8mMPg7zi5U2+HkyPifA7f0c7wHK8Z/F3kdyve8Sb9Lt8fHTsrfU9kLp96VtrgrwHZ3U+yQ9ps2ygn9i84pnIsp/a6t6gshLQ5qdpz6M1F+rw3OjleM/zqnu8q45V3ZiV7OF6rOH+YjddU3Kz6AeM1lCnSN1wcr6Gf5bPS6Bv57iH0Z5w7QftO+Q6Cdx5N6b7KceF9zpzjUuPSQtHGJmImwz8WeuVdRQdVfkWN1yoHaXVVH34K3rEM6ewQdBSuTTXisrPBgzXJ3t/KrEk+0WKmO2ukg+fPU++X+duaxv2DYNz/exr31XdomF7q/TIG/715mKuy7L5Psqt6v8xTQHb/5sRMbNsoJ46ZMJbhmKnOeSHWZ7k1sCaTHDPNxZqMd79MxRhtNmZSMZrqB4yZ1N2WiMtbk/RiJi//xWuZaN8p98tgm7w1SaurvnF0KJXhN474HrSdUIZrmfaNI/W9uNsIxzYou4PKboeynYD/ltd1t+1WwUfKXEjljtQ8if1s0R2yvCfP4J8JvumAk7txps4jDN67dwX5UXO7+xJweffnF91JyrRV7p55CSFuaw2elR9R54Bx7jEy1cEb6yc1//JkpfppguBRNsrHeN989eZl7H9QtzHHw/qp5mjog/jb4mqOpsZ5NUZ6uuet5yvdU2etU/aUo/2z3/DW27179dWeMbX3jfeMvSLviyb3jLF+43fiUL9j67IngW97ZcS3jZTEuTTHU3RvhvVjn75geE++yzl2/g5xefc1m4xGBTzi4zXj46EP+G4M9Ed85wf6I84FpcY8Zg+Z3rydYgq03UmAO4V0T+Wt0efE8tbvAH0+PX+v029wDgP9AN87U/buI3XPU4N3zyXPI+bi7jl1V2CffnN2HpG6No/zCJVvRVw2Fsy1X/PuOimSq/mWidDbRrZn9BHsB9BHsP/Y4dBDH4Gx+NvJ9pWPTI1ZMHfzt5RHQPti+1f7+sruo4ndfah8GI/ZCP9u8GG/RrJRuuzFsercl7rXSe39eTAB190ObbVH5UGHNvKFdZl2zCaVLZpsmphvYFzAtujdtZU9KbLy7t/C83EPUlmq7fK+HRzf2a5Rt/HMxq9Fxm1sh8pvqHgAx/xTaOzGOIrXTeuI+Xkdu+iOcf5uisGvAdu9jWSj4kjPforua+M5kzrL6uHy8hRFfoNpK7/BvIQQH1sb/NbLSNP36ilZqX6aCL0+kM+mqm+BK9vlHAPaLs9H1Jij9LOucZf3UdxTgJfl6eVqkJayf76bVJ2vVPbPfgN1lP2Gd56J40OG51yBwT9IuYKK+0NlroDHcdw/oPSb51YG//vg2x6K+LaRkjgfTswV1DSODzc9jhf5TbZb7BueP6qxFGWa8o1Stc+b89tfdnIF6tsJZeYBSNfb17b7mxyUK1DnWDO4r9aUp/oH0Oc/pnijDr/hxdaDffXu84TcVz/Xfs3LgRbJlefu2Ea2Z/XtnDLzDUUPfQTG4n+XMN/YJfCqfbM439hOuQK0L7Z/tHG2f9R3jhvUfI7Hjdh3E3HMRvh/BR/2pFO6cSpd9uJYdWcLzjP5XDfq+mcScHk59ocE/Gcc2sgX1mXaMZtUtmiyaWK+gXEB26KXJ8meFFmpfpogeJRNWdvlHIN3/gd123Re6WfRmizbrlpjxnhgrs7E8RlFbCP7IMTLMf8+cK7vBSQbFUd69lOUa+M5k8q1ebjucmgX+Q2mrfwG8xJCfGxVtmuyacJ2caxk2/Xi/exJkZXqp4nQ6wM/TWWp+5M4x5B6Pg/ndKyfav0/ddy9C/BeErkPBvF6ule0Nsu6p+LmOsd19hvYt+w3OD5keM4VGPwheV9Y/Ik60m+ugMfxB4EHpd88tzL4V4Nv+4WIbxspifPwHE9RrqCmcXy46XG8yG+y3WLf8PxRjaXqbjq2s9Gg8xSxb7AcCX3AuYKq8YLK3yl/hLmCC3I+OJ+bvU8C3GtI96rmqd4K+nxi/l6n3/Bia97ro8YcpWdqPwqOoVzP/ECfd0Am5woM/1jobXOVXEHq3L1PvzmbK1BxuOoHzBWoey0Rl5craNKveTnQIrny3B3bWCUfoPyHt48BfQTG4hckzDdSYxacb5xLuQK0L7Z/tHG2f5X7VfNbjhs+A7yomAfHbIS/DHzYR0g2Spe9OPazAh7nmfdRe1DXP5uAy8uxf07Af9ahjXxhXaYds0lliyabJuYbGBewLXp5kuxJkZXqpwmCR9mUtV3OMeD4znaNum06r/SzaE2WbVetMWM8kLInsI77qTlOU7HvLsErx76fAtttN5znS5mve7i8+VpRno9pD/J83fCqn1LyfKl3ZXv26d2VjeNuu6FcAd9/qnyCp3tF+2lY99R+GmX/7DfK5gOUrrPf4DvQGZ5zBQa/i3IFqCP95goeIh4xn6H0m+dWBv/b4Nvuifi2kZI470/MFVg/NhFTo72zL/B8cPaU9Ztst2qMb9H/ERfKlHMFJqPRoHOWnN82+M87uQL0R5zXTL2737sLFnMFj1KuAG13EuC+RLqn8vroc1j3DP47oM+/S/FGHX6D9zipnJE35ig9U+u8OIZyPfMDfc6lk3MFhn8s9La5Sq4g9fsUffrN2VyBmuOofsBcgZqLIC4vV9CkX/PWQ4rkynN3bKN3btJbw2D/cY9DD30ExuKPku0rH5kas+B+hedQrgDti+2/bD5Aza05bngIeFExD47ZCP/34MP+m2SjdNmLY4vm67wOo+brHi4vT/GwgP+cQxv5wrpMO2aTyhZNNk3MNzAuYFv0cjTZkyIr1U8TBI+yKWu7D1GZygco28Uc2H9Hxm1sh8pXqngAx/wvPU5zBWOnduo959RunINcQS+fg1xBd9lc5gpYP+vKFTy6vBvvIFfQeY/lCl6c98WenCtYCr7twIhvK5sreGmOZ5ArmL9cwS9BH8xnruBNOR9FuYIjSPeq5gpWgj4fnb8PcgXyGeQKiN4gVzA/uYI3ke3XlSuwbxk/3nIFF4IPex/JZpAriNvkIFdQznbryBW8LzJuYzuq5AqOoLEbbZxtV9070MQZBNyTETuD8DGw3bUkm7rPIHj7H1POIHj3FRTlKby9V4MzCLqfUs4geN90VOeA+jmDwPqp7itQZwrV/el4X8FGyhUUjedlzyB49454ZxDYb6h7B+brDMKtlCuoGNM3egbhYfBtt0d8W9kzCDsTcwWDMwi9Mq3rDMKnE3MFnOdAf1THGYRHKFcQO4Pwm6R7Vc8gfAv0+QsUb9ThNwZnEAZnEHYjz/8+Uc8goI/wzi7XcQbhEbJ95SNTYxY8g3AD5QpSc4Vs/3N9BuEx8GH/TrIZnEGI2+TgDEI5263jDMK/R8ZtbEeVMwi/WXEe0yJ+Ed67R7DoPjXv2yjefWqbInRi+xU+mr/zPUwLTpv5O0d3gE3M933hPE9W8ZnSd74TOjaffR/NZ4vuEWP+Pf0q0heOIe8WPDZ41+Pi+f4uBOdOvL5F2+DxVe2DSI0TcB/EhRQn3OvQvM+hyXWxbaMhLedo8JNg7zZ/8+Tr5V6K9ml4uRdvn8bdETqxeOdKaqvBvzDRt9W0BrdX07nDohwvj+VeHK7W7j27rBInH5uwD6hO/UrdB4S+fDfuqU5ZTbqwaL51gX0h6oK3H4N1wfNL2ePpAq6vLiNdaOVlmPs8DN4PhXKEPz23aZtPo1xK9M+J41AnAA7EPVwRd4vwhaDzHzjXV/SyZ0yUDSfwcsBVVx6433tGXtqi+sYL/8b6NSLgLxTwJqtR4n0yJD3HKxs02lY2DGWcH0E7Mh4y23sx8TdSkb8U+SH+CVG2L7yX6Yt9QrcuoL6bX8M75DZS2Vzti8a7qGP7os8+rVPv0tO6cda9L5rvRy+7L9r7llbR/j6mPdgX3Q2v+illX/RGKOPvuNW9L5r1s67vuH3vtd14VTzk6V4d3yRQ9s9+Y0/aF/0BGu/3xH3RN4Bvm4r4trL7oj8yt3OXwb7o0DtXvkbMlZU/anpf9D05H0X7oteQ7lXdF30/6PPa/L1OvzHYFz3YF70bef73ibovGn1E0/ui7yHbVz4yNWbBeft385hF2Tjb/560L/pz4MO+SrIZ7IuO2+RgX3Q5261jX/RXI+M2tqPKvug1FecxLeIX4b21Tm+tDmmp9Uxes8d6GyN00CdgHoTXOg3+G4kxdU17iSea/vZZ0XyQ58lqv5nSd6NZNJ/9Q5rPqrVOb622aK2T9eVWwb9a69wI/O/GPdUpm6+1TmUbZdc6cR7EuROv37Fved2xrtzGwxQn3C3gPL+CeHn9T+1VRfjYXtV/d9Y6m+oP1X5vn/nGCB30begLea3T4H+c6Ntqyh3uNd/fcuP1TBV7Kv3nvbTKZ6XqP37DaD35wqL7judq7DQeGxznFs33OMe+0Bvn1NkXbzxK1QX8pvYa8oXe9zPVeTTWiZgv+NX8nf3ec0+f+Yu+wJO95/eKZM+5HJVz9mir754x7dGg289rTQb/Amg/5+3Uvh/vjILqQ8+matont6jsPrki2dZpU5znUOc36rapk8imsK94DPV8urIz9e1O5ef5250vE3rWIhpouygnHscN/hWO7SpZeutFRXtPOUfj7T2d472Ei5reS5g63k6EXr/W717CVP1HHXoVxRdq37KnC97dTtm7fWN+scOHOl/tzbUMrolYE9vDuqDs37tvqmgearJROR7WE/RF7Gc2Czp3wm+sC3cKOrvvXiJfeAfA8VzrDkETf+P1E6x/RwQXro9iez8G5Qh/Re7TbF1gJ9QpoQdvYbkYDsS9qyLuFuELQa/joO+L2dCYKEvZs7X65/7xKTvO/c9veDbuzSGUjZ8s4E1WqOMlZPVmZetGW+3Z4vEC7dV4UHu27qrIX4r8PD+ePUdOdeDK9IUaEz4W6sO1sUZcmyvisn1p6J/MphcLPo8jOhsFnY0Oz1gfxxuu14r8NTr8G9NRPBud26BsMn/PfPEHTu/8zn56SNRlH2nwz3xjp95UjtPb49ci3CHoOMDGFNUvtxGuOwpwnUy4sD6PFTsLcJ1KuLD+TsJ1ZwGuUwgX1r+TcHlxE/bPYlGffT/yUNM4NFp2HBoTbaiynyA1nuT4C+uqeTTrqxqjVGymcN1WI647asS1s0ZcHIdjm08gOsr2b3PoYH2DGxf1+vWjimc1v5nM3zOft4X86B1QpubksVjzyeBHt5EfxT7H9u9u11SnzOD6nLc8Sc1b0C+OTHXwxvwc6tYn8/eJ0OubNlEZ9oHhqLOvlUxfF7rbU3bugfXvcNrzOmpPTKceKKlTJl/Wqf84u1PvMwk6pWx3SejmpaztLkmkc36fdM4XdJr2EUuIzs4a6aD9nE907qyRDtriJNHZVSMdjCsOIzoxO/gDsgOVm8S6v56/c27yZrCDP3LsAHnE+rj3+w7RDqb3Z5Q3qDhflXu/MYfvye7PS/iQ7OE9tQb/fpDdIyQ7pM22reJila/luAFlxbGOyo+pfT0Toj7LDeuZfK2/ME/WxJ5awz8W+tKP2RhY5QHVeGXtu7cavdk9tSoHrfoB99SiTJE+7mHPHuVnOVeJvpHXzNGfefnuQ+Ed6cXaxPNRpftmO3aW9EKwnX/ObUeNSadPdZfhWdRbQgfH98n+UA6cP1XzWPzNy5+yvSKdE/qkc4Kg0/T4ybE8+oXJ/D2T74/JZ94JZUOiLsfyBn8m9HvrjJl3zy/OdSyP8cPIVAcv2shufkKvTXEsjzbFsbzKZ4wTrJWrv8YD/zZfsfwmQYdzKqxT+5yh+YntAY3F8seCTj3N0Sm+xwt55lge+2BI/ObF8h6d8/ukc76gU6feqP4cxPLpdLxYPmYHLyI7ULE81o3F8v/7rE69Axw7qCuWPzinMRexfEx2h5bwIdkTi+W/ArL7xRI+ROUMVbzOsTzGfLG9KyH4+x5UrtHg1P4Kk2+fsW5yLG/4x0Jvm6vE8mo/iMrBWvvuq0ZvNpZP3VeHsbyK3xEXx/LoZ3lMRd/I+9rQn3Gc78XydxS0iWN5xR/jwvtcVOzOtrY8t6/M1k7M35WdG+0M7s8ITo1B1gcom7L9jvhC0HrNewIq7n2Y1WsvR5w9vE6j9ieovr8a3rEM6aSuK2+vEdeeEIct65POMkFnruOwpuKjZUSnqfhokujcVSMdHBM5DovNcd9OsQSeBVDzI44lDP5iiCXeQbEE+goe93FPahDwHIcZ/K9QHFZxnJVxGMcTMdm9m2S3E8pSZGfwy0F273Nkx7adGmt5e/X5jJKKN9T+a2/PtNrnzeNVxTglOQ4z/GOht81VxqvUHKe17/5q9GbjMLWvXfUDxmEq9kJcXhy2k8rQN/IZpdSzBxyH7SxokxeH7YzgSo3DDP4G8hsV4ybpNzinNYjXuus2vT8R8+T94hrEax06/NsgXquHTpV47d6a4rV/fkOn3gNzEK99dg+I1x6uKV77Gsju8yXyZmr9wzuXpGI5HgfL5s1UfuUnJW+mxqsnSt4MfSPHZOjPOG/mxWt15M1Sc1xMMxbXnTHVXW7wj0B+7euUN0O+8K6HFa/rhhvEa911H0/5NetXddaA4zV1V8itDp0liXSW9UlnmaAzLuq1In+NDv/m7e3geG17jXSwf5cRnSfaOmcs5vhhwjqnF3MY/OUQc/yXE6+lrHN68drseJD7xrlY54zJbuh13W2pGq+9DmQ3muP09kypdc7tVDZY55x5Buuc8XhN7aFTvrGudc7tBW3ieA352x7BlRqHGfy+5DcqxjHSb/D+QDVWLSReq+gH4gtB67/hHwu98qui/2q/KbaP47Wdghee42UP59fK7s9EOpxf6wfXIF7r0OHfysRrTZ1lWUZ0dtRIB/VokujsrJGOinOKYo5XUszh7fnNHo45DP4/zuzUW0oxR8oZ4dR9aQZ/NPndiud2pd/l88Lo6ybz993fySLZqX1p6NNi+9L+AmT3GpId0mbb9s6w4ZjK39tCWfF+n7JzUrXn0JuL9HlHRHK8ZvjVnR5Vxqu7iB7bRU13dMzGaypuVv2A8RrKFOkbLi9e205l6Bv5nDj6M86doH2nxGvYppR4rWyO6yc5ZtoheFF9+Cl4xzKks0PQUbg21YiL76nHOwk4Zip7N8mSRDrL+qSzTNAZF/Vakb9Gh3/z7kDhmKmptc9lRKep2GyS6DQVm6Xu5f9gwrifsh/9/TDuf9gZ93kegmsGQcBzzGTwV8/hXDUmu18l2W2HshTZGfw5ILtfJ9l539ZDOfF6pRdPoaw4d1B2Xoj1U84A9rkmkxwzzcWajBqv+ozhZ2MmFaOpfsCYSd0ThLg4ZvK+Z+ftL1N3LikfxDHTpoI2efdE8R6YdYKOlW2Dss1UdjuUGf7M7m4hu8P2t/P3YaL9WfJBeI64RJ+/cpzoGA7EXfFupVem2kssB4J8qXueUu4UPPTRLz596ILzbm+FXp/o5WrYryL86QK+z1j4FeNGY6pTH2P17BmGslupbATKjAd1p2DF2PkVKfJD/GpudDi8l+kLhWtTRVx2d18b6vPd8mjf0/m7FwP2aYPJ8yDDPxZ6ZVBlXFH3sap9gewjsO6EKOO1/rag0xZ0FK51NeIy36z6medB6wSddQ6dJYJnRWdZn3SWCTrjol4r8tfo8G9MR8nG6GyukQ7azDKi066RThtgJonOdI10pgGG50EbBQ+778OhWB7zMGpuzLH8rJ+DWP5bTkyBPGJ9nAdtEu1geo9SDFJxbJHzIM5TxWT3GMkO94ilyM7g//r1nXrfdWTHto1jEo8jKI82lWGcwHeulL2zDOun3Flm/YXxchPzIMM/FnrbXGW8UjkwNcZb++6oRm92HqTmo6ofcB6EMlXrNTwPQj/L956ou4GUP+OYaxrKUuZB2CaeByn+BrFQWiyUPbyO3hZ02oKO6udbQn24vBhlEAt10xnEQqESHfRDqbHQs17f+R39e9lY6KMwnj83f28yFnp+TmM+Y6EXkOyqxkJvAdm9kGSHtNm2UU7etyvbVKZyyS0qC8HPfarcIcutgTXM5FhoLtYw1XjVZ6w3GwupMx2qHzAWQpmquMiLhTZSGfpGjnfaUMa55Gko41hoY0GbvFiI1xwxn8uwG0KnvQj7KrCz814fp7UldJdtgLKtVJZqn4gD5Yu+AuHfQW0w+KNzvrNc47dWapwLgtZR8z8q92ntWGh0oayE/n5B3VvYBoCRqW6ep6HMi6kMfouAR53j2HALlHE8p/Qx9q2s3TBTnfrt/Lcm5IU8pMgL4cvKi+0e5bWNcLUFLpShJy/jsQl5IQ8p8lL7HlLl1c7flbxuJ1xFcxz+/mQ7/300aJ9g+IYJfiX4BP7+pOfjNwjc6BtbhAPbMSbaMU5lWDfDu+SEmfe5yvNgv+GYqOIzxMv3Ab8dxo0PkWyKvmHD+qVyHJi34HV/HMd3JuDa5NAu+t4D00a++BwYr/ereEP5AZNNn35gRPkBzFexH1D9pPZzebJS/aTOgvAaemrOaQeVtaHMyzmZziv9VPmnmM9me8D5DM911DzB0z1vD6DSPZVjVfbPfkPdP65sqU1l2LfTxDvnEhme56gGv4rmqE3cYcP6jd9KRP2O7eXaBr7t+ohvGymJcw2MR9634a0f+/QFw8oXoL2zL/B8cPaU9Ztst9g3vNag1s1RphwTmIxGBTzi431m7cSYgPf0pObAvXmf2UOmN1/M+Sg6k7CddA99mporsu4Z/JdAn3fQHK8OvzFNZWrvnTfmeHeYq71WSp/ND/S5HzI5l2L4x0Jvm6vkUlLXeeq40yH7t0vQU/2AuRR1BwzisrFgrv0ayinFr6m1Ju+cn/IR7AfQR7D/aDv0pqEexuJfjOSgsR2pMQvmr59F9o/2xfaPNs72j/repjKUIbYP9Ub5MB6zEf4PwId9m2SjdNmLY+8S8OpuD3X+6q4EXLc5tL3vYiva6v4b5iWEuE0qWzTZNDHfqPo9juxJkZXqpwmCR9mUtV0+A9WGMrbraSjD+x2+HRm3sR0qx6viARzztztrSHtyruDvwHZ/NMgV9NBmPge5gu6yucwV/KihXMFjkbMyiHeQK+iGX5TvJdyTcwXPg/2Oi8/UOMvmCvbJ8QxyBfOXK3gO9MF85gqW5HwU5Qr2J92rmis4AvT5Z/P3Qa5APoNcAdEb5ArmJ1ewhGy/rlzBI7QH/fGSKzgOfNjZJJtBriBuk4NcQTnbrSNXcHZk3MZ2VMkV7O+M3d481bv3O+VeIu4/dRcA4h0m+AvAdt9DslH248WdRfbDdzAp+/FwbXdoqzt/7nZoI198Nybbsjrbrmy3pu/uSttF+2Tb9Xxm9qTISvXTBMGjbNSZfrZ5zJfxPUg4tnH+Qd2RpPRTzelxLGbbVWeW1b0aKi7xdK9ovuXdPcb3wXr5LbR/9huoo+w3sG/Zb6hvNCB87BsNV1OuoIlvNLB+Y64A9Tt2D/JG8G2fjPi2kZI4P5WYK7B+bCKmRntnX+D54Owp6zfZbrFvYt+7RFzqjjK2s9GgYwiONw1+rZMrQH/EcQb6I44lUu8YwVzB5yhXgLY7CXCbSfdUnI0+J3ZP5G+CPm+heKMOv8F3HaIf4PydGnOUnqkcE46hXM/8QJ93ASbnCgz/WOhtc5VcgbI/FUf36TdncwWpd2FjrkDdb4i4vFxBk37Nm58UyZXn7thGtmf0EewH0Eew//ByE+gjMBb/XCRHje1IjVkwv/1ByhWgfbH9o4173+fmuAFlyHHDPcCLinlwzEb4/wE+7OskG6XLXhyrvrOI967vpPagrt+XgMub/6o74e9zaCNfWJdpx2xS2aLJpon5BsYFbIuqn9R9+J6sVD9NEDzKpqzt8j35OL6zXaNu4zfSvh4Zt7EdOG6z7aqcLMYDaj7AcwW0a7bP1LGb1+HVd+AwX4E5Y4R/FGz3ByQbFUd69uPpEPKjfNG9Cbi8PEWR32Daym8wLyHEx1ZluyabJmwXx0q2XS/ez54UWal+mgi9PpC/BavGMmWfnGNQY6taE8A53Q8Sxt3UPB+Ou3xv+a4CvGXz20bLy28r+/fyWynjutJ19hscHzI85woMfugNM38t/qz4PRaZK+BxHO/rVvrNcyuDfyZ+9+cNGudISZxjOZ6iXEFN4/hw0+N4kd9ku8W+4fmjGktRppwrMBmNBp2nwG8hIPzToA84V4D+qGq84N3hjrmCl+V8cD43e58EuGeT7lXNU70C9Hnf/L1Ov+HF1rwON/iOVdfzhPyO1Vz7NS8HWiRXnrtjG9me0UfE8gHKf+xw6KGPwFj8ZWT73p5OxMt7brBuhveVlCvw1uTQxtn+Ud85blDzOR43lA/jMRvhl4EPO41ko3TZi2MfEPA4z9xF7UFdfyABl5djf1DAP+DQRr6wLtOO2aSyRZNNE/MNjAvYFr08SfakyEr10wTBo2zK2i7nGHB8Z7tG3TadV/pZtCbLtqvWmDEeUHn+Jr5BiXxwG9kHIV6O+d8EtvsOko2KIz37Kcq18ZxJ5do8XDsd2kV+g2krv8G8hBAfW5XtmmyasF0cK9l2vXg/e1JkpfppIvT6wPupLPV7mJxjSP0eJs7pWD+L9lt74y7uNeJv0qo1DE/3itZmWfdU3Kzsn/2Gl3dTsZHSdfYbHB8yPOcKDP6DlCtAHek3V8Dj+H3Ag9JvnlsZ/BrwbR+O+LaRkjg/lpgrqGkcH256HC/ym2y32Dcp+zhRppwrMBmNBp2n4LUpg782MVfA8QL6I+/7vByDoM1gruA+yhWg7U4C3E015akeBH1eR/FGHX7Di615r48ac5Seqf0oOIZyPfMD5ldQF5vIFRj+sdDb5iq5gtS5e59+czZXoOJw1Q+YK0CZIn3D5eUKmvRrXg60SK48d8c2sj17+UT0Eew/vH0M6CMwFr8vYb6RGrPgfOOHZ8y8Kxtn+/fWzFTuV81vOW54AHhRMQ+O2Qj/G+DD/ohko3TZi2M/LeBxnnk3tQd1/dMJuLwc+2cE/Kcd2sgX1mXaMZtUtmiyaWK+gXEB26KXJ8meFFmpfpogeJRNWdvlHAOO72zXqNum80o/i9Zk2XbVGjPGAypXwPt+yuYDlM1znKZi3zsErxz7PgK2+w8N5/lS5useLm++VpTnY9qDPF83vOqnlDyf9+3AVPtkm0fdxnH3HxrKFTx8Rjde5RM83SvaT8O6p/bTKPtnv1E2H6B0nf2G9SfmChCecwUG/5+UK0Ad6TdX8CDxiPkMpd88tzL4fc6a+Zv18Y8jvm2kJM5WjrMoV2D92ERMjfbOvsDzwdlT1m+y3aoxvkX/R1woU84VmIxGg85Zcn57dj0a+oBzBeiPOK+J/ohzIOo8nPJHmCs4KOeD5zrZ+yTAPfWs7narvD76HNY9gz8E9Pmn8vc6/QbvcVI5I2/MUXqm1nlxDOV6rfxvn3Pp5FyB4R8LvW2ukitQ9qfmO336zdlcgZrjqH7AXIGaiyAuL1fQpF/z1kOK5Mpzd2wj2zP6CG8Ng/3HLoce+giMxQ8i21c+MjVmwf0K91KuAO2L7b9sPkDNrTlueBB4UTEPjtkI/3LwYSeQbJQue3Fs0Xyd12HUfN3D5eUpHhLwn3FoI19Yl2nHbFLZosmmifkGxgVsi16OJntSZKX6aYLgUTZlbfdBKlP5AGW7mAM7ITJuYztUvlLFAzjmP5XG7sdLruAMsN23kmwGuYJePge5gu6yucwVsH7WlSt49yBXUDpXcGXeF3tyruBT4NveG/FtZXMFHxjkCmbL5itX8Ik9JFdwR2KuYFVNuYJdoM/XD3IF3jPIFRC9Qa5gfnIFdzSUK3j74zRX8AD4sN8Z5Ap6aMdscpArKGe7deQKfqehXMEqGru9+wuRNz4jWOcZBNyvETuD8Cdgu98h2dR9BsHbG5VyBsG7r6AoT8G0B2cQuuFVP6WcQUDb5RyDOgfUzxkE1s+67gk6lHIFReN5E/dqKvtnv6HuHZivMwjfp1xBxZi+0TMIY2fP/M36+N8ivq3sGYQfJuYKBmcQemVa1xmE4bxfi3IFnOdAf1THGYQX5nwUnUFYdHZ3u6ueQXgx6PPi/L1OvzE4gzA4g7Abef73iXoGwbsDDX1EHWcQXki2r3xkasyCZxBe5JxB8HKFbP9zfQbhYPBhR5FsBmcQ4jY5OINQznbrOINwVGTcxnZUOYPA8UDqPKZF/CK8d4+g8jnYZp6fqPviFot6myJ0YvsVfj1/53uYlkM8Nwd3gC2c7/vCeZ6s4jOl70azaD67D81nlb5437Ms0peq9+/tBP53457qlNXUt0/ak/vWuweN51J13Wv049O78bbyMpzvHwbvh0I5wr8/t1GLIVEuJfrnxHGoEwAH4h6uiLtF+ELQMT/Gt4pe9oyJsuEEXg646soD93vPyEtbVN944d9Yv0YE/IUC3mQ1SrxPhqTneGWDRtvKhqGM5wRoR8ZDZnsvJv5GKvKXIj/EPyHK9oX3Mn2xT+jWBdR3ld/nO8DmKr+P332K5fc/AvH2jRR31J3f52+szWV+n2kP8vvd8KqfUvL73jc/6s7v35gQF2+G33gMVN8wzPD+OY2Bdef3WfdS8/ve3YHznd+/hcb7PTG//1nwbdsjvq1sfn9H4lxkkN/vlWld+f0HnPy+dydh3fn9ryfm9x+uKb//F6DPn3fy+1X9xiC/P8jv70ae/32i5ve9O4frzu9/PSG/nxqzYP7sD/KYRdk42/+elN9/FHzYDwb5/R7aMZsc5PfL2W4d+f0fNJTff7jiPKZF/CK8d1apKF/L85PUfO1tETpl8/vhjTN/Bvl9/5uanN+PzWcfoPmsOjPn5feLvsXL+pL6Ld7bgP/duKc6ZQbXRH7f+yZi3WtlnDvBOZL3vaY7iU5duY0tpxfj9XTBO2+JbVgs+OBYA+vZN+iULtT0DfBRpQvYHtaFom/TsWw83UHZqHGG9QS/ybeT6GwWdNR3NMdDr15Z3UwXPkAx4zaAuyV0l90OZbz+i3f7852VSjdYl3B8WAcwhpe/VXzQGzv1jnhjN07VZ7fDb2X7bB21B/tiVwKubQ7tIt/BtNU4zLwEwafVU7ZlsmkiZqzTtpSsVD8pP7uLym6Bsm1UlnpH/g4qU3lvpZ/bRDvWwW9su+sErxnevzqxG+8OgdfTPeX30Y5Z924X7VP2z37D+w4n6ij7DeU32c4wR43wnKM2+JPyvrC8B+pICV2XOerYejzmqFG/Y98jvwB826kR3zZSEucZifG09eNcf4e67piL7Rb75nbCdbvAhTLluZbJaDToWNjwDRP8SugDzlGjP/K+lcXx4nZBV/kjzFF/NOdjPPTa7iTAXUi6hz6N/UX2sO4Z/NWgzxfl73X6DY430Q8gDtYpT88mRH0cQ7me+QHzK6iLTeSoDf9Y6G1zlRy1sj+1vtmn35zNURd9d17lqFGmSB/3MWTPXPs1lFOKX1N7stR8gO0ZfQT7AfQR7D+2O/TQR2As/lGyfeUjU2OW2wHvn+cxi7Jxtn+0ce/73Rw3lM1Hqe+Ocj7qGvBh0ySbur8/5H1z/J4EXN6+hKI7ipi2uqOIeQkhbpMN5nVGms7ZKVmpfpogeJRNWdvldSkc3708oOm80k8vzs8ett0dglcVD9ws8C4SeA1+HeAaIhzZ+4fz92GCv03EroZzg+BhDH7jPt0o4DcAjPGzOPT6sY1UhvVW5+9K3w2uT33fS+k7tof1fROUDQl4lo3KKeFecuvbCYJHOVnZaijDvB7iQXlnOjF2Qjc/6wU/2LesXxsA1xDhyN4/mr8PE/xnHf1S+nIT/MYy9GSO/Cgd4jNYWM/kq/TL4PrUr8VKv7A9rF+evmQPy6Yt4FGHrG8nCB7lZGVol0ZznPCgvDOd+Mqru+HQf7Uif41X/o3nCejH9iV+1tVIB9t9GNFZC2WT+fvu76KQ30aZDIm6V+XvwwT/9xADfY3mcVh/HdW3sv8JdvbtlfH67INRtouoDOWBPifWToT/aKSd3wQ+vwX2kD1od8ZXn3Y3oewOfV+KX0f4sn6dfTfa5FrCtVbgUvMAgzcZjQbdB4ZvmOC/6+RKcPxYT7yvLsm7Gk+UH7G6mS59Kvcji0PvGLOBaKoxTPXVhKi/PoJrgeAf7Zb7fSjo8ZDhTScwX6n88zDB/yv01V+v1DhDhIe1EZ5HI/CbiAeD/w+hL54fQP3fSDgN/j8B570lcU5FcP7YiTWUnWJ8W3Y85XgC5dimMuSdx8XNQJ9hP0L0sQz1nOkGh181prYdfnm8sbKnv2nm7+7YMn9fSPhK+uohr6/OFvym9tVap32My+rhebsUG0F57P0mjXOkJM6n5nhwTFexyqGA/+lEW/lI9NXsl9FnoB3+EcUkSH8R8W/jxLOBf29dxHD1N9a3vq3G+tUAMTLVwRuTDcKzT1DzYexHjrFxvHkpleE4y7HVakEndSy1ulmfveXV3XjXOXiz94uJj6IY7/L8nf3wi0W/ezL0ZF6UU+B1VOwPzikonZ1rfcT2sz56bc2esvNh1kc1fih95DjL05vs8fQR81JnUmyHvPLcY5PDT1HMPUbw7fz/oxF49vkGvwT0mOOeacGDN0/YIuCnBc+LiQesy7TV2dPsOXGquz0Gf3SiP64p57GP0n+UG+u/J6PsYZluFfAoK97ztRXK2lSG+j9NZSqP5Nlsqm1Y3awfDyZfXXd+jn21wZ/u+GrVNs9XN5Wf83x1k7q6p+bnUFdT83PPT4gFFjn8K31cJ/hXeSXud6x3RCjma53ga0LUxzwu12tF/hod/s3LDR5B7VnvtKdsjgLrr6f2rK+xPYrnolzn5TS3UD4H5xY8Dhn8NTBXujJ/93KdZXXqptDNp5fbyZ6Tp8Js+7On/lhQr6fOZSzI8R6OYym5PNQ9HNN2w0x16te0HiflhfbM8vL8U/akzCtU7kztF7+ZylDf1hGduvKiPzy2mP+bnfYW6QfnSPagtbN5H5tZF9pQlrJ2xv4S6Sh/yX2M/hX75ar8fZjgNzkxndIDT2+K5lrGj9INPrek8u8N+pA9Wm82UpnKB6bqjZfDwzHaxm8vd9UK3eMk6jPCx9Y91hGeFv3+ZPgd672P2swxEuN+P8FbO0cj8IaPY5EHnDn+hgIePkA8bCzgYQPxYPAPCR48+WePFxMuDL22WHYfKeIzfvA3xD8WtH5MhqSnxfIzekoPsodtWdmTWsPwfKCyc4VrUY24LG5QMewSolN2XoT11zl0lvVJZ5mg0/T8awnR2VgjHbSZZURnU410UA8mic7mGungeMR7Wm4WPGTjxDdonteGMhUz8NkEg3/eik69b9I8D30F8oj18fzRetEOpvdXtA45DXVK+CN5/shwFcnuryPrb6mymx2nVnTq/Y0jO7btNpTx+gfKg2N6zJsiDiwLoTfPmj2sc1jf4MZFPR6vtsLvZeaKKbaB+MdCb5urjFcq/9yG3/hcxy3V6M2e69gm6Kl+wHMdKFN1LtNsTPlZzhmgb9xCZejPpqkM7ftQeEcasTZZbLvY4U/FoRi7qXwL695cx0obqtFzYyWVHyobK/G+qD01VkI+OVYqm3PF+usdOsv6pLNM0Gk6tzuIldLpVImVnnVO53f0/2VjpW3ndOo9N39XeZOUWGmDaAfTe35OYz5jpReQ7NR6gic7g/8EyO6FjuzYtttQNoiVuvtwECt13mOxkoo3moyVNhS0iWMlxZ+Kd7JnMqQ9KbEUtq9E3z0vVTcNf12xlIpLVCxl7dtcjd5kpmtPzuthHHspvKt9SdhfdfWfys3MV/+tq0bP7T+Vs6qz/9C2yvSfss2XwzuWYXu8uBLrz1Vc+XKiExvjT6UxXq1p4RjPewYM/lwY48+gMT51X8Ba4Hl3m6c6ZTWt8w+VPW/k7SnOnrL7YXkfkbdurfZ6t0Jvn5Rdt8Zzp9+NrFu3AO9Voi7bNsJvFHwYPJ9xYRg+j2LwF+Y6lfXfAys1z7HzKLF12IsA51yfR0E5t6kM63nrsAbXp008T9lEGwDYJqahzIsVDb5oby3rPcayGwkX21f24Lo866fidV0fvHI/Yl9tIVwGi3qJ7WG9NPgPCL1U/d/Of2ui/711eCVTbx2+SKac7/L2CHvr8EV7btgn3ix4wDFxruaonDPYCrwMCV4N7zDBr4IxeAuN6zZfCiHNZtX8DOdcfE4Z52bbEnB5vvRWAb/NoY18YV2mzXxavQZtS+6Tw7k225bqJ4RPkZXqJ3XfCt/9mDpf3kplqfNl03mlnyrOSrVdzEtxzmpa4PV0L3Ws8s6BKPtnv6HGOGVL7Dewb9lvcB6E4TnXaPB3U64RdaSErstc463E4y3Ag9JvziEa/JfAt90X8W0jJXE+mDjOWj82cX8a2jv7As8HZ09Zv8l2i33TJlxtgQtlynG9yWhUwCM+PvP0BegDvusA/dEtxHtq/q5NZWoNIdObx3I++BxU9j4JcL9Duoc+jf1F9rDuGfx3QZ+/QvFGHX6D93aiH+A4VY05Ss9UfIZjKNczP2B+BXWxiZy44R8LvW2ukrdKzVH36Tdnc+LbBT3VD5gTR5kifcPl3Qs5Dfzvhp2qxr/yayinFL+m8uQTobeN7dBdhj6C/QD6CPYfmxx66CMwFn8sspaI7UiNWdqA91lk/2hfbP9o42z/qO8cN6AMOW64FXhRMQ+O2Qj/j+DDWiu6cSpd9uLY2wQ83v83Te1BXb8tAdcWh7a63/M2h7a6d5h5CSFuk8oWTTZNzDcwLmBbVP3kff9CyUr10wTBo2zK2u6tVIbjO9s16rbpvNLPorPMbLvTgleMB+Zq719duYJFKzr19l3RjXNPyxV4+fZBriDnJxT72DpzBan7EOvIFbB+qvW31HEX9/vyXuBpgbefOyOq5grYb+xJuYIDVsz83ZNzBUesmPmb9fFBKzTOsrmCQ3I8g1zB/OUKXrli5q/KFaA/ajpXsGLFzHtRruCoFaGr3VVzBeeu6NQ7Nn+v028McgWDXMFu5PnfJ2quAH1E07kC8xGej6ySK/gGnTVC+2L735NyBW9b0an3gRXdOAe5grhNDnIF5Wy3jlwB62dduQKOBxDOxqg3THV+470svMc7xofBm57E9lpZXc4NfGzFzF/ca6X2BRmurG1Xr9BtQz/RBv63EG2D37aiU++T+buKdfheCxXrhNDrlxn2cOLDYK9f0amzakWclunQuNPGDMfqFXG4wwUc41gQemVgONQ9eDy/bAueA+FcIGCZxmZRT9HYRDhRZujbVR5ClW8VbQvitwUCfjro9gZBe0sB3rbAo3yN56M4pm6H3vZWiQ2uyvdyKnuJ2YTSq2mH963E+7Tgve3w3hZ00H+o/ZF8loF1a6NoZ0v83/i7An5jH6vuYEcYq8v7U+9ZMfNX7U/F+6WHBF/viuC8H3Dy/tR26DyG8xfhNx6LvX5CftS+xmmqp+4QCuI31T9rCbZNfB4ueIr9f7PAE+PBO1/rnd+ra0/hW8k2MZ7hO+fXE+8Iy3el8NkM1m8+44v38AwJGNZvg//Sipm/Sr/VuUDk610RnL8LOFPuNv0F+I31u+j+NJ4bqfvTFO/oe/g31T+s3+yPDhc8xf6/QeCJ8aDWndS3BFLujlbfMVPfr8K7o394zMy7930w1hekqfbkqe+a8B1NxsMjK2b+qu9VqG+vYRv5TIvBfwtwNn1Puvdtn41OPey/hYLWpL38t/8YPrOFJ4W4DvJ+9e+s6NT5wkrNS4v5KXgaPMc42SJ8Iegc4eP0HON+dZxj5LNRLaCf2dE/rej8HrMxrPvO/J1t7AcrOvX+JYIzhP5806PHdONt6u5WZbveuR++MwP7JBaXonwRnu8PN/gfrZj5W/Q9r3ruAm19T+WUMEYcmQpd7WpD2ZCALxvHmkwmCJ77JaZfKtfLehP7TgF/i2dWprk81LoV3k3LZ11uLsl77A5gtkW0Dbbjur9renH+zna/D8iEx9a6v/vifdeU80jqjmFlLwbXxB2oc3nvNH/XVOmzOo9qNIu+a/pl8r3qvmXs29g39FC/kI+L8vdhgt/f0a+679bnu5nL3oPe4Hnnp8z3eWfr27L3dPM5efVtw0wnbiX9UuMk1n17/s7j5GGOvrRDvI3ZU3aMMn68XIvKqbIuTUMZzzO9vQbZ+zvyd95r8MsgBy9eaOe/9amfy8quB2+FspT1Om+PHMpkguC5X/D/iAv7mn1XO/99NOg+iH3X6FjoA+9MjJdjTuFd+V1lb2hTJzjzfI5Zve/TcF0ce0Yj8LH558lCXuzPYrnXSwinwZ/m+AM1pt4Iv7EOFt3RzrlXlY9U8wfvboB64vlwxHzf0c7jRxvK+Ixq2TvaU/Ufdehw0n8cz9cQTS+O5bpIJ6b/sTvSL3T0v2he/lbCafAXOfqvZOnpf1GM4MVI3r085m8ajM+Pnu/4nPXfi8/L5nlT9R916IUUb6n7k7Hu2/J3vj/5AyX1C+cNVWNQpUOe7+X8jIpduR9j4wzPUwz+YyAHL96q6ZsbT51vf85rb20o4zuOlP/07hZS/lONl+w/r4U+8PIznFu6uSTvqfaGNvU0Gm9w7svjzc0OTa6Ldh0bbwwfjw3rhLxaRCOWD+LxxuA3Ov5A+S5vvCmar3M+SN2zpeby3nzd4Pq0z6c1/V2tolwZjzfoD/l7OWW/q5Wq/6hDIdf//uT67t3wu3mZ6uAeEpCGf5jg78n7BO9Rs7/DCXz8+/T379p255/+Hp97yR7royf3gf//HPe+DSf90XU3NIX/5z5+/d3HfvNHRzaF/39c9NtvWLx3WNAU/oWt8Sv++7lvu78p/I/90vd++L4lQx9qCv8bFjz27Af2vX1zU/iP3v5773jmsseeXoR/cf4+OtUpRz+YPU/K/2/nthje8A0T/FdyG8ts8w/AB+7+TdDL4L7pwLUif3fjEL8NT3X/NjbVCz801QtvtJ881cujlS2CMvThu2Hy/6O8ENcYlCP8N/K2W58shDpWf0LQX0j0u/gWv+EYwriGxG8Gn/XPn5DfxLaXXUPPnlGqj78xbdONfuxi+XsvveyUP330kabs7q/2+bfjP/5bE99sCv95Kz9x25f+cPVXmsL/lYte+/DKYw7bqyn8B/6vpz1j7WMnrmkK/29cPHbwI9ufdGER/v8fGl6FuyDoDQA=",
      "debug_symbols": "VJ3LzizLbpzf5Yw96CSTZKZexQPDdwgQJMCXkV7ef5FJRnii/YXOWhmsC6Orq9i1/v0f/+2//5f/+z//0z//6//4t//9j3/6j//+j//yv/75X/7ln//nf/qXf/uv//n//PO//evf//ff//H7/k/cf/yT/od/nD/hf/9Z//in/fcfqf9o/Wf/45/O33+s/uP1n6j/nPrPzf/cX/1n1X+k/qP1n1rl1iq3Vrm1yq1Vbq2yfr/33/X+K++/+v6733/t/dfff+P997z/vvXWW2+99dZbb7311ltvvfXWW2+99dZbb7315K0nbz1568lbT9568taTt5689eStJ289fevpW0/fevrW07eevvX0radvPX3r6Vtvv/X2W2+/9fZbb7/19ltvv/X2W2+/9fZbz9569tazt5699eytZ289e+vZW8/eevbW87ee/623fh9Igzbshr81l37gDdFwGv7WXX9n74q/heX7W7EapEEbdoM1/K0s+4NoOA33wdcfYh+sBmn4av425+uTAmv4W1nXB9FwGu6Dr2cKVoM0aMNusIZe+fbKt1e+b2X5/Rq+lfUDadCG3WAN3hANp+E++BqqoFdevfLqlVevvHrl1SuvXnn1yqtXll5ZemXplaVXll5ZemXplaVXll756zH9O0zyNVnBapAGbdgN1uAN0XAaeuXdK+9eeffKu1fevfLulXevvHvl3SvvXtl6ZeuVrVe2Xtl6ZeuVrVe2Xtl6ZeuVvVf2Xtl7Ze+VvVf2Xtl7Ze+VvVf2Xjl65eiVo1eOXjl65eiVo1eOXjl65eiVT698euXTK59e+fTKp1c+vfLplU+vfHrl2yvfXvn2yrdXvr1y9uD5wBui4TTcAs0eTFgN0qANu8EavCEaTsPfyvuvqfXrwYLV8H1q+wfasBuswRui4TTcB18PFqyGXll6ZemVpVeWl0gq0XAaXiKp/hpWgzRow26whl5Ze2XtlbVX/npw3w9WgzRow26wBm+IhtNwH1ivbL2y9crWK1uv/PWg/T7whmg4DffB14MFq0EatGE39MreK3uv7L3y14MWf/D1YMFqkAZt2A3W4A3RcBp65dMrn1759MqnVz698umVT698euXTK59e+fbKt1e+vfLtlW+vfHvl2yvfXvn2yvetvH+/htUgDdqwG6zBG6LhNPTKq1devfLqlVevvHrl1SuvXnn1yqtXXr2y9MrSK0uvLL2y9MrSK0uvLL2y9MrSK2uvrL2y9sraK2uvrL2y9sraK2uvrL3y7pV3r7x75d0r715598q7V9698u6Vd69svbL1ytYrW69svbL1ytYrW69svbL1yt4re6/svbL3yt4re6/svbL3yt4rdw/u7sHdPbi7B3f34O4e3N2Du3twdw/u7sHdPbi7B3f34O4e3N2Du3twdw/u7sHdPbi7B3f34O4e3N2Du3twdw/u7sHdPbi7B3f34O4e3N2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi6B0/34OkePN2Dp3vwdA+e7sHTPXi+HvTfB9bgDX8r+/eY7+vBgvvg68GC1SAN2rAbrMEbeuXbK9+38v39GlaDNGjDbrAGb4iG09Arr1559cqrV1698uqVV6+8euXVK69eefXK0itLryy9svTK0itLryy9svTK0itLr6y9svbK2itrr6y9svbK2itrr6y9svbKu1fevfLulXevvHvl3SvvXnn3yrtX3r2y9crWK1uvbL2y9crWK1uvbL2y9crWK3uv7L2y98reK3uv7L2y98reK3uv7L1y9MrRK0evHL1y9MrRK0evHL1y9MrRK59e+fTKp1c+vfLplU+vfHrl7sHbPXi7B2/34O0evN2Dt3vwdg/e7sHbPXi7B2/34O0e/HvM/htaQzKkQ3vIhnwohs7QeKzxWOOxxmONxxqPNR5rPNZ4rPFY4yHjIeMh4yHjIeMh4yHjIeMh4yHjoeOh46HjoeOh46HjoeOh46HjoeOxx2OPxx6PPR57PPZ47PHY47HHY4+HjYeNh42HjYeNh42HjYeNh42HjYePh4+Hj4ePh4+Hj4ePh4+Hj4ePR4xHjEeMR4xHjEeMR4xHjEeMR4zHGY8zHmc8znic8TjjccbjjMcZjzMedzzueNzxuONxx+OOxx2POx53PKbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+nxNn6/p8zV9vqbP1/T5mj5f0+dr+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcps9l+lymz2X6XKbPZfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6XKfPdfpcp891+lynz3X6PAeX3JPWkAzp0B6yIR+KoTN0m9Z4rPFY47HGY43HGo81Hms81nis8ZDxkPGQ8ZDxkPGQ8ZDxkPGQ8ZDx0PHQ8dDx0PHQ8dDx0PHQ8dDx0PHY47HHY4/HHo89Hns89njs8djjscfDxsPGw8bDxsPGw8bDxsPGw8bDxsPHw8fDx8PHw8fDx8PHw8fDx8PHI8YjxiPGI8YjxiPGI8YjxiPGI8bjjMcZjzMeZzzOeJzxOONxxuOMxxmPOx53PO543PG443HH447HHY87Hrc9bPrcps9t+tymz236PCekvH6a4UMxdIZuU/Z50RqSIR3aQ+OxxmONxxqPNR4yHjIeMh4yHjIeMh4yHjIeMh4yHjoeOh46HjoeOh46HjoeOh46Hjoeezz2eOzx2OOxx2OPxx6PPR57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"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "external",
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1752556835457866331": {
            "error_kind": "string",
            "string": "No public functions"
          }
        }
      },
      "bytecode": "JwAABAEqAAABBRhSVSgKJhpbPAAAAQ==",
      "debug_symbols": "XY1bCoAgEEX3Mt+toK1EiI9RBkRl0iDEvWeRIH3ee+6jgkFVnKBg4wHrVkExeU9O+Khlphi6W9sCQ4rMiN2CiW97D0hN/C+dkkkqj5+0JeiJ5isNMk4TR42mMD5LL2t7uwE="
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Governance"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "members",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "proposals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "proposal_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "choice",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 32
                    }
                  }
                ],
                "kind": "struct",
                "path": "Governance::cast_vote_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Governance::cast_vote_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "name",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  },
                  {
                    "name": "symbol",
                    "type": {
                      "kind": "string",
                      "length": 31
                    }
                  }
                ],
                "kind": "struct",
                "path": "Governance::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Governance::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Governance::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Governance::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Governance::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Governance::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "114": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "115": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "117": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "118": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "119": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "138": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "143": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{\n        compute_note_hash_for_nullification_from_read_request, compute_note_hash_for_read_request,\n    },\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter, context)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification = compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        note_hash_for_read_request,\n    );\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullification\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "147": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { view_note::<Note>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let M: u32, PreprocessorArgs, FilterArgs>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N = M>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PreprocessorArgs>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PreprocessorArgs) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PreprocessorArgs,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let M: u32, PreprocessorArgs, FilterArgs>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N = M>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; M];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\npub unconstrained fn view_note<Note>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\")\n}\n\nunconstrained fn get_notes_internal<Note, let M: u32, PreprocessorArgs, FilterArgs>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N = M>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. note nonce, note hash,\n/// etc.).\npub unconstrained fn view_notes<Note, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, M>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N = M> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "150": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "153": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "158": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "162": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "167": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "168": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "172": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "174": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(utilityGetRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "175": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "185": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_note},\n    note_interface::{NoteHash, NoteType},\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::HasStorageSlot;\n\nmod test;\n\n/// # PrivateMutable\n///\n/// PrivateMutable is a private state variable type, which enables you to read, mutate,\n/// and write private state within the #[external(\"private\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PrivateMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PrivateMutable<YourNote, Context>`\n/// or:\n/// `your_mapping: Map<Field, PrivateMutable<YourNote, Context>>`\n///\n/// The 'current' value of a PrivateMutable state variable is represented as a\n/// _single_ note at any given time.\n///\n/// > More exactly, the 'current value' is the most recently inserted note that\n/// > has not yet been nullified.\n///\n/// This is conceptually similar to how a regular variable works in Ethereum:\n/// the state variable has exactly one value at any point in time. However, the\n/// underlying implementation differs significantly because of Aztec's private\n/// state model.\n///\n/// The PrivateMutable type operates over notes. A PrivateMutable state variable is\n/// initialized by inserting a very first note. Subsequently, the PrivateMutable\n/// can make changes to the state variable's value by nullifying the current note\n/// and inserting a replacement note.\n///\n/// The methods of PrivateMutable are:\n/// - `initialize`\n/// - `replace`\n/// - `initialize_or_replace`\n/// - `get_note`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example\n///\n/// A user's account nonce can be represented as a PrivateMutable<NonceNote>.\n/// The \"current value\" of the user's nonce is the value contained within the\n/// single not-yet-nullified note in this PrivateMutable.\n///\n/// When the nonce needs to be incremented, the current note gets nullified\n/// and a new note with the incremented nonce gets inserted. The new note then\n/// becomes the \"current value\" of the PrivateMutable state variable.\n///\n/// This is similar to how `uint256 nonce` would work in Solidity: there's always\n/// exactly one current value, and updating it overwrites the previous value.\n///\n/// ## When to choose PrivateMutable vs PrivateSet:\n///\n/// - Use PrivateMutable when you want exactly one note to represent the state\n///   variable's current value, similar to regular variables in Ethereum.\n/// - Use PrivateMutable when you want only the 'owner' of the private state to\n///   be able to make changes to it.\n/// - Use PrivateSet when you want multiple notes to collectively represent the\n///   state variable's current value (like a collection of token balance notes).\n/// - Use PrivateSet when you want to allow \"other people\" (beyond the owner) to\n///   insert notes into the state variable.\n///\n/// Only the 'owner' of a PrivateMutable state variable can mutate it, because\n/// every mutation requires nullifying the current note, and only the owner who\n/// knows the note's content can compute its nullifier.\n///\n/// ## Privacy\n///\n/// The methods of a PrivateMutable are only executable in a PrivateContext, and are\n/// designed to not leak anything about _which_ state variable was read/modified/\n/// initialized, to the outside world.\n///\n/// However, there is one important privacy consideration: the `initialize` method\n/// creates an \"initialization nullifier\" that can leak information about which\n/// storage slot was initialized. See the `initialize` method documentation for\n/// more details, and for a concrete example.\n///\n/// The design of the Note impacts the privacy of the state variable: the note\n/// should contain a `randomness` field so that, when hashed, the contents are\n/// private. The note's `compute_nullifier` method will also impact privacy when\n/// the note is nullified.\n///\n/// # Generic Parameters:\n///\n/// * `Note` - A single note of this type will represent the PrivateMutable's\n///            current value at the given storage_slot.\n/// * `Context` - The execution context (PrivateContext or UtilityContext).\n///\n/// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateMutable (and all other private state variables) needs just\n// one slot to be reserved, regardless of what it stores.\nimpl<T, Context> HasStorageSlot<1> for PrivateMutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    /// Initializes a new PrivateMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Every replacement note for this PrivateMutable\n    ///                    state variable will have the same `storage_slot`.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    /// Computes the nullifier that will be created when this PrivateMutable is first\n    /// initialized.\n    ///\n    /// This function is primarily used internally by the `initialize` and\n    /// `initialize_or_replace` methods, but may also be useful for contracts that\n    /// need to check if a PrivateMutable has been initialized.\n    ///\n    /// ## Returns\n    ///\n    /// * `Field` - The nullifier that will be emitted when this PrivateMutable is\n    ///             first initialized.\n    ///\n    /// ## Advanced\n    ///\n    /// The computation uses the Poseidon2 hash function with a specific generator\n    /// index to hash the storage slot, creating a deterministic nullifier based on\n    /// the storage location.\n    ///\n    /// Note: Subsequent nullifications via the `replace` method will NOT be leaky\n    /// if the underlying note's `compute_nullifier()` method is designed to ensure privacy\n    /// (e.g., by incorporating the note owner's nullifier secret key into the nullifier preimage).\n    ///\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash,\n{\n    /// Initializes a PrivateMutable state variable instance with its first note.\n    ///\n    /// This function creates the very first note for this state variable. It can\n    /// only be called once per PrivateMutable. Subsequent calls will fail because\n    /// the initialization nullifier will already exist.\n    ///\n    /// This is conceptually similar to setting an initial value for a variable in\n    /// Ethereum smart contracts, except that in Aztec the \"value\" is represented\n    /// as a private note.\n    ///\n    /// ## IMPORTANT PRIVACY CONSIDERATION\n    ///\n    /// This computation is leaky and can compromise privacy under certain\n    /// circumstances.\n    ///\n    /// When the initialization nullifier is emitted during this call, an observer\n    /// could perform a dictionary or rainbow attack to learn the storage slot and\n    /// contract address.\n    ///\n    /// For applications where revealing that a particular state variable has been\n    /// initialized is unacceptable, developers should consider alternative approaches\n    /// or avoid using PrivateMutable.\n    ///\n    /// This is especially dangerous for initial assignments to elements of a\n    /// `Map<AztecAddress, PrivateMutable>`, because the storage slot often identifies\n    /// a specific user. For example, `my_map.at(msg.sender).initialize(note)` will\n    /// leak:\n    /// - `msg.sender`;\n    /// - the fact that this map element was assigned for the first time;\n    /// - and the contract's address.\n    ///\n    /// See https://github.com/AztecProtocol/aztec-packages/issues/15568 for ideas to\n    /// improve this privacy footgun in future.\n    ///\n    /// ## Arguments\n    ///\n    /// * `note` - The initial note to store in this PrivateMutable. This note\n    ///            becomes the \"current value\" of the state variable.\n    ///\n    /// ## Returns\n    ///\n    /// * `NoteEmission<Note>` - A type-safe wrapper that requires you to decide\n    ///                          whether to encrypt and send the note to someone.\n    ///   You can call `.emit()` on it to encrypt and log the note, or `.discard()`\n    ///   to skip emission. See NoteEmission for more details.\n    ///\n    /// ## Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Inserts the provided note into the protocol's Note Hash Tree.\n    /// - Returns a NoteEmission type that allows the caller to decide how to encrypt\n    ///   and deliver the note to its intended recipient.\n    ///\n    /// The initialization nullifier is deterministically computed from the storage\n    /// slot and can leak privacy information (see `compute_initialization_nullifier`\n    /// documentation).\n    ///\n    pub fn initialize(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n\n    /// Reads the current note of a PrivateMutable state variable, nullifies it,\n    /// and inserts a new note produced by a user-provided function.\n    ///\n    /// This function implements a \"read-and-replace\" pattern for updating private state\n    /// in Aztec. It first retrieves the current note, then nullifies it (marking it as spent),\n    /// and finally inserts a `new_note` produced by the user-provided function `f`.\n    ///\n    /// This is conceptually similar to updating a variable in Ethereum smart contracts,\n    /// except that in Aztec we achieve this by consuming the old note and creating a\n    /// new one.\n    ///\n    /// This function can only be called after the PrivateMutable has been initialized.\n    /// If called on an uninitialized PrivateMutable, it will fail because there is\n    /// no current note to replace. If you don't know if the state variable has been\n    /// initialized already, you can use `initialize_or_replace` to handle both cases.\n    ///\n    /// ## Arguments\n    ///\n    /// * `f` - A function that takes the current `Note` and returns a new `Note` that\n    ///         will replace it and become the \"current value\".\n    ///\n    /// ## Returns\n    ///\n    /// * `NoteEmission<Note>` - A type-safe wrapper that requires you to decide\n    ///                          whether to encrypt and send the note to someone.\n    ///                          You can call `.emit()` on it to encrypt and log\n    ///                          the note, or `.discard()` to skip emission.\n    ///                          See NoteEmission documentation for more details.\n    ///\n    /// ## Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Retrieves the current note from the PXE via an oracle call\n    /// - Validates that the current note exists and belongs to this storage slot\n    /// - Computes the nullifier for the current note and pushes it to the context\n    /// - Calls the user-provided function `f` to produce a new note\n    /// - Inserts the resulting `new_note` into the Note Hash Tree using 'create_note'\n    /// - Returns a NoteEmission type for the `new_note`, that allows the caller to\n    ///   decide how to encrypt and deliver this note to its intended recipient.\n    ///\n    /// The nullification of the previous note ensures that it cannot be used again,\n    /// maintaining the invariant that a PrivateMutable has exactly one current note.\n    ///\n    pub fn replace<Env>(self, f: fn[Env](Note) -> Note) -> NoteEmission<Note>\n    where\n        Note: Packable,\n    {\n        let (prev_retrieved_note, note_hash_for_read_request): (RetrievedNote<Note>, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(\n            self.context,\n            prev_retrieved_note,\n            note_hash_for_read_request,\n        );\n\n        let new_note = f(prev_retrieved_note.note);\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n\n    /// Initializes the PrivateMutable if it's uninitialized, or replaces the current note\n    /// using a transform function.\n    ///\n    /// If uninitialized, `init_note` is used to initialize. If already initialized, the `transform_fn`\n    /// is passed to `replace`, which retrieves the current note, nullifies it, and inserts the transformed note.\n    ///\n    /// ## Arguments\n    ///\n    /// * `f` - A function that takes an `Option` with the current `Note` and returns the `Note` to insert. This allows\n    ///         you to transform the current note before it is reinserted. The `Option` is `none` if the state variable\n    ///         was not initialized.\n    ///\n    ///\n    /// ## Returns\n    ///\n    /// * `NoteEmission<Note>` - A type-safe wrapper that requires you to decide\n    ///                          whether to encrypt and send the note to someone.\n    ///                          You can call `.emit()` on it to encrypt and log\n    ///                          the note, or `.discard()` to skip emission.\n    ///                          See NoteEmission documentation for more details.\n    ///\n    pub fn initialize_or_replace<Env>(self, f: fn[Env](Option<Note>) -> Note) -> NoteEmission<Note>\n    where\n        Note: Packable,\n    {\n        // Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        // by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        // a non-inclusion proof would only be valid if done in public.\n        // Ultimately, this is not an issue given that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        //    to produce an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        // oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        // a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        let emission_content = if !is_initialized {\n            self.initialize(f(Option::none())).content\n        } else {\n            self.replace(|note| f(Option::some(note))).content\n        };\n\n        NoteEmission::new(\n            emission_content.note,\n            emission_content.storage_slot,\n            emission_content.note_hash_counter,\n            self.context,\n        )\n    }\n\n    /// Reads the current note of a PrivateMutable state variable instance.\n    ///\n    /// This function retrieves the current note, but with an important caveat: reading\n    /// a \"current\" note requires nullifying it to ensure that it is indeed current,\n    /// and that it and hasn't been nullified by some earlier transaction.\n    /// Having nullified the note, we then need to re-insert a new note with equal\n    /// value, so that this value remains available for future functions to read it\n    /// as \"current\".\n    ///\n    /// This is different from reading variables in Ethereum, where reading doesn't\n    /// modify the state. In Aztec's private state model, reading a \"current\" note\n    /// \"consumes\" it and creates a new note of equal value but with fresh\n    /// randomness.\n    ///\n    /// The returned note has the same content as the original but is actually the\n    /// newly-created note.\n    ///\n    /// ## Returns\n    ///\n    /// * `NoteEmission<Note>` - A type-safe wrapper containing the newly-created note.\n    ///                          You still need to decide whether to encrypt and send\n    ///                          the note to someone. You can call `.emit()` on it to\n    ///                          encrypt and log the note, or `.discard()` to skip\n    ///                          emission. See NoteEmission documentation for more details.\n    ///\n    /// ## Advanced\n    ///\n    /// This function performs the \"nullify-and-recreate\" pattern:\n    /// - Retrieves the current note from the PXE via an oracle call\n    /// - Validates that the note exists and belongs to this contract address and\n    ///   storage slot\n    /// - Nullifies the current note to ensure that it is indeed current\n    /// - Creates a new note with identical content but with fresh randomness\n    /// - Returns a NoteEmission for the new note\n    ///\n    /// This pattern ensures that:\n    /// - You're always reading the most up-to-date note\n    /// - Concurrent transactions can't create race conditions\n    /// - The note remains available for future reads (via the fresh copy)\n    ///\n    /// The kernel will inject a unique nonce into the newly-created note, which means\n    /// the new note will have a different nullifier, allowing it to be consumed in\n    /// the future.\n    ///\n    /// docs:start:get_note\n    pub fn get_note(self) -> NoteEmission<Note>\n    where\n        Note: Packable,\n    {\n        let mut (retrieved_note, note_hash_for_read_request) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, retrieved_note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, retrieved_note.note)\n    }\n}\n\nimpl<Note> PrivateMutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    /// Checks whether this PrivateMutable has been initialized.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// ## Returns\n    ///\n    /// * `bool` - `true` if the PrivateMutable has been initialized (the initialization\n    ///            nullifier exists), `false` otherwise.\n    ///\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    /// Returns the current note in this PrivateMutable without consuming it.\n    ///\n    /// This function is only available in a UtilityContext (unconstrained environment)\n    /// and is typically used for offchain queries, view functions, or testing.\n    ///\n    /// Unlike `get_note()`, this function does NOT nullify and recreate the note.\n    /// It simply reads the current note from the PXE's database without modifying\n    /// the state. This makes it suitable for read-only operations.\n    ///\n    /// This is conceptually similar to view functions in Ethereum that don't modify\n    /// state.\n    ///\n    /// ## Returns\n    ///\n    /// * `Note` - The current note stored in this PrivateMutable.\n    ///\n    /// docs:start:view_note\n    pub unconstrained fn view_note(self) -> Note\n    where\n        Note: Packable,\n    {\n        view_note(self.storage_slot).note\n    }\n}\n"
    },
    "187": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::Packable};\n\nmod test;\n\n/// # PrivateSet\n///\n/// PrivateSet is a private state variable type, which enables you to read, mutate,\n/// and write private state within the #[external(\"private\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PrivateSet within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PrivateSet<YourNote, Context>`\n/// or:\n/// `your_mapping: Map<Field, PrivateSet<YourNote, Context>>`\n///\n/// The PrivateSet type operates over notes, by facilitating: the insertion\n/// of new notes, the reading of existing notes, and the nullification of existing\n/// notes.\n///\n/// The methods of PrivateSet are:\n/// - `insert`\n/// - `pop_notes`\n/// - `get_notes`\n/// - `remove`\n/// (see the methods' own doc comments for more info).\n///\n/// The \"current value\" of a PrivateSet state variable is represented as a\n/// _collection_ (or \"Set\") of multiple notes.\n///\n/// > More exactly, the 'current value' is the collection of all\n/// > _not-yet-nullified_ notes in the set.\n///\n///\n/// ## Example.\n///\n/// A user's token balance can be represented as a PrivateSet of multiple notes,\n/// where the note type contains a value.\n/// The \"current value\" of the user's token balance (the PrivateSet state variable)\n/// can be interpreted as the summation of the values contained within all\n/// not-yet-nullified notes (aka \"current notes\") in the PrivateSet.\n///\n/// This is similar to a physical wallet containing five $10 notes: the owner's\n/// wallet balance is the sum of all those $10 notes: $50.\n/// To spend $2, they can get one $10 note, nullify it, and insert one $8 note as\n/// change. Their new wallet balance will then be interpreted as the new summation: $48.\n///\n/// The interpretation doesn't always have to be a \"summation of values\". When\n/// `get_notes` is called, PrivateSet does not attempt to interpret the notes at all;\n/// it's up to the custom code of the smart contract to make an interpretation.\n///\n/// For example: a set of notes could instead represent a moving average; or a modal\n/// value; or some other single statistic. Or the set of notes might not be\n/// collapsible into a single statistic: it could be a disjoint collection of NFTs\n/// which are housed under the same \"storage slot\".\n///\n/// It's worth noting that a user can prove existence of _at least_ some subset\n/// of notes in a PrivateSet, but they cannot prove existence of _all_ notes\n/// in a PrivateSet.\n/// The physical wallet is a good example: a user can prove that there are five\n/// $10 notes in their wallet by furnishing those notes. But because we cannot\n/// _see_ the entirety of their wallet, they might have many more notes that\n/// they're choosing to not showing us.\n///\n/// ## When to choose PrivateSet vs PrivateMutable:\n///\n/// - If you want _someone else_ (other than the owner of the private state) to be\n///   able to make edits (insert notes).\n/// - If you don't want to leak the storage_slot being initialized (see the\n///   PrivateMutable file).\n/// - If you find yourself needing to re-initialize a PrivateMutable (see that file).\n///\n/// The 'current' value of a _PrivateMutable_ state variable is only ever represented\n/// by _one_ note at a time. To mutate the current value of a PrivateMutable, the\n/// current note always gets nullified, and a new, replacement note gets inserted.\n/// So if nullification is always required to mutate a PrivateMutable, that means\n/// only the 'owner' of a given PrivateMutable state variable can ever mutate it.\n/// For some use cases, this can be too limiting: A key feature of some smart contract\n/// functions is that _multiple people_ are able to mutate a particular state\n/// variable.\n///\n/// PrivateSet enables \"other people\" (other than the owner of the private state) to\n/// mutate the 'current' value, with some limitations:\n/// The 'owner' is still the only person with the ability to `remove` notes from the\n/// the set.\n/// \"Other people\" can `insert` notes into the set.\n///\n/// It's important to notice that the \"owner\" of a state variable is an abstract\n/// concept which will differ depending on the rules of a smart contract. When we\n/// talk about the \"owner\" in the context of these aztec-nr files, we tend to mean\n/// \"the person who has the ability to nullify the state variable's notes\".\n/// Notice that the state variable abstractions of aztec-nr do not know what an\n/// \"owner\" is: they delegate responsibility of understanding who the \"owner\" of a\n/// note is to the note itself, via a `compute_nullifier` call.\n///\n///\n/// ## Privacy\n///\n/// The methods of a PrivateSet are only executable in a PrivateContext, and are\n/// designed to not leak anything about _which_ state variable was read/modified/\n/// inserted, to the outside world.\n///\n/// The design of the Note does impact the privacy of the state variable: the note\n/// will need to contain a `randomness` field so that, when hashed, the contents of\n/// the note are private.\n/// > Note: we decided to explicitly require `randomness` in a note definition,\n/// > because we anticipated use cases where notes might also be used to store\n/// > certain _public_ state. We might roll-back that decision, so that users don't\n/// > need to worry about handling their own randomness when defining custom notes.\n///\n/// The design of the note's custom `compute_nullifier` method will also impact the\n/// privacy of the note at the time it is nullified. (Note: all Notes must implement\n/// `compute_nullifier` to be compatible with PrivateSet). See the docs.\n///\n///\n/// # Struct Fields:\n///\n/// * context - The execution context (PrivateContext or UtilityContext).\n/// * storage_slot -  All notes that \"belong\" to a given PrivateSet state variable\n///                   are augmented with a common `storage_slot` field, as a way of\n///   identifying which set they belong to. (Management of `storage_slot` is handled\n///   within the innards of the PrivateSet impl, so you shouldn't need to think about\n///   this any further).\n///\n///\n/// # Generic Parameters:\n///\n/// * `Note` - Many notes of this type will collectively form the PrivateSet at the\n///            given storage_slot.\n/// * `Context` - The execution context (PrivateContext or UtilityContext).\n///\n/// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n\nimpl<T, Context> HasStorageSlot<1> for PrivateSet<T, Context> {\n    // Private storage slots are not really 'slots' but rather a value in the note\n    // hash preimage, so there is no notion of a value spilling over multiple slots.\n    // For this reason, PrivateSet (and all other private state variables) needs\n    // just one slot to be reserved, regardless of what it stores.\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    /// Initializes a new PrivateSet state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. All notes that \"belong\" to a given PrivateSet\n    ///                    state variable are augmented with a common `storage_slot`\n    ///                    field, as a way of identifying which set they belong to.\n    ///                    Usually, the #[storage] macro will determine an appropriate\n    ///                    storage_slot automatically. A smart contract dev shouldn't\n    ///                    have to worry about this, as it's managed behind the scenes.\n    ///\n    /// docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    /// Inserts a new `note` into the PrivateSet.\n    ///\n    /// # Arguments\n    ///\n    /// - `note` - A newly-created note that you would like to insert into this\n    ///            PrivateSet.\n    ///\n    /// # Returns\n    ///\n    /// - NoteEmission<Note> - A type-safe wrapper which makes it clear to the\n    ///                        smart contract dev that they now have a choice: they\n    ///   need to decide whether they would like to send the contents of the newly-\n    ///   created note to someone, or not. If they would like to, they have some\n    ///   further choices:\n    ///   - What kind of log to use? (Private log, or offchain log).\n    ///   - What kind of encryption scheme to use? (Currently only AES128 is supported)\n    ///   - Whether to _constrain_ delivery of the note, or not.\n    ///   At the moment, aztec-nr provides limited options.\n    ///   You can call `.emit()` on the returned type to encrypt and log the note, or\n    ///   `.discard()` to skip emission.\n    ///   See NoteEmission for more details.\n    ///   > Note: We're planning a _significant_ refactor of this syntax, to make the\n    ///     syntax of how to encrypt and deliver notes much clearer, and to make the\n    ///     default options much clearer to developers. We will also be enabling\n    ///     easier ways to customize your own note encryption options.\n    ///\n    /// # Advanced:\n    ///\n    /// Ultimately, this function inserts the `note` into the protocol's Note Hash\n    /// Tree.\n    /// Behind the scenes, we do the following:\n    /// - Augment the note with the `storage_slot` of this PrivateSet, to\n    ///   convey which set it belongs to.\n    /// - Augment the note with a `note_type_id`, so that it can be correctly filed-\n    ///   away when it is eventually discovered, decrypted, and processed by its\n    ///   intended recipient.\n    ///   (The note_type_id is usually allocated by the #[note] macro).\n    /// - Provide the contents of the (augmented) note to the PXE, so that it can\n    ///   store all notes created by the user executing this function.\n    ///   - The note is also kept in the PXE's memory during execution, in case this\n    ///     newly-created note gets _read_ in some later execution frame of this\n    ///     transaction. In such a case, we feed hints to the kernel to squash:\n    ///     the so-called \"transient note\", its note log (if applicable), and the\n    ///     nullifier that gets created by the reading function.\n    /// - Hash the (augmented) note into a single Field, via the note's own\n    ///   `compute_note_hash` method.\n    /// - Push the `note_hash` to the PrivateContext. From here, the protocol's\n    ///   kernel circuits will take over and insert the note_hash into the protocol's\n    ///   \"note hash tree\".\n    ///   - Before insertion, the protocol will:\n    ///     - \"Silo\" the `note_hash` with the `contract_address` of the calling\n    ///       function, to yield a `siloed_note_hash`. This prevents state collisions\n    ///       between different smart contracts.\n    ///     - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///       attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///       yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// docs:start:insert\n    pub fn insert(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n\n    /// Pops a collection of \"current\" notes (i.e. not-yet-nullified notes) which\n    /// belong to this PrivateSet.\n    ///\n    /// \"Pop\" indicates that, conceptually, the returned notes will get _permanently\n    /// removed_ (nullified) from the PrivateSet by this method.\n    ///\n    /// The act of nullifying convinces us that the returned notes are indeed\n    /// \"current\" (because if they can be nullified, it means they haven't been\n    /// nullified already, because a note can only be nullified once).\n    ///\n    /// This means that -- whilst the returned notes should be considered \"current\"\n    /// within the currently-executing execution frame of the tx -- they will be not\n    /// be considered \"current\" by any _later_ execution frame of this tx (or any\n    /// future tx).\n    ///\n    /// Notes will be selected from the PXE's database, via an oracle call, according\n    /// to the filtering `options` provided.\n    ///\n    /// # Arguments\n    ///\n    /// - `options` - See NoteGetterOptions. Enables the caller to specify the\n    ///               properties of the notes that must be returned by the oracle\n    ///               call to the PXE.\n    ///               The NoteGetterOptions are designed to contain functions which\n    ///               _constrain_ that the returned notes do indeed adhere to the\n    ///               specified options. Those functions are executed _within_ this\n    ///               `pop_notes` call.\n    ///\n    /// # Returns\n    ///\n    /// - BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    ///   - A vector of \"current\" notes, that have been constrained to satisfy the\n    ///     retrieval criteria specified by the given `options`.\n    ///\n    /// # Generic Parameters\n    ///\n    /// * `PreprocessorArgs` - See `NoteGetterOptions`.\n    /// * `FilterArgs` - See `NoteGetterOptions`.\n    /// * `M` - The length of the note (in Fields), when packed by the Packable trait.\n    ///\n    /// # Advanced:\n    ///\n    /// Reads the notes:\n    ///\n    /// - Gets notes from the PXE, via an oracle call, according to the filtering\n    ///   `options` provided.\n    /// - Constrains that the returned notes do indeed adhere to the `options`.\n    ///   (Note: the `options` contain _constrained_ functions that get invoked\n    ///   _within_ this function).\n    /// - Asserts that the notes do indeed belong to this calling function's\n    ///   `contract_address`, and to this PrivateSet's `storage_slot`.\n    /// - Computes the note_hash for each note, using the `storage_slot` and\n    ///   `contract_address` of this PrivateSet instance.\n    /// - Asserts that the note_hash does indeed exist:\n    ///   - For settled notes: makes a request to the kernel to perform a merkle\n    ///     membership check against the historical Note Hashes Tree that this tx\n    ///     is referencing.\n    ///   - For transient notes: makes a request to the kernel to ensure that the\n    ///     note was indeed emitted by some earlier execution frame of this tx.\n    ///\n    /// Nullifies the notes:\n    ///\n    /// - Computes the nullifier for each note.\n    ///   - (The nullifier computation differs depending on whether the note is\n    ///     settled or transient).\n    /// - Pushes the nullifiers to the PrivateContext. From here, the protocol's\n    ///   kernel circuits will take over and insert the nullifiers into the\n    ///   protocol's \"nullifier tree\".\n    ///   - Before insertion, the protocol will:\n    ///     - \"Silo\" each `nullifier` with the `contract_address` of the calling\n    ///       function, to yield a `siloed_nullifier`. This prevents nullifier\n    ///       collisions between different smart contracts.\n    ///     - Ensure that each `siloed_nullifier` does not already exist in the\n    ///       nullifier tree. The nullifier tree is an indexed merkle tree, which\n    ///       supports efficient non-membership proofs.\n    ///\n    pub fn pop_notes<PreprocessorArgs, FilterArgs, let M: u32>(\n        self,\n        options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N = M>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in fewer constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Permanently removes (conceptually) the given note from this PrivateSet,\n    /// by nullifying it.\n    ///\n    /// Note that if you obtained the note via `get_notes` it's much better to use\n    /// `pop_notes`, as `pop_notes` results in significantly fewer constraints,\n    /// due to avoiding an extra hash and read request check.\n    ///\n    /// # Arguments\n    ///\n    /// - `retrieved_note` - A note which -- earlier in the calling function's\n    ///                      execution -- has been retrieved from the PXE.\n    ///                      The `retrieved_note` is constrained to have been read\n    ///                      from the i\n    ///\n    /// # Returns\n    ///\n    /// - NoteEmission<Note> - A type-safe wrapper which makes it clear to the\n    ///                        smart contract dev that they now have a choice: they\n    ///   need to decide whether they would like to send the contents of the newly-\n    ///   created note to someone, or not. If they would like to, they have some\n    ///   further choices:\n    ///   - What kind of log to use? (Private log, or offchain log).\n    ///   - What kind of encryption scheme to use? (Currently only AES128 is supported)\n    ///   - Whether to _constrain_ delivery of the note, or not.\n    ///   At the moment, aztec-nr provides limited options.\n    ///   See NoteEmission for further details.\n    ///   > Note: We're planning a _significant_ refactor of this syntax, to make the\n    ///     syntax of how to encrypt and deliver notes much clearer, and to make the\n    ///     default options much clearer to developers. We will also be enabling\n    ///     easier ways to customize your own note encryption options.\n    ///\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read = self.context.note_hash_read_requests.any(|r| r.inner == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Returns a collection of which belong to this PrivateSet.\n    ///\n    /// DANGER: the returned notes do not get nullified within this `get_notes`\n    /// function, and so they cannot necessarily be considered \"current\" notes.\n    /// I.e. you might be reading notes that have already been nullified. It is\n    /// this which distinguishes `get_notes` from `pop_notes`.\n    ///\n    /// Note that if you later on remove the note it's much better to use\n    /// `pop_notes` as `pop_notes` results in significantly fewer constrains\n    /// due to avoiding 1 read request check.\n    /// If you need for your app to see the notes before it can decide which to\n    /// nullify (which ideally would not be the case, and you'd be able to rely\n    /// on the filter and preprocessor to do this), then you have no resort but\n    /// to call `get_notes` and then `remove`.\n    ///\n    /// Notes will be selected from the PXE's database, via an oracle call, according\n    /// to the filtering `options` provided.\n    ///\n    /// # Arguments\n    ///\n    /// - `options` - See NoteGetterOptions. Enables the caller to specify the\n    ///               properties of the notes that must be returned by the oracle\n    ///               call to the PXE.\n    ///               The NoteGetterOptions are designed to contain functions which\n    ///               _constrain_ that the returned notes do indeed adhere to the\n    ///               specified options. Those functions are executed _within_ this\n    ///               `pop_notes` call.\n    ///\n    /// # Returns\n    ///\n    /// - BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    ///   - A vector of \"current\" notes, that have been constrained to satisfy the\n    ///     retrieval criteria specified by the given `options`.\n    ///\n    /// # Generic Parameters\n    ///\n    /// * `PreprocessorArgs` - See `NoteGetterOptions`.\n    /// * `FilterArgs` - See `NoteGetterOptions`.\n    /// * `M` - The length of the note (in Fields), when packed by the Packable trait.\n    ///\n    /// # Advanced:\n    ///\n    /// Reads the notes:\n    ///\n    /// - Gets notes from the PXE, via an oracle call, according to the filtering\n    ///   `options` provided.\n    /// - Constrains that the returned notes do indeed adhere to the `options`.\n    ///   (Note: the `options` contain _constrained_ functions that get invoked\n    ///   _within_ this function).\n    /// - Asserts that the notes do indeed belong to this calling function's\n    ///   `contract_address`, and to this PrivateSet's `storage_slot`.\n    /// - Computes the note_hash for each note, using the `storage_slot` and\n    ///   `contract_address` of this PrivateSet instance.\n    /// - Asserts that the note_hash does indeed exist:\n    ///   - For settled notes: makes a request to the kernel to perform a merkle\n    ///     membership check against the historical Note Hashes Tree that this tx\n    ///     is referencing.\n    ///   - For transient notes: makes a request to the kernel to ensure that the\n    ///     note was indeed emitted by some earlier execution frame of this tx.\n    ///\n    pub fn get_notes<PreprocessorArgs, FilterArgs, let M: u32>(\n        self,\n        options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N = M>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    /// Returns a collection of notes which belong to this PrivateSet, according\n    /// to the given selection `options`.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Arguments\n    ///\n    /// - `options` - See NoteGetterOptions. Enables the caller to specify the\n    ///               properties of the notes that must be returned by the oracle\n    ///               call to the PXE.\n    ///\n    /// docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, <Note as Packable>::N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable,\n    {\n        view_notes(self.storage_slot, options)\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "211": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "212": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/collapse.nr",
      "source": "/// Collapses an array of `Option`s with sparse `Some` values into a `BoundedVec`, essentially unwrapping the `Option`s\n/// and removing the `None` values.\n///\n/// For example, given:\n///   `input: [some(3), none(), some(1)]`\n/// this returns\n///   `collapsed: [3, 1]`\npub fn collapse<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collapsed BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n\n    // Safety: The hints are verified by the `verify_collapse_hints` function.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\nfn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n\nmod test {\n    use super::{collapse, verify_collapse_hints};\n\n    #[test]\n    unconstrained fn collapse_empty_array() {\n        let original: [Option<Field>; 2] = [Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn collapse_non_sparse_array() {\n        let original = [Option::some(7), Option::some(3), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_sparse_array() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_front_padding() {\n        let original =\n            [Option::none(), Option::none(), Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn collapse_back_padding() {\n        let original =\n            [Option::some(7), Option::none(), Option::some(3), Option::none(), Option::none()];\n        let collapsed = collapse(original);\n\n        assert_eq(collapsed.len(), 2);\n        assert_eq(collapsed.get(0), 7);\n        assert_eq(collapsed.get(1), 3);\n    }\n\n    #[test]\n    unconstrained fn verify_collapse_hints_good_hints() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec length\")]\n    unconstrained fn verify_collapse_hints_wrong_length() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Collapse hint vec length mismatch\")]\n    unconstrained fn verify_collapse_hints_hint_length_mismatch() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Out of bounds index hint\")]\n    unconstrained fn verify_collapse_hints_out_of_bounds_index_hint() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 3]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 5]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn verify_collapse_hints_hint_to_none() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 0]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 1]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec content\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_content() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([7, 42]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Wrong collapsed vec order\")]\n    unconstrained fn verify_collapse_hints_wrong_vec_order() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n        let collapsed = BoundedVec::from_array([3, 7]);\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([2, 0]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n    #[test(should_fail_with = \"Dirty collapsed vec storage\")]\n    unconstrained fn verify_collapse_hints_dirty_storage() {\n        let original = [Option::some(7), Option::none(), Option::some(3)];\n\n        let mut collapsed: BoundedVec<u32, 3> = BoundedVec::from_array([7, 3]);\n        // We have to use the unchecked setter as we're knowingly writing past the length, breaking its invariants.\n        collapsed.set_unchecked(2, 1);\n\n        let collapsed_to_input_index_mapping = BoundedVec::from_array([0, 2]);\n\n        verify_collapse_hints(original, collapsed, collapsed_to_input_index_mapping);\n    }\n\n}\n"
    },
    "214": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "215": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "216": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/comparison.nr",
      "source": "struct ComparatorEnum {\n    pub EQ: u8,\n    pub NEQ: u8,\n    pub LT: u8,\n    pub LTE: u8,\n    pub GT: u8,\n    pub GTE: u8,\n}\n\npub global Comparator: ComparatorEnum =\n    ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::Comparator;\n    use super::compare;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"
    },
    "217": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "218": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "221": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "232": {
      "path": "/home/karyia/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "295": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "298": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Empty, Serialize, ToField},\n};\nuse std::meta::derive;\n\n// Partial address\n#[derive(Deserialize, Eq, Serialize)]\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Empty for PartialAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\nmod test {\n    use crate::{address::partial_address::PartialAddress, traits::{Deserialize, Serialize}};\n\n    #[test]\n    fn serialization_of_partial_address() {\n        let item = PartialAddress::from_field(1);\n        let serialized: [Field; 1] = item.serialize();\n        let deserialized = PartialAddress::deserialize(serialized);\n        assert_eq(item, deserialized);\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "300": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\n#[derive(Eq)]\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "304": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n\nmod test {\n    use crate::{\n        address::AztecAddress,\n        constants::CONTRACT_INSTANCE_LENGTH,\n        contract_class_id::ContractClassId,\n        contract_instance::ContractInstance,\n        public_keys::PublicKeys,\n        traits::{Deserialize, FromField, Serialize},\n    };\n\n    #[test]\n    fn serde() {\n        let instance = ContractInstance {\n            salt: 6,\n            deployer: AztecAddress::from_field(12),\n            contract_class_id: ContractClassId::from_field(13),\n            initialization_hash: 156,\n            public_keys: PublicKeys::default(),\n        };\n\n        // We use the CONTRACT_INSTANCE_LENGTH constant to ensure that there is a match between the derived trait\n        // implementation and the constant.\n        let serialized: [Field; CONTRACT_INSTANCE_LENGTH] = instance.serialize();\n\n        let deserialized = ContractInstance::deserialize(serialized);\n\n        assert(instance.eq(deserialized));\n    }\n\n}\n"
    },
    "310": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "320": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "333": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "334": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "335": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "336": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "343": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "364": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "366": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "367": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "385": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "389": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "50": {
      "path": "/home/karyia/Code/Aztec/covenant_aztec/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\npub mod types;\n\n#[aztec]\ncontract Governance {\n    use crate::types::members_note::MembersNote;\n    use crate::types::proposal_note::ProposalNote;\n    use aztec::context;\n    use aztec::keys::getters::get_public_keys;\n    use aztec::{\n        macros::{functions::{external, initializer}, storage::storage},\n        note::{note_getter_options::NoteGetterOptions, note_interface::NoteProperties},\n        protocol_types::{address::AztecAddress, hash::poseidon2_hash, traits::Hash},\n        state_vars::{private_mutable::PrivateMutable, private_set::PrivateSet},\n        utils::comparison::Comparator,\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        members: PrivateMutable<MembersNote, Context>,\n        proposals: PrivateSet<ProposalNote, Context>,\n    }\n\n    #[external(\"private\")]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        let mut members = [0; 10];\n        members[0] = admin.inner;\n        let members_note = MembersNote::new(context.this_address(), members);\n        let _ = storage.members.initialize(members_note);\n    }\n\n    #[external(\"private\")]\n    fn cast_vote(proposal_id: Field, choice: u32) {\n        // Check if caller is a member\n        let members_note = storage.members.get_note();\n        let msg_sender = context.msg_sender().unwrap();\n        let mut is_member = false;\n\n        // Check membership\n        for i in 0..10 {\n            if members_note.content.note.members[i] == msg_sender.inner {\n                is_member = true;\n            }\n        }\n        assert(is_member, \"Not a member\");\n\n        let _ = storage.members.initialize(members_note.content.note);\n\n        // Find the proposal\n        let options = NoteGetterOptions::new()\n            .select(ProposalNote::properties().proposal_id, Comparator.EQ, proposal_id)\n            .set_limit(1);\n        let notes = storage.proposals.pop_notes(options);\n        assert(notes.len() == 1, \"Proposal not found\");\n\n        // Create nullifier to prevent double voting\n        let msg_sender_npk_hash = get_public_keys(msg_sender).npk_m.hash();\n        let secret = context.request_nsk_app(msg_sender_npk_hash);\n        let nullifier = poseidon2_hash([proposal_id, secret]);\n        context.push_nullifier(nullifier);\n\n        // Update the proposal with the vote\n        let retrieved_note = notes.get_unchecked(0);\n\n        // Use the vote method to update tally\n        let updated_proposal = retrieved_note.vote(choice);\n\n        // Remove old proposal and add updated one\n        let insertion = storage.proposals.insert(updated_proposal);\n    }\n\n}\n"
    },
    "52": {
      "path": "/home/karyia/Code/Aztec/covenant_aztec/src/types/members_note.nr",
      "source": "use aztec::{\n    context::private_context::PrivateContext,\n    macros::notes::custom_note,\n    note::note_interface::NoteHash,\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Packable, Serialize, ToField},\n    },\n};\n\n#[derive(Eq, Serialize, Deserialize, Packable)]\n#[custom_note]\npub struct MembersNote {\n    pub gov_contract: AztecAddress,\n    pub members: [Field; 10],\n    pub randomness: Field,\n}\n\nimpl NoteHash for MembersNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        let secret = self.pack().concat([storage_slot]);\n        poseidon2_hash_with_separator(secret, GENERATOR_INDEX__NOTE_HASH)\n    }\n\n    fn compute_nullifier(self, _: &mut PrivateContext, note_hash_to_nullify: Field) -> Field {\n        poseidon2_hash_with_separator(\n            [note_hash_to_nullify, self.gov_contract.to_field()],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_to_nullify: Field) -> Field {\n        poseidon2_hash_with_separator(\n            [note_hash_to_nullify, self.gov_contract.to_field()],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl MembersNote {\n    pub fn new(gov_contract: AztecAddress, members: [Field; 10]) -> Self {\n        // Safety: Using random() is safe here as it's for generating randomness for note uniqueness\n        let randomness = unsafe { random() };\n        MembersNote { gov_contract, members, randomness }\n    }\n}\n"
    },
    "53": {
      "path": "/home/karyia/Code/Aztec/covenant_aztec/src/types/proposal_note.nr",
      "source": "use aztec::{\n    context::private_context::PrivateContext,\n    macros::notes::custom_note,\n    note::note_interface::NoteHash,\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Packable, Serialize, ToField},\n    },\n};\n\n#[derive(Eq, Serialize, Deserialize, Packable)]\n#[custom_note]\npub struct ProposalNote {\n    pub gov_contract: AztecAddress,\n    pub proposal_id: Field,\n    pub votes_for: Field,\n    pub votes_against: Field,\n    pub randomness: Field,\n}\n\nimpl NoteHash for ProposalNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        let secret = self.pack().concat([storage_slot]);\n        poseidon2_hash_with_separator(secret, GENERATOR_INDEX__NOTE_HASH)\n    }\n\n    fn compute_nullifier(self, _: &mut PrivateContext, note_hash_to_nullify: Field) -> Field {\n        poseidon2_hash_with_separator(\n            [note_hash_to_nullify, self.gov_contract.to_field()],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_to_nullify: Field) -> Field {\n        poseidon2_hash_with_separator(\n            [note_hash_to_nullify, self.gov_contract.to_field()],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl ProposalNote {\n    pub fn new(gov_contract: AztecAddress, proposal_id: Field) -> Self {\n        // Safety: Using random() is safe here as it's for generating randomness for note uniqueness\n        let randomness = unsafe { random() };\n        ProposalNote { gov_contract, proposal_id, votes_for: 0, votes_against: 0, randomness }\n    }\n\n    pub fn vote(self, choice: u32) -> Self {\n        // Safety: Using random() is safe here as it's for generating randomness for note uniqueness\n        let randomness = unsafe { random() };\n        \n        let (new_votes_for, new_votes_against) = if choice == 0 {\n            (self.votes_for, self.votes_against + 1)\n        } else if choice == 1 {\n            (self.votes_for + 1, self.votes_against)\n        } else {\n            assert(false, \"Invalid choice\");\n            (self.votes_for, self.votes_against)\n        };\n        \n        ProposalNote { \n            gov_contract: self.gov_contract, \n            proposal_id: self.proposal_id, \n            votes_for: new_votes_for, \n            votes_against: new_votes_against, \n            randomness \n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "71": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "74": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "79": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "96": {
      "path": "/home/karyia/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.5/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    }
  }
}
